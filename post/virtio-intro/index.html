<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【翻译】Virtio：一种Linux I/O虚拟化框架 | hhdx's blog</title>
<meta name=keywords content="qemu,virtio"><meta name=description content="首发于安全客Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)
原文：Virtio: An I/O virtualization framework for Linux – IBM Developer

学习Virtio推荐首先看这一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。
受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。
简言之，virtio是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。virtio是Rusty Russell为了支持他自己的虚拟化方案lguest而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻virtio中的一些细节。采用kernel 2.6.30版本的virtio框架进行讲解。
Linux是hypervisor的“游乐场”。正如我在文章使用Linux作为hypervisor中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，lguest、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。virtio为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。
全虚拟化 vs. 半虚拟化
我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。
译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。
在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。"><meta name=author content="hhdx"><link rel=canonical href=https://hhdx.xyz/post/virtio-intro/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://hhdx.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hhdx.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hhdx.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://hhdx.xyz/apple-touch-icon.png><link rel=mask-icon href=https://hhdx.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://hhdx.xyz/post/virtio-intro/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hhdx.xyz/post/virtio-intro/"><meta property="og:site_name" content="hhdx's blog"><meta property="og:title" content="【翻译】Virtio：一种Linux I/O虚拟化框架"><meta property="og:description" content="首发于安全客Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)
原文：Virtio: An I/O virtualization framework for Linux – IBM Developer
学习Virtio推荐首先看这一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。
受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。
简言之，virtio是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。virtio是Rusty Russell为了支持他自己的虚拟化方案lguest而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻virtio中的一些细节。采用kernel 2.6.30版本的virtio框架进行讲解。
Linux是hypervisor的“游乐场”。正如我在文章使用Linux作为hypervisor中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，lguest、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。virtio为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。
全虚拟化 vs. 半虚拟化 我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。
译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。
在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-11-27T14:43:05+00:00"><meta property="article:modified_time" content="2020-11-27T14:43:05+00:00"><meta property="article:tag" content="Qemu"><meta property="article:tag" content="Virtio"><meta name=twitter:card content="summary"><meta name=twitter:title content="【翻译】Virtio：一种Linux I/O虚拟化框架"><meta name=twitter:description content="首发于安全客Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)
原文：Virtio: An I/O virtualization framework for Linux – IBM Developer

学习Virtio推荐首先看这一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。
受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。
简言之，virtio是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。virtio是Rusty Russell为了支持他自己的虚拟化方案lguest而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻virtio中的一些细节。采用kernel 2.6.30版本的virtio框架进行讲解。
Linux是hypervisor的“游乐场”。正如我在文章使用Linux作为hypervisor中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，lguest、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。virtio为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。
全虚拟化 vs. 半虚拟化
我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。
译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。
在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hhdx.xyz/post/"},{"@type":"ListItem","position":2,"name":"【翻译】Virtio：一种Linux I/O虚拟化框架","item":"https://hhdx.xyz/post/virtio-intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【翻译】Virtio：一种Linux I/O虚拟化框架","name":"【翻译】Virtio：一种Linux I\/O虚拟化框架","description":"首发于安全客Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)\n原文：Virtio: An I/O virtualization framework for Linux – IBM Developer\n学习Virtio推荐首先看这一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。\n受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。\n简言之，virtio是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。virtio是Rusty Russell为了支持他自己的虚拟化方案lguest而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻virtio中的一些细节。采用kernel 2.6.30版本的virtio框架进行讲解。\nLinux是hypervisor的“游乐场”。正如我在文章使用Linux作为hypervisor中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，lguest、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。virtio为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。\n全虚拟化 vs. 半虚拟化 我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。\n译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。\n在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。\n","keywords":["qemu","virtio"],"articleBody":"首发于安全客Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)\n原文：Virtio: An I/O virtualization framework for Linux – IBM Developer\n学习Virtio推荐首先看这一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。\n受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。\n简言之，virtio是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。virtio是Rusty Russell为了支持他自己的虚拟化方案lguest而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻virtio中的一些细节。采用kernel 2.6.30版本的virtio框架进行讲解。\nLinux是hypervisor的“游乐场”。正如我在文章使用Linux作为hypervisor中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，lguest、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。virtio为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。\n全虚拟化 vs. 半虚拟化 我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。\n译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。\n在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。\n图1. 全虚拟化和半虚拟化中的设备仿真\n硬件也随着虚拟化不断地发展着。新处理器加入了高级指令，使客户机操作系统和hypervisor的切换更加高效。硬件也随着I/O虚拟化不断地发生改变（参照Resource了解PCI passthrough和单/多根I/O虚拟化）。\n在传统的全虚拟化环境中，hypervisor必须陷入(trap)请求，然后模仿真实硬件的行为。尽管这样提供了很大的灵活性（指可以运行不必修改的操作系统），但却造成了低效率（图1左侧）。图1右侧展示了半虚拟化。客户机操作系统知道运行于虚拟机之中，加入了驱动作为前端。hypervisor为特定设备仿真实现了后端驱动。这里的前端后端就是virtio的构件，提供了标准化接口，提高了设备仿真开发的代码复用程度和仿真设备运行的效率。\n作者注：virtio并不是半虚拟化领域的唯一存在。Xen提供了半虚拟化的设备驱动，VMware也提供了名为Guest Tools的半虚拟化支持。\nLinux客户机中的一种抽象 如前节所述，virtio为半虚拟化提供了一系列通用设备仿真的接口。这种设计允许hypervisor导出一套通用的设备仿真操作，只要使用这一套接口就能够工作。图2解释了为什么这很重要。通过半虚拟化，客户机实现了通用的接口，同时虚拟化管理程序提供设备仿真的后端驱动。后端驱动并不一定要一致，只要它实现了前端所需的各种操作就可以。\n图2. 使用virtio的驱动抽象\n注意在实际中，使用用户空间的QEMU程序来进行设备仿真，所以后端驱动通过QEMU的I/O来与用户空间的hypervisor通信。QEMU是系统模拟器，包括提供客户机操作系统虚拟化平台，提供整个系统的仿真（PCI host controller, disk, network, video hardware, USB controller等）。\nvirtio依靠于简单的缓存管理，用来存储客户机的命令与客户机所需的数据。我们继续来看virtio的API及其构件。\nVirtio 架构 除了前端驱动（在客户机操作系统中实现）和后端驱动（在hypervisor中实现）之外，virtio还定义了两层来支持客户机与hypervisor进行通讯。虚拟队列(Virtual Queue)接口将前端驱动和后端驱动结合在一起。驱动可以有0个或多个队列，依赖于它们的需要。例如，virtio网络驱动使用了两个虚拟队列（一个用于接收一个用于发送），而virtio块设备驱动只需要一个。虚拟队列，通常使用环形缓冲，在客户机与虚拟机管理器之间传输。可以使用任意方式实现，只要客户机与虚拟机管理器相统一。\n图3. virtio框架的架构\n如图3，包含了五种前端驱动：块设备（如硬盘）、网络设备、PCI仿真、balloon驱动（用于动态的管理客户机内存使用）和一个终端驱动。每一个前端驱动，在hypervisor中都有一个相匹配的后端驱动。\n概念层级 在客户机的视角来看，对象层级如图4所示。顶端是virtio_driver，表示客户机中的前端驱动。与驱动相匹配的设备被封装在virtio_device（在客户机中表示设备），其中有成员config指向virtio_config_ops结构（其中定义了配置virtio设备的操作）。virtqueue中有成员vdev指向virtio_device（也就是指向它所服务的某一设备virtio_device）。最下面，每个virtio_queue中有个类型为virtqueue_ops的对象，其中定义了与hypervisor交互的虚拟队列操作。\n图4. virtio前端的对象层级\n这一过程起始于virtio_driver的创建和后续的使用register_virtio_driver将驱动进行注册。virtio_driver结构定义了设备驱动的上层结构，包含了它所支持的设备的设备ID，特性表（根据设备的类型有所不同），和一系列回调函数。当hypervisor发现新设备，并且匹配到了设备ID，就会以virtio_device为参数调用probe函数（于virtio_driver中提供）。这一结构与管理数据一起被缓存（以独立于驱动的方式）。根据设备的类型，virtio_config_ops中的可能会被调用，以获取或设置设备相关的选项（例如，获取硬盘块设备的读/写状态或者设置块设备的块大小）。\n注意，virtio_device中没有包含指向所对应virtqueue的成员（virtqueue有指向virtio_device的成员）。为了得到与virtio_device相关联的virtqueue，需要使用virtio_config_ops结构中的find_vq函数。这个函数返回与该virtqueue相关联的设备实例。find_vq还允许为virtqueue指定回调函数，用于在hypervisor准备好数据时，通知客户机。\nvirtqueue结构包含可选的回调函数（用于在hypervisor填充缓冲后，通知客户机）、一个指向virtio_device、一个指向virtqueue操作和一个特别的priv用于底层实现使用。callback是可选的，也可以动态的启用或禁用。\n这个层级的核心是virtqueue_ops，其中定义了如何在客户机和hypervisor之间传输命令与数据。我们先来探索virtqueue中对象的添加和删除操作。\nVirtio缓冲 客户机驱动（前端）与hypervisor（后端）通过缓冲区进行通信。对于一次I/O，客户机提供一个或多个缓冲区表示请求。例如，你可以使用三个缓冲区，其中一个用来存储读请求，其他两个用来存储回复数据。内部这个配置被表示为分散/聚集(scatter-gather)列表（列表中的每个元素存储有缓冲区地址与长度）。\n核心API 将客户机驱动与hypervisor驱动链接起来，偶尔是通过virtio_device，大多数情况下都是通过virtqueue。virtqueue支持五个API函数。使用第一个函数add_buf向hypervisor添加请求，这种请求以分散/聚集列表的形式，正如先前讨论的。为了提交请求，客户机必须提供请求命令，分散/聚集列表（以缓冲区地址和长度为元素的数组），向外提供请求的缓冲区的数量（也就是发送请求信息给hypervisor），向内传递数据的缓冲区的数量（hypervisor用来填充数据，返回给客户机）。当客户机通过add_buf向hypervisor提交一条请求后，客户机就可以使用kick通知hypervisor新请求已递送。但为了更好地性能，客户机应该在kick通知hypervisor之前，提交尽可能多的请求。\n客户机使用get_buf接收从hypervisor中返回的数据。客户机可以简单地使用get_buf轮询或者等待由virtqueue callback函数的通知。当客户机知道了缓冲区数据可用，就会使用get_buf获取数据。\n最后两个virtqueue的API是enable_cb和disable_cb，可用使用这两个函数启用和禁用回调函数（callback函数使用find_vq初始化设置）。注意回调函数与hypervisor在不同的地址空间，所以调用需要间接调用(indirect hypervisor call)（例如：kvm_hypercall）。\n缓冲区的格式、顺序与内容支队前端和后端驱动有意义。内部传送（现在使用环形缓冲区实现）只传输缓冲区，并不知道内部表达的意义。\nVirtio驱动例子 对于各种各样前端驱动，可以在Linux内核源码的./drivers子目录下找到。virtio网络驱动在./driver/net/virtio_net.c，virtio块驱动在./driver/block/virtio_blk.c。./driver/virtio子目录下提供了virtio接口的实现(virtio设备、驱动、virtqueue和环形缓冲区)。virtio也被用在了高性能计算(High-Performance Computing, HPC)研究之中，使用共享内存传递内部虚拟机的信息。特别的，这使用了virtio来实现虚拟化PCI接口。可以再resources中找到相关工作。\n你可以在Linux内核中练习半虚拟化基础工作。你所需要的就是一个作为hypervisor的内核，客户机内核和用来仿真设备的QEMU。你可以使用KVM(一个存在于宿主机内核中的模块)或者Rusty Russell的lguest（一个修改过的Linux内核）。两种方案都支持virtio（配合以QEMU进行系统模拟和libvirt进行虚拟化管理）。\nRusty的成果是简化了半虚拟化驱动的开发，并且设备仿真性能更高。最重要的还是，virtio能够提供更好地性能（两三倍的网络I/O）比现有的商业解决方案。虽说有一定的代价，但如果你的hypervisor和客户机系统是Linux，还是非常值得的。\n进一步 尽管你可以永远不会为virtio开发前端或者后端驱动，但它实现了一个有趣的架构，值得更加细致的理解它。与先前的Xen相比，virtio为了半虚拟化提高性能提供了新的可能。在作为投入使用的hypervisor和新虚拟技术的实验平台中，Linux不断地证明了它自己。virtio再一次证明了Linux作为hypervisor的优势和开放性。\nResources Virtio: towards a de factor standard for virtual I/O devices\nAnatomy of a Linux hypervisor\nLinux virtualization and PCI passthrough\nperformance advantage of virtio using KVM\nlibvirt wiki\nlguest\nKVM\nshared-memory message passing\n","wordCount":"4863","inLanguage":"zh-cn","datePublished":"2020-11-27T14:43:05Z","dateModified":"2020-11-27T14:43:05Z","author":{"@type":"Person","name":"hhdx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hhdx.xyz/post/virtio-intro/"},"publisher":{"@type":"Organization","name":"hhdx's blog","logo":{"@type":"ImageObject","url":"https://hhdx.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hhdx.xyz/ accesskey=h title="hhdx's blog (Alt + H)">hhdx's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hhdx.xyz/ title=主页><span>主页</span></a></li><li><a href=https://hhdx.xyz/post/ title=归档><span>归档</span></a></li><li><a href=https://hhdx.xyz/tags/ title=标签><span>标签</span></a></li><li><a href=https://hhdx.xyz/underway/ title=施工中><span>施工中</span></a></li><li><a href=https://hhdx.xyz/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">【翻译】Virtio：一种Linux I/O虚拟化框架</h1><div class=post-meta><span title='2020-11-27 14:43:05 +0000 UTC'>November 27, 2020</span>&nbsp;·&nbsp;hhdx</div></header><div class=post-content><p>首发于安全客<a href=https://www.anquanke.com/post/id/224001>Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)</a></p><p>原文：<a href=https://developer.ibm.com/articles/l-virtio/>Virtio: An I/O virtualization framework for Linux – IBM Developer</a></p><blockquote><p>学习Virtio推荐首先看这一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。</p><p><strong>受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。</strong></p></blockquote><p>简言之，<code>virtio</code>是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。<code>virtio</code>是Rusty Russell为了支持他自己的虚拟化方案<code>lguest</code>而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻<code>virtio</code>中的一些细节。采用kernel 2.6.30版本的<code>virtio</code>框架进行讲解。</p><p>Linux是hypervisor的“游乐场”。正如我在文章<a href=https://developer.ibm.com/tutorials/l-hypervisor/>使用Linux作为hypervisor</a>中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，<code>lguest</code>、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。<code>virtio</code>为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。</p><h2 id=全虚拟化-vs-半虚拟化>全虚拟化 vs. 半虚拟化<a hidden class=anchor aria-hidden=true href=#全虚拟化-vs-半虚拟化>#</a></h2><p>我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。</p><p><em>译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。</em></p><p>在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。</p><p><strong>图1. 全虚拟化和半虚拟化中的设备仿真</strong></p><p><img alt=figure1 loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgfigure1.jpg></p><p>硬件也随着虚拟化不断地发展着。新处理器加入了高级指令，使客户机操作系统和hypervisor的切换更加高效。硬件也随着I/O虚拟化不断地发生改变（参照Resource了解PCI passthrough和单/多根I/O虚拟化）。</p><p>在传统的全虚拟化环境中，hypervisor必须陷入(trap)请求，然后模仿真实硬件的行为。尽管这样提供了很大的灵活性（指可以运行不必修改的操作系统），但却造成了低效率（图1左侧）。图1右侧展示了半虚拟化。客户机操作系统知道运行于虚拟机之中，加入了驱动作为前端。hypervisor为特定设备仿真实现了后端驱动。这里的前端后端就是<code>virtio</code>的构件，提供了标准化接口，提高了设备仿真开发的代码复用程度和仿真设备运行的效率。</p><p><em>作者注：<code>virtio</code>并不是半虚拟化领域的唯一存在。Xen提供了半虚拟化的设备驱动，VMware也提供了名为<code>Guest Tools</code>的半虚拟化支持。</em></p><h2 id=linux客户机中的一种抽象>Linux客户机中的一种抽象<a hidden class=anchor aria-hidden=true href=#linux客户机中的一种抽象>#</a></h2><p>如前节所述，<code>virtio</code>为半虚拟化提供了一系列通用设备仿真的接口。这种设计允许hypervisor导出一套通用的设备仿真操作，只要使用这一套接口就能够工作。图2解释了为什么这很重要。通过半虚拟化，客户机实现了通用的接口，同时虚拟化管理程序提供设备仿真的后端驱动。后端驱动并不一定要一致，只要它实现了前端所需的各种操作就可以。</p><p><strong>图2. 使用virtio的驱动抽象</strong></p><p><img alt=figure2 loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgfigure2.jpg></p><p>注意在实际中，使用用户空间的QEMU程序来进行设备仿真，所以后端驱动通过QEMU的I/O来与用户空间的hypervisor通信。QEMU是系统模拟器，包括提供客户机操作系统虚拟化平台，提供整个系统的仿真（PCI host controller, disk, network, video hardware, USB controller等）。</p><p><code>virtio</code>依靠于简单的缓存管理，用来存储客户机的命令与客户机所需的数据。我们继续来看<code>virtio</code>的API及其构件。</p><h2 id=virtio-架构>Virtio 架构<a hidden class=anchor aria-hidden=true href=#virtio-架构>#</a></h2><p>除了前端驱动（在客户机操作系统中实现）和后端驱动（在hypervisor中实现）之外，<code>virtio</code>还定义了两层来支持客户机与hypervisor进行通讯。虚拟队列(Virtual Queue)接口将前端驱动和后端驱动结合在一起。驱动可以有0个或多个队列，依赖于它们的需要。例如，<code>virtio</code>网络驱动使用了两个虚拟队列（一个用于接收一个用于发送），而<code>virtio</code>块设备驱动只需要一个。虚拟队列，通常使用环形缓冲，在客户机与虚拟机管理器之间传输。可以使用任意方式实现，只要客户机与虚拟机管理器相统一。</p><p><strong>图3. virtio框架的架构</strong></p><p><img alt=figure3 loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgfigure3.jpg></p><p>如图3，包含了五种前端驱动：块设备（如硬盘）、网络设备、PCI仿真、balloon驱动（用于动态的管理客户机内存使用）和一个终端驱动。每一个前端驱动，在hypervisor中都有一个相匹配的后端驱动。</p><h2 id=概念层级>概念层级<a hidden class=anchor aria-hidden=true href=#概念层级>#</a></h2><p>在客户机的视角来看，对象层级如图4所示。顶端是<code>virtio_driver</code>，表示客户机中的前端驱动。与驱动相匹配的设备被封装在<code>virtio_device</code>（在客户机中表示设备），其中有成员<code>config</code>指向<code>virtio_config_ops</code>结构（其中定义了配置<code>virtio</code>设备的操作）。<code>virtqueue</code>中有成员<code>vdev</code>指向<code>virtio_device</code>（也就是指向它所服务的某一设备<code>virtio_device</code>）。最下面，每个<code>virtio_queue</code>中有个类型为<code>virtqueue_ops</code>的对象，其中定义了与hypervisor交互的虚拟队列操作。</p><p><strong>图4. virtio前端的对象层级</strong></p><p><img alt=figure4 loading=lazy src=https://raw.githubusercontent.com/clxsh/pics/master/imgfigure4.jpg></p><p>这一过程起始于<code>virtio_driver</code>的创建和后续的使用<code>register_virtio_driver</code>将驱动进行注册。<code>virtio_driver</code>结构定义了设备驱动的上层结构，包含了它所支持的设备的设备ID，特性表（根据设备的类型有所不同），和一系列回调函数。当hypervisor发现新设备，并且匹配到了设备ID，就会以<code>virtio_device</code>为参数调用<code>probe</code>函数（于<code>virtio_driver</code>中提供）。这一结构与管理数据一起被缓存（以独立于驱动的方式）。根据设备的类型，<code>virtio_config_ops</code>中的可能会被调用，以获取或设置设备相关的选项（例如，获取硬盘块设备的读/写状态或者设置块设备的块大小）。</p><p>注意，<code>virtio_device</code>中没有包含指向所对应<code>virtqueue</code>的成员（<code>virtqueue</code>有指向<code>virtio_device</code>的成员）。为了得到与<code>virtio_device</code>相关联的<code>virtqueue</code>，需要使用<code>virtio_config_ops</code>结构中的<code>find_vq</code>函数。这个函数返回与该<code>virtqueue</code>相关联的设备实例。<code>find_vq</code>还允许为<code>virtqueue</code>指定回调函数，用于在hypervisor准备好数据时，通知客户机。</p><p><code>virtqueue</code>结构包含可选的回调函数（用于在hypervisor填充缓冲后，通知客户机）、一个指向<code>virtio_device</code>、一个指向<code>virtqueue</code>操作和一个特别的<code>priv</code>用于底层实现使用。<code>callback</code>是可选的，也可以动态的启用或禁用。</p><p>这个层级的核心是<code>virtqueue_ops</code>，其中定义了如何在客户机和hypervisor之间传输命令与数据。我们先来探索<code>virtqueue</code>中对象的添加和删除操作。</p><h2 id=virtio缓冲>Virtio缓冲<a hidden class=anchor aria-hidden=true href=#virtio缓冲>#</a></h2><p>客户机驱动（前端）与hypervisor（后端）通过缓冲区进行通信。对于一次I/O，客户机提供一个或多个缓冲区表示请求。例如，你可以使用三个缓冲区，其中一个用来存储读请求，其他两个用来存储回复数据。内部这个配置被表示为分散/聚集(scatter-gather)列表（列表中的每个元素存储有缓冲区地址与长度）。</p><h2 id=核心api>核心API<a hidden class=anchor aria-hidden=true href=#核心api>#</a></h2><p>将客户机驱动与hypervisor驱动链接起来，偶尔是通过<code>virtio_device</code>，大多数情况下都是通过<code>virtqueue</code>。<code>virtqueue</code>支持五个API函数。使用第一个函数<code>add_buf</code>向hypervisor添加请求，这种请求以分散/聚集列表的形式，正如先前讨论的。为了提交请求，客户机必须提供请求命令，分散/聚集列表（以缓冲区地址和长度为元素的数组），向外提供请求的缓冲区的数量（也就是发送请求信息给hypervisor），向内传递数据的缓冲区的数量（hypervisor用来填充数据，返回给客户机）。当客户机通过<code>add_buf</code>向hypervisor提交一条请求后，客户机就可以使用<code>kick</code>通知hypervisor新请求已递送。但为了更好地性能，客户机应该在<code>kick</code>通知hypervisor之前，提交尽可能多的请求。</p><p>客户机使用<code>get_buf</code>接收从hypervisor中返回的数据。客户机可以简单地使用<code>get_buf</code>轮询或者等待由<code>virtqueue callback</code>函数的通知。当客户机知道了缓冲区数据可用，就会使用<code>get_buf</code>获取数据。</p><p>最后两个<code>virtqueue</code>的API是<code>enable_cb</code>和<code>disable_cb</code>，可用使用这两个函数启用和禁用回调函数（<code>callback</code>函数使用<code>find_vq</code>初始化设置）。注意回调函数与hypervisor在不同的地址空间，所以调用需要间接调用(indirect hypervisor call)（例如：<code>kvm_hypercall</code>）。</p><p>缓冲区的格式、顺序与内容支队前端和后端驱动有意义。内部传送（现在使用环形缓冲区实现）只传输缓冲区，并不知道内部表达的意义。</p><h2 id=virtio驱动例子>Virtio驱动例子<a hidden class=anchor aria-hidden=true href=#virtio驱动例子>#</a></h2><p>对于各种各样前端驱动，可以在Linux内核源码的<code>./drivers</code>子目录下找到。<code>virtio</code>网络驱动在<code>./driver/net/virtio_net.c</code>，<code>virtio</code>块驱动在<code>./driver/block/virtio_blk.c</code>。<code>./driver/virtio</code>子目录下提供了<code>virtio</code>接口的实现(<code>virtio</code>设备、驱动、<code>virtqueue</code>和环形缓冲区)。<code>virtio</code>也被用在了高性能计算(High-Performance Computing, HPC)研究之中，使用共享内存传递内部虚拟机的信息。特别的，这使用了<code>virtio</code>来实现虚拟化PCI接口。可以再resources中找到相关工作。</p><p>你可以在Linux内核中练习半虚拟化基础工作。你所需要的就是一个作为hypervisor的内核，客户机内核和用来仿真设备的QEMU。你可以使用KVM(一个存在于宿主机内核中的模块)或者Rusty Russell的lguest（一个修改过的Linux内核）。两种方案都支持<code>virtio</code>（配合以QEMU进行系统模拟和<code>libvirt</code>进行虚拟化管理）。</p><p>Rusty的成果是简化了半虚拟化驱动的开发，并且设备仿真性能更高。最重要的还是，<code>virtio</code>能够提供更好地性能（两三倍的网络I/O）比现有的商业解决方案。虽说有一定的代价，但如果你的hypervisor和客户机系统是Linux，还是非常值得的。</p><h2 id=进一步>进一步<a hidden class=anchor aria-hidden=true href=#进一步>#</a></h2><p>尽管你可以永远不会为<code>virtio</code>开发前端或者后端驱动，但它实现了一个有趣的架构，值得更加细致的理解它。与先前的Xen相比，<code>virtio</code>为了半虚拟化提高性能提供了新的可能。在作为投入使用的hypervisor和新虚拟技术的实验平台中，Linux不断地证明了它自己。<code>virtio</code>再一次证明了Linux作为hypervisor的优势和开放性。</p><h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2><ol><li><p><a href="http://portal.acm.org/citation.cfm?id=1400097.1400108">Virtio: towards a de factor standard for virtual I/O devices</a></p></li><li><p><a href=https://www.ibm.com/developerworks/linux/library/l-hypervisor/index.html>Anatomy of a Linux hypervisor</a></p></li><li><p><a href=http://www.ibm.com/developerworks/linux/library/l-pci-passthrough/index.html>Linux virtualization and PCI passthrough</a></p></li><li><p><a href=http://blog.loftninjas.org/2008/10/22/kvm-virtio-network-performance/>performance advantage of virtio using KVM</a></p></li><li><p><a href=http://wiki.libvirt.org/page/Virtio>libvirt wiki</a></p></li><li><p><a href=http://lguest.ozlabs.org/>lguest</a></p></li><li><p><a href=http://www.linux-kvm.org/page/Main_Page>KVM</a></p></li><li><p><a href=http://www.springerlink.com/content/b1676363881h5662/>shared-memory message passing</a></p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://hhdx.xyz/tags/qemu/>Qemu</a></li><li><a href=https://hhdx.xyz/tags/virtio/>Virtio</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hhdx.xyz/>hhdx's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>