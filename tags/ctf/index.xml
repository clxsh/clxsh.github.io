<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CTF on hhdx's blog</title><link>https://hhdx.xyz/tags/ctf/</link><description>Recent content in CTF on hhdx's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 30 Nov 2020 12:05:03 +0000</lastBuildDate><atom:link href="https://hhdx.xyz/tags/ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>HITB GSEC 2017：babyqemu</title><link>https://hhdx.xyz/post/babyqemu/</link><pubDate>Mon, 30 Nov 2020 12:05:03 +0000</pubDate><guid>https://hhdx.xyz/post/babyqemu/</guid><description>&lt;p>题目下载地址：&lt;a href="https://github.com/kitctf/writeups/blob/master/hitb-gsec-2017/babyqemu/babyqemu.tar.gz">babyqemu.tar.gz&lt;/a>&lt;/p>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>&lt;code>tar xvzf babyqemu.tar.gz&lt;/code>解压看到启动脚本&lt;code>launch.sh&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="cp">#! /bin/sh
&lt;/span>&lt;span class="cp">&lt;/span>./qemu-system-x86_64 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-initrd ./rootfs.cpio &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-kernel ./vmlinuz-4.8.0-52-generic &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-append &lt;span class="s1">&amp;#39;console=ttyS0 root=/dev/ram oops=panic panic=1&amp;#39;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-enable-kvm &lt;span class="se">\ &lt;/span> &lt;span class="c1"># 需要CPU virtualization，现在与hyper-v共存的VMware不支持此选项。可以删掉&lt;/span>
-monitor /dev/null &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-m 64M --nographic -L ./dependency/usr/local/share/qemu &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-L pc-bios &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-device hitb,id&lt;span class="o">=&lt;/span>vda
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在最后一行可以看到设备名称为hitb，在ida左侧Functions window，ctrl+f搜索hitb就可以找到相关函数。通过在ida的Local Types窗口搜索hitb可以找到&lt;code>HitbState&lt;/code>结构体，其中还包含&lt;code>dma_state&lt;/code>结构体。&lt;/p></description></item><item><title>Qemu Escape ---- 以BlizzardCTF2017_STRNG为例</title><link>https://hhdx.xyz/post/qemu-pwn/</link><pubDate>Mon, 23 Nov 2020 15:05:17 +0000</pubDate><guid>https://hhdx.xyz/post/qemu-pwn/</guid><description>&lt;p>最近想学一下qemu escape的基础知识，进而分析一些Qemu的CVE漏洞。&lt;/p>
&lt;p>本文主要参考raycp师傅的两篇文章。[1] [2]&lt;/p>
&lt;h2 id="qemu概述">Qemu概述&lt;/h2>
&lt;p>每个运行的qemu虚拟机对应于host上的一个进程，虚拟机的执行线程（如CPU线程、I/O线程等）对应于qemu进程中的一个线程。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/clxsh/pics/master/imgqemu-architecture.png" alt="qemu-architecture">&lt;/p>
&lt;p>qemu的内存结构，根据&lt;a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html">QEMU Case Study&lt;/a>，虚拟机对应的内存结构为如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> Guest&amp;#39; processes
+--------------------+
Virtual addr space | |
+--------------------+
| |
\__ Page Table \__
\ \
| | Guest kernel
+----+--------------------+----------------+
Guest&amp;#39;s phy. memory | | | |
+----+--------------------+----------------+
| |
\__ \__
\ \
| QEMU process |
+----+------------------------------------------+
Virtual addr space | | |
+----+------------------------------------------+
| |
\__ Page Table \__
\ \
| |
+----+-----------------------------------------------++
Physical memory | | ||
+----+-----------------------------------------------++
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Kernel Pwn: 从入门到入土</title><link>https://hhdx.xyz/post/kernel-pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</link><pubDate>Sun, 25 Oct 2020 19:12:40 +0000</pubDate><guid>https://hhdx.xyz/post/kernel-pwn-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</guid><description>&lt;h2 id="misc">MISC&lt;/h2>
&lt;h3 id="内核文件区别">内核文件区别&lt;/h3>
&lt;p>&lt;code>vmlinux&lt;/code> 是静态链接的可执行文件，未压缩的内核，最原始的文件，可以用来调试。&lt;/p>
&lt;p>&lt;code>vmlinuz&lt;/code> 是可引导的、压缩的内核。没有调试信息等数据，不可用于调试。启动时会自解压，通常会显示以下信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Decompressing Linux... done
Booting the kernel.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>zImage&lt;/code> 是经过压缩的小内核（小于512KB）。&lt;/p>
&lt;p>&lt;code>bzImage&lt;/code> 是经过压缩的大内核（大于512KB）。&lt;/p>
&lt;h3 id="initial-ramdisk">Initial Ramdisk&lt;/h3>
&lt;p>名字类似&lt;code>initramfs.cpio&lt;/code> 文件，一般可以使用cpio读取其中的文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ find . &lt;span class="p">|&lt;/span> cpio -o --format&lt;span class="o">=&lt;/span>newc &amp;gt; initramfs.cpio &lt;span class="c1"># compress&lt;/span>
$ sudo cpio -idmv &amp;lt; initramfs.cpio &lt;span class="c1"># depress&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有时也经过了gzip的压缩。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ mv initramfs.cpio initramfs.cpio.gz
$ gunzip initramfs.cpio.gz &lt;span class="c1"># 解压得到initramfs.cpio&lt;/span>
$ cpio -idmv &amp;lt; initramfs.cpio
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>更改为正确的后缀之后，图形界面“归档管理器”也可以打开。&lt;/p></description></item><item><title>Arm Pwn</title><link>https://hhdx.xyz/post/arm-pwn/</link><pubDate>Sat, 17 Oct 2020 17:35:26 +0000</pubDate><guid>https://hhdx.xyz/post/arm-pwn/</guid><description>&lt;h2 id="环境配置">环境配置&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ sudo apt install qemu-user gdb-multiarch
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装完成后就可以运行平台上的静态链接文件了，会自动调用qemu执行。&lt;/p>
&lt;h3 id="动态链接程序">动态链接程序&lt;/h3>
&lt;p>对于动态链接的程序，还需要安装跨平台的lib。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ apt-cache search &lt;span class="s2">&amp;#34;libc&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> grep arm
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装类似libc6-ARCH-cross。&lt;/p>
&lt;p>动态链接库被安装在类似&lt;code>/usr/arm-linux-gnueabihf/&lt;/code>的路径。qemu不知道动态链接的位置，它预期在类似&lt;code>/etc/qemu-binfmt/arm&lt;/code>的路径，所以可以设置软链接来避免用&lt;code>-L&lt;/code>来指定链接库位置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ sudo mkdir /etc/qemu-binfmt
$ sudo ln -s /usr/arm-linux-gnueabihf /etc/qemu-binfmt/arm
$ sudo ln -s /usr/aarch64-linux-gnu/ /etc/qemu-binfmt/aarch64 &lt;span class="c1"># 对于aarch64&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>pwnable.tw re-alloc_revenge</title><link>https://hhdx.xyz/post/pwnable-tw-re-alloc-revenge/</link><pubDate>Mon, 07 Sep 2020 14:48:20 +0000</pubDate><guid>https://hhdx.xyz/post/pwnable-tw-re-alloc-revenge/</guid><description>&lt;h2 id="题目分析">题目分析&lt;/h2>
&lt;p>防护比&lt;a href="https://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/">re-alloc&lt;/a>多了FULL RELRO和PIE。其他没有改变。&lt;/p>
&lt;h2 id="总体思路">总体思路&lt;/h2>
&lt;p>程序没有show函数，所以通过修改stdout的方式泄露libc。&lt;/p>
&lt;p>将一个chunk同时释放到tcache和unsorted bin，partial overwrite fd部分，指向stdout，需要爆破4bit。取得stdout后修改进行泄露。&lt;/p>
&lt;p>最后修改&lt;code>__realloc_hook&lt;/code>为one_gadget得到shell。&lt;/p>
&lt;p>主要难点在布局构造。&lt;/p></description></item><item><title>pwnable.tw tcache_tear seethefile</title><link>https://hhdx.xyz/post/pwnable-tw-tcache-tear-seethefile/</link><pubDate>Wed, 19 Aug 2020 17:26:17 +0000</pubDate><guid>https://hhdx.xyz/post/pwnable-tw-tcache-tear-seethefile/</guid><description>&lt;h1 id="tcache_tear">tcache_tear&lt;/h1>
&lt;h2 id="分析">分析&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Arch: amd64-64-little
RELRO: Full RELRO
Stack: Canary found
NX: NX enabled
PIE: No PIE (0x400000)
FORTIFY: Enabled
libc_version: Ubuntu GLIBC 2.27-3ubuntu1
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>程序开始在bss段上读入了一个0x20的名字&lt;/p>
&lt;p>malloc: 输入指定size，分配，指针ptr同样存储在bss，读入size-16的字符，这里字符个数可以溢出&lt;/p>
&lt;p>free: 释放ptr空间，指针悬空，可以double free，程序使用了tcache，且在这个版本释放没有任何的检查&lt;/p>
&lt;p>info: 打印姓名&lt;/p>
&lt;h2 id="总体思路">总体思路&lt;/h2>
&lt;p>利用tcache double free，可以对任意地址进行改写。在name处伪造一个chunk释放到unsorted bin，进行libc base的泄露。将&lt;code>__free_hook&lt;/code>改写为system地址。&lt;/p>
&lt;p>伪造chunk注意绕过free的所有检查。伪造完成的结构如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">+----------+
| |
| |
| 0x421 |
| |
+----------+
| 0x21 |
+----------+
| 0x21 |
+----------+
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>tcache默认最多有64个，第1个是0x20大小，递推第64个也就是0x410。所以将name处伪造为0x420大小。第一个chunk的&lt;code>chunk-&amp;gt;size=0x420|pre_in_use&lt;/code>，避免backward consolidate，第三个chunk的&lt;code>chunk-&amp;gt;size=0x20|pre_in_use&lt;/code>，避免forward consolidate。&lt;/p></description></item><item><title>确定glibc版本,以指定glibc运行程序</title><link>https://hhdx.xyz/post/%E4%BB%A5%E6%8C%87%E5%AE%9Alibc%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</link><pubDate>Sat, 08 Aug 2020 09:08:15 +0000</pubDate><guid>https://hhdx.xyz/post/%E4%BB%A5%E6%8C%87%E5%AE%9Alibc%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>CTF题目中经常会给出libc的文件，首先需要做的就是确定libc的版本，对程序进行针对性的攻击。最直接的确定方法就是直接运行该libc&lt;code>./libc.so.6&lt;/code>，但通常由于本机ld版本与libc版本不匹配，发生段错误。&lt;/p>
&lt;p>确定完大版本号还不够，因为就算是同一版本的libc也会有较大的变动。比方说，与最开始的2.29版本相比，gnu libc库的release/2.29/master分支的&lt;code>tcache_perthread_struct-&amp;gt;counts&lt;/code>的变量类型都变了；&lt;code>__libc_malloc&lt;/code>中取用tcache的判定，也由判断指针是否为空变成了判断counts是否大于0。这些细节很大程度上影响了exploit的书写。&lt;/p>
&lt;p>下面以pwnable.tw re-alloc的&lt;a href="https://github.com/clxsh/ctf_wps/blob/master/pwnable.tw/Re-alloc/libc.so.6">libc&lt;/a>为例，写一写我的经验。&lt;/p></description></item><item><title>pwnable.tw re-alloc</title><link>https://hhdx.xyz/post/pwnable-tw-re-alloc/</link><pubDate>Fri, 07 Aug 2020 22:11:47 +0000</pubDate><guid>https://hhdx.xyz/post/pwnable-tw-re-alloc/</guid><description>&lt;h2 id="题目分析">题目分析&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Arch: amd64-64-little
RELRO: Partial RELRO
Stack: Canary found
NX: NX enabled
PIE: No PIE (0x400000)
FORTIFY: Enabled
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是一个典型的菜单类程序&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$$$$$$$$$$$$$$$$$$$$$$$$$$$$
🍊 RE Allocator 🍊
$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$ 1. Alloc $
$ 2. Realloc $
$ 3. Free $
$ 4. Exit $
$$$$$$$$$$$$$$$$$$$$$$$$$$$
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>Alloc: index只能取0或1；size必须&amp;lt;=0x78；然后使用&lt;code>realloc(0, size)&lt;/code>分配，通过源码可以看出，这就相当于&lt;code>malloc(size)&lt;/code>。这里存在null byte overflow（然而没什么用似乎，一开始我一直卡在这里想如何利用，完全没注意到后一个漏洞。。。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/* realloc of null is supposed to be same as malloc */&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">oldmem&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">__libc_malloc&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>Realloc: size同样&amp;lt;=0x78。realloc有几种情况：请求大小自己可以满足；尝试向后扩展(top chunk或!inuse (next))；&lt;code>__int_malloc&lt;/code>请求新块。（这里存在UAF，输入size为0&lt;/li>
&lt;li>Free：&lt;code>realloc(ptr, 0)&lt;/code>相当于&lt;code>free(ptr)&lt;/code>，同时将指针数组置空。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">oldmem&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">__libc_free&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">oldmem&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>libc_version: glibc 2.29 with tcache。该版本libc的&lt;a href="https://launchpad.net/ubuntu/+source/glibc/2.29-0ubuntu2">源码&lt;/a>。下一篇文章说一下如何确定的libc版本，如何确定的有tcache，以及如何使用指定libc运行程序。&lt;/p>
&lt;p>此外，这个版本中出现了对tcache double free的一个&lt;a href="https://hhdx.xyz/2020/08/01/How2heap%E6%80%BB%E7%BB%93/#fastbin-dup">检查机制&lt;/a>。&lt;/p></description></item><item><title>How2heap总结</title><link>https://hhdx.xyz/post/how2heap%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 01 Aug 2020 19:36:10 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap%E6%80%BB%E7%BB%93/</guid><description>&lt;h2 id="first-fit">first-fit&lt;/h2>
&lt;p>如果一个chunk可用且足够大，那么就会使用这个chunk。&lt;/p>
&lt;h2 id="calc_tcache_idx">calc_tcache_idx&lt;/h2>
&lt;p>tcache(thread local caching)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */&lt;/span>
&lt;span class="cp"># define TCACHE_MAX_BINS 64
&lt;/span>&lt;span class="cp"># define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cm">/* Only used to pre-fill the tunables. */&lt;/span>
&lt;span class="cp"># define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cm">/* When &amp;#34;x&amp;#34; is from chunksize(). */&lt;/span>
&lt;span class="cp"># define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="cm">/* When &amp;#34;x&amp;#34; is a user-provided size. */&lt;/span>
&lt;span class="cp"># define usize2tidx(x) csize2tidx (request2size (x))
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cm">/* With rounding and alignment, the bins are...
&lt;/span>&lt;span class="cm"> idx 0 bytes 0..24 (64-bit) or 0..12 (32-bit)
&lt;/span>&lt;span class="cm"> idx 1 bytes 25..40 or 13..20
&lt;/span>&lt;span class="cm"> idx 2 bytes 41..56 or 21..28
&lt;/span>&lt;span class="cm"> etc. */&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>tcache拥有和fastbin差不多的结构。默认情况下，64个bin，每个bin最多7个chunk&lt;/p>
&lt;p>64bit: &lt;code>IDX = (CHUNKSIZE - 0x11) / 0x10&lt;/code>&lt;/p></description></item><item><title>How2heap--tcache_stashing_unlink_attack Hitcon2019--one_punch</title><link>https://hhdx.xyz/post/how2heap-tcache-stashing-unlink-attack-hitcon2019-one-punch/</link><pubDate>Fri, 31 Jul 2020 21:40:45 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-tcache-stashing-unlink-attack-hitcon2019-one-punch/</guid><description>&lt;h2 id="tcache-stashing-unlink-attack">tcache stashing unlink attack&lt;/h2>
&lt;p>在tcache中布置5个chunk，对应大小的small bin中布置2个chunk。修改倒数第二个small chunk的bk指向target，target-&amp;gt;bk写入一个可写的位置。使用calloc触发，因为calloc调用&lt;code>_int_malloc&lt;/code>不会使用tcache进行分配（除了&lt;code>_int_malloc&lt;/code>遍历unsorted bin的尾部），只会往tcache中填充。&lt;/p>
&lt;p>可以造成target-&amp;gt;bk-&amp;gt;fd位置写入大数字，并且target成为tcache中第一个，再次malloc就可以获得。&lt;/p>
&lt;p>有点像fastbin reverse into tcache。&lt;/p>
&lt;h3 id="variation">variation&lt;/h3>
&lt;p>在tcache中布置6个chunk，对应大小的small bin中布置2个chunk。（可以用unsorted bin切割的方式布置2个small bin）&lt;/p>
&lt;p>修改倒数第二个small chunk的bk，calloc触发，只在bk-&amp;gt;fd写入大数字。&lt;/p></description></item><item><title>How2heap--house_of_orange Hitcon2016--houseoforange</title><link>https://hhdx.xyz/post/how2heap-house-of-orange-hitcon2016-houseoforange/</link><pubDate>Sat, 25 Jul 2020 18:14:07 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-house-of-orange-hitcon2016-houseoforange/</guid><description>&lt;h2 id="house-of-orange">house of orange&lt;/h2>
&lt;p>修改&lt;code>topchunk-&amp;gt;size&lt;/code>为一个缩小的并且满足页对齐的大小，malloc一个大于size的块（但也不要大于mmap threshold），会导致原来topchunk被放入unsorted bin。&lt;/p>
&lt;p>当topchunk不足以分配所需空间时，会调用sysmalloc分配额外空间。一般情况下，main_arena中old top chunk和新分配的top chunk首尾相邻，从而会进行合并。当我们将&lt;code>topchunk-&amp;gt;size&lt;/code>减小后，会检测不到相邻，也就不会合并了。设置好fencepost chunk，会执行&lt;code>_int_free (av, old_top, 1)&lt;/code>将其放入unsorted bin。&lt;/p>
&lt;p>代码涉及&lt;code>_int_malloc&lt;/code>后边和&lt;code>sysmalloc&lt;/code>。&lt;/p></description></item><item><title>How2heap--house_of_einherjar SECON2016--tinypad</title><link>https://hhdx.xyz/post/how2heap-house-of-einherjar-secon2016-tinypad/</link><pubDate>Thu, 23 Jul 2020 09:57:08 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-house-of-einherjar-secon2016-tinypad/</guid><description>&lt;h2 id="house-of-einherjar">house of einherjar&lt;/h2>
&lt;p>和house of force很像，都是篡改top chunk。&lt;/p>
&lt;p>off-by-one覆盖victim chunk的&lt;code>pre_in_use&lt;/code>位，并修改&lt;code>victim-&amp;gt;pre_size&lt;/code>为距离目标地址的大小，在目标地址处伪造chunk，释放victim时，发生backward consolidate，合并到目标地址。&lt;/p>
&lt;p>&lt;strong>victim需要临近top chunk&lt;/strong>，backward consolidate结束，接着与top chunk进行forward consolidate。如果不这样，这个块被放入unsorted bin，而在unsorted bin中分配会过不了以下检查。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">__builtin_expect&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">chunksize_nomask&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">victim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">SIZE_SZ&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">||&lt;/span> &lt;span class="n">__builtin_expect&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">chunksize_nomask&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">victim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">av&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">system_mem&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">malloc_printerr&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;malloc(): memory corruption&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>How2heap--large_bin_attack 0ctf2018--heapstorm2</title><link>https://hhdx.xyz/post/how2heap-large-bin-attack-0ctf2018-heapstorm2/</link><pubDate>Sat, 18 Jul 2020 21:10:54 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-large-bin-attack-0ctf2018-heapstorm2/</guid><description>&lt;h2 id="large-bin-attack">large bin attack&lt;/h2>
&lt;p>对已存在于large bin中的chunk的bk、bk_nextsize字段进行更改，在unsorted bin中取出插入该large bin时，会将bk-&amp;gt;fd、bk_nextsize-&amp;gt;fd_nextsize的位置覆盖成chunk的地址。涉及的代码就是unsorted bin遍历取出插入那块。和先前的unsorted bin attack类似，通常为进一步攻击做准备，如修改global_max_fast。&lt;/p>
&lt;p>这里比较难理解就是large bin的结构，特别是先前我被一个&lt;a href="https://raw.githubusercontent.com/clxsh/pics/master/img/largebin.png">large bin结构图&lt;/a>所误导，下面给出我画的结构图（如果有错误o((⊙﹏⊙))o，请帮忙指出）。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/clxsh/pics/master/img/large_bin2.png" alt="glibc large bin">&lt;/p>
&lt;h2 id="0ctf2018-heapstorm2">0ctf2018 heapstorm2&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Arch: amd64-64-little
RELRO: Full RELRO
Stack: Canary found
NX: NX enabled
PIE: PIE enabled
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="功能分析">功能分析&lt;/h3>
&lt;p>程序首先使用mallopt函数将global_max_fast设置为0，也就是不使用fastbin。&lt;/p></description></item><item><title>How2heap--unsorted_bin_attack 0ctf2016--zerostorage</title><link>https://hhdx.xyz/post/how2heap-unsorted-bin-attack-0ctf2016-zerostorage/</link><pubDate>Sun, 12 Jul 2020 10:01:35 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-unsorted-bin-attack-0ctf2016-zerostorage/</guid><description>&lt;h2 id="unsorted-bin-attack">unsorted bin attack&lt;/h2>
&lt;p>对unsorted bin中的&lt;code>chunk-&amp;gt;bk&lt;/code>进行修改，接下来该chunk分配出去时，&lt;code>chunk-&amp;gt;bk-&amp;gt;fd&lt;/code>就被赋值为unsortedbin头结点地址。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">bck&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">victim&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">bk&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="cm">/* remove from unsorted list */&lt;/span>
&lt;span class="n">unsorted_chunks&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">av&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">bk&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bck&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">bck&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">unsorted_chunks&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">av&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在glibc2.28中增加了以下检查，使得此攻击失效。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">__glibc_unlikely&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bck&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">fd&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">victim&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">malloc_printerr&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;malloc(): corrupted unsorted chunks 3&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>unsorted bin attack通常为进一步的攻击做准备，比如覆写global_max_fast。&lt;/p>
&lt;h2 id="0ctf2016-zerostorage">0ctf2016 zerostorage&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Arch: amd64-64-little
RELRO: Full RELRO
Stack: Canary found
NX: NX enabled
PIE: PIE enabled
FORTIFY: Enabled
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关键数据结构&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/clxsh/pics/master/img/image-20200712102723178.png" alt="image-20200712102723178">&lt;/p>
&lt;p>flag：标识该节点是否存在&lt;/p>
&lt;p>size：记录大小&lt;/p>
&lt;p>content：数据块指针&lt;/p>
&lt;p>程序有以下功能&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">1. Insert
2. Update
3. Merge
4. Delete
5. View
6. List
7. Exit
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>insert：获取数据块大小，并读入数据。数据块大小在128~4096这个范围内&lt;/p>
&lt;p>update：对数据块进行大小内容进行更新&lt;/p>
&lt;p>merge：将两节点合并。这里存在漏洞，输入两次相同的id，导致UAF。这个漏洞我没发现，思维还不够猥琐啊&lt;/p>
&lt;p>delete：释放数据块，清空节点&lt;/p>
&lt;h3 id="总体思路">总体思路&lt;/h3>
&lt;p>通过UAF，首先泄露libc基址，然后修改其bk指针，使用unsorted bin attack修改global_max_fast变量；fastbin bin attack覆写&lt;code>__free_hook&lt;/code>为system函数地址。&lt;/p></description></item><item><title>How2heap--house_of_force Bctf2016--bcloud</title><link>https://hhdx.xyz/post/how2heap-house-of-force-bctf2016-bcloud/</link><pubDate>Tue, 07 Jul 2020 14:46:39 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-house-of-force-bctf2016-bcloud/</guid><description>&lt;h2 id="house-of-force">House of force&lt;/h2>
&lt;p>溢出修改topchunk的size，分配一个使size_t溢出的evil_size，使下一次分配在目标位置，进行修改。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/*
&lt;/span>&lt;span class="cm">* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
&lt;/span>&lt;span class="cm">* new_top = old_top + nb
&lt;/span>&lt;span class="cm">* nb = new_top - old_top
&lt;/span>&lt;span class="cm">* req + 2sizeof(long) = new_top - old_top
&lt;/span>&lt;span class="cm">* req = new_top - old_top - 2sizeof(long)
&lt;/span>&lt;span class="cm">* req = dest - 2sizeof(long) - old_top - 2sizeof(long)
&lt;/span>&lt;span class="cm">* req = dest - old_top - 4*sizeof(long)
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="bctf2016-bcloud">Bctf2016 bcloud&lt;/h2>
&lt;h3 id="分析">分析&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Arch: i386-32-little
RELRO: Partial RELRO
Stack: Canary found
NX: NX enabled
PIE: No PIE (0x8047000)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>程序一开始让输入name、org、hostname，输入字符串函数存在null byte overflow。&lt;/p>
&lt;p>输入name函数中，字符串数组在栈中后部紧邻指针变量，所以strcpy会将该指针一并拷贝入0x40的空间（实际可用0x44），并且null byte覆盖topchunk的最低字节。可以泄露堆的地址&lt;/p>
&lt;p>输入org、hostname函数中，存在同样问题，可覆盖的更多的字节。可以覆盖topchunk的size&lt;/p></description></item><item><title>How2heap--overlapping_chunks Hack.lu2015--bookstore</title><link>https://hhdx.xyz/post/how2heap-overlapping-chunks-hack-lu2015-bookstore/</link><pubDate>Sun, 05 Jul 2020 18:45:39 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-overlapping-chunks-hack-lu2015-bookstore/</guid><description>&lt;h2 id="overlapping-chunks">overlapping chunks&lt;/h2>
&lt;p>溢出对unsortedbin中的&lt;code>chunk-&amp;gt;size&lt;/code>进行修改，造成堆块重叠。&lt;/p>
&lt;h2 id="hacklu2015-bookstore">hack.lu2015 bookstore&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Arch: amd64-64-little
RELRO: No RELRO
Stack: Canary found
NX: NX enabled
PIE: No PIE (0x3ff000)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>程序是一个订书系统，在main函数开始处，连续分配3个0x80的空间，一个存储订单1——order1，一个存储订单2——order2，一个存储提示信息——info。有以下功能菜单&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">1: Edit order 1
2: Edit order 2
3: Delete order 1
4: Delete order 2
5: Submit
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Edit order 1/2：order1/order2使用fgetc读取字符串，读到&lt;code>\n&lt;/code>终止，所以这里存在溢出&lt;/p>
&lt;p>Delete order 1/2：free掉order1/order2。这里存在指针悬空&lt;/p>
&lt;p>Submit： 分配0x140的空间（称为orderlist）将order1和order2拼接。这里存在溢出&lt;/p>
&lt;p>程序末尾&lt;code>printf(info)&lt;/code>存在可能的格式化字符串漏洞。&lt;/p>
&lt;h3 id="overlapping-chunks--format-string-vulnerability">overlapping chunks &amp;amp;&amp;amp; format string vulnerability&lt;/h3></description></item><item><title>How2heap--poison_null_byte Plaidctf2015--plaiddb</title><link>https://hhdx.xyz/post/how2heap-poison-null-byte-plaidctf2015-plaiddb/</link><pubDate>Fri, 03 Jul 2020 00:16:56 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-poison-null-byte-plaidctf2015-plaiddb/</guid><description>&lt;h2 id="poison-null-byte">Poison null byte&lt;/h2>
&lt;p>关于堆块重叠，可以看这篇&lt;a href="https://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html">文章&lt;/a>，图文并茂。&lt;/p>
&lt;p>glibc2.26中，在unlink宏中加入了&lt;code>size==prev_size(next_chunk)&lt;/code>的检查，与下一chunk所存储的pre_size进行了比对，在&lt;code>poison_null_byte.c&lt;/code>中相应的添加了&lt;code>*(size_t*)(b+0x1f0) = 0x200&lt;/code>，可以绕过这个检查，所以how2heap的README中对glibc的要求是&lt;code>&amp;lt;2.26&lt;/code>应该是忘了改。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">chunk b +------&amp;gt; +----------+
| |
+----------+ &amp;lt;---------+ size
| 0X200 |
+----------+ &amp;lt;---------+ b
| |
| |
| |
| |
| |
| |
| |
| |
| |
+----------+ &amp;lt;--------+ fake pre_size
| 0X200 |
+----------+
| |
chunk c +------&amp;gt; +----------+ &amp;lt;--------+ pre_size
| 0X210 |
+----------+
| |
| |
| |
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>触发unlink的流程&lt;/strong>：通过null byte溢出伪造完0x200的chunk后，此时该chunk存在于unsortedbin。再次分配0x100的b1时，遍历unsortedbin，该chunk被放入到smallbin中，unsortedbin里的chunk也就这一个，遍历结束无法分配。又通过查找binmap找到0x200的smallbin，这时触发的unlink，将该chunk从smallbin中取出。&lt;/p></description></item><item><title>how2heap--House_of_Spirit Hack.lu2014--oreo</title><link>https://hhdx.xyz/post/how2heap-house-of-spirit-hacklu2014-oreo/</link><pubDate>Wed, 01 Jul 2020 14:13:34 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-house-of-spirit-hacklu2014-oreo/</guid><description>&lt;h2 id="house-of-spirit">House of Spirit&lt;/h2>
&lt;p>该攻击手法的主要是思想是，在不可控区域的前后伪造chunk信息，覆盖某指针指向&lt;code>chunk2mem(fake_chunk)&lt;/code>，释放该指针后再次申请，对不可控区域的进行改写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">+---------------+
| 可 控 区 域 |
+---------------+
| |
| 不 可 控 区 域 |
| |
| 一 般 为 某 些 |
| 指 针 |
+---------------+
| 可 控 区 域 |
+---------------+
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>伪造的chunk也通常是fastbin，因为检查容易绕过。&lt;/p></description></item><item><title>How2heap--fastbin_dup_consolidate Hitcon2016--SleepyHolder</title><link>https://hhdx.xyz/post/how2heap-fastbin-dup-consolidate-hitcon2016-sleepyholder/</link><pubDate>Sun, 28 Jun 2020 23:01:43 +0000</pubDate><guid>https://hhdx.xyz/post/how2heap-fastbin-dup-consolidate-hitcon2016-sleepyholder/</guid><description>&lt;h2 id="前置">前置&lt;/h2>
&lt;p>Ubuntu 16.04&lt;/p>
&lt;p>使用how2heap脚本编译glibc2.25，其中的4是编译线程数。脚本中&lt;code>git clone&lt;/code>慢，可以替换成&lt;a href="https://mirrors.tuna.tsinghua.edu.cn/">tsinghua mirrors&lt;/a>，把第83行的&lt;code>git clone git://sourceware.org/git/glibc.git &amp;quot;$SRC&amp;quot;&lt;/code> 替换成&lt;code> git clone https://mirrors.tuna.tsinghua.edu.cn/git/glibc.git &amp;quot;$SRC&amp;quot;&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ ./glibc_build.sh 2.25 -j &lt;span class="m">4&lt;/span> -disable-tcache
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>做这道题目使用了glibc2.25，&lt;code>patchelf --set-interpreter /path/to/ld-2.25.so /path/to/exe&lt;/code>，patch之后再运行程序就自动使用同目录下libc-2.25.so。&lt;/p></description></item><item><title>glibc heap 整理</title><link>https://hhdx.xyz/post/glibcheap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hhdx.xyz/post/glibcheap/</guid><description>&lt;p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。&lt;/p>
&lt;p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，&lt;strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系&lt;/strong>。&lt;/p>
&lt;h2 id="基本操作">基本操作&lt;/h2>
&lt;h3 id="malloc">malloc&lt;/h3>
&lt;p>&lt;code>malloc(size_t n)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>当 n=0 时，返回当前系统允许的堆的最小内存块。&lt;/li>
&lt;li>当 n 为负数时，由于在大多数系统上，&lt;strong>size_t 是无符号数（这一点非常重要）&lt;/strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。&lt;/li>
&lt;/ul>
&lt;h3 id="free">free&lt;/h3>
&lt;p>&lt;code>free(void *p)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>当 p 为空指针时，函数不执行任何操作。&lt;/strong>&lt;/li>
&lt;li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 &lt;code>double free&lt;/code>。&lt;/li>
&lt;li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。&lt;/li>
&lt;/ul>
&lt;h2 id="背后的系统调用">背后的系统调用&lt;/h2>
&lt;p>这些函数背后的系统调用主要是 &lt;a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk&lt;/a> 函数以及 &lt;a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap&lt;/a> 函数。&lt;/p></description></item></channel></rss>