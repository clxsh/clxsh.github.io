<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Virtio on hhdx's blog</title><link>https://hhdx.xyz/tags/virtio/</link><description>Recent content in Virtio on hhdx's blog</description><generator>Hugo -- 0.145.0</generator><language>en</language><lastBuildDate>Fri, 27 Nov 2020 14:43:05 +0000</lastBuildDate><atom:link href="https://hhdx.xyz/tags/virtio/index.xml" rel="self" type="application/rss+xml"/><item><title>【翻译】Virtio：一种Linux I/O虚拟化框架</title><link>https://hhdx.xyz/post/virtio-intro/</link><pubDate>Fri, 27 Nov 2020 14:43:05 +0000</pubDate><guid>https://hhdx.xyz/post/virtio-intro/</guid><description>&lt;p>首发于安全客&lt;a href="https://www.anquanke.com/post/id/224001">Virtio：一种Linux I/O虚拟化框架 - 安全客，安全资讯平台 (anquanke.com)&lt;/a>&lt;/p>
&lt;p>原文：&lt;a href="https://developer.ibm.com/articles/l-virtio/">Virtio: An I/O virtualization framework for Linux – IBM Developer&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>学习Virtio推荐首先看这一篇，国内好多文章写的太乱了，看来看不去都不明白整体的架构，给人很模糊的感觉。这篇文章好很多。&lt;/p>
&lt;p>&lt;strong>受限于个人水平，翻译肯定有不妥之处，译注根据自己的理解加入，也不一定准确。如有错误，还请不吝指出。&lt;/strong>&lt;/p>&lt;/blockquote>
&lt;p>简言之，&lt;code>virtio&lt;/code>是设备和半虚拟化管理程序(paravirtualized hypervisor)之间的一个抽象层。&lt;code>virtio&lt;/code>是Rusty Russell为了支持他自己的虚拟化方案&lt;code>lguest&lt;/code>而开发的。这篇文章以对半虚拟化和设备仿真的介绍开始，然后探寻&lt;code>virtio&lt;/code>中的一些细节。采用kernel 2.6.30版本的&lt;code>virtio&lt;/code>框架进行讲解。&lt;/p>
&lt;p>Linux是hypervisor的“游乐场”。正如我在文章&lt;a href="https://developer.ibm.com/tutorials/l-hypervisor/">使用Linux作为hypervisor&lt;/a>中所展现的，Linux提供了许多具有不同特性和优势的虚拟化解决方案。例如KVM(Kernel-based Virtual Machine)，&lt;code>lguest&lt;/code>、和用户态的Linux。在Linux使用这些虚拟化解决方案给操作系统造成了重担，因为它们各自都有独立的需求。其中一个问题就是设备的虚拟化。&lt;code>virtio&lt;/code>为各种各样设备（如：网络设备、块设备等等）的虚拟提供了通用的标准化前端接口，增加了各个虚拟化平台的代码复用。而不是各自为政般的使用繁杂的设备虚拟机制。&lt;/p>
&lt;h2 id="全虚拟化-vs-半虚拟化">全虚拟化 vs. 半虚拟化&lt;/h2>
&lt;p>我们先来讨论两种完全不同的虚拟化方案：全虚拟化和半虚拟化。在全虚拟化中，客户操作系统在hypervisor上运行，相当于运行于裸机一般。客户机不知道它在虚拟机还是物理机中运行，不需要修改操作系统就可以直接运行。与此相反的是，在半虚拟化中，客户机操作系统不仅能够知道其运行于虚拟机之上，也必须包含与hypervisor进行交互的代码。但是能够在客户机和hypervisor的切换中，带来更高的效率（图1）。&lt;/p>
&lt;p>&lt;em>译注：客户机与hypervisor的切换举例：客户机请求I/O，需要hypervisor中所虚拟的设备来响应请求，此时就会发生切换。&lt;/em>&lt;/p>
&lt;p>在全虚拟化中，hypervisor必须仿真设备硬件，也就是说模仿硬件最底层的会话（如：网卡驱动）。尽管这种仿真看起来方便，但代价是极低的效率和高度的复杂性。在半虚拟化中，客户机与hypervisor可以共同合作让这种仿真具有更高的效率。半虚拟化不足就是客户机操作系统会意识到它运行于虚拟机之中，而且需要对客户机操作系统做出一定的修改。&lt;/p></description></item></channel></rss>